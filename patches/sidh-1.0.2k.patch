From 9e5f079522ca4b2723a130ceed31fb79d0e343b1 Mon Sep 17 00:00:00 2001
From: Colin Stanfill <colin.stanfill@gmail.com>
Date: Mon, 20 Feb 2017 14:44:46 -0500
Subject: [PATCH] Apply sidh-1.0.2g patch and resolve conflicts

---
 .gitignore                               |  121 ++
 Makefile                                 |   46 +-
 Makefile.org                             |    2 +-
 README.SIDH                              |   46 +
 apps/speed.c                             |  211 +++-
 crypto/err/err.h                         |    3 +
 crypto/err/openssl.ec                    |    1 +
 crypto/opensslconf.h                     |   15 +-
 crypto/sidh/Makefile                     |  113 ++
 crypto/sidh/sidh.h                       |  103 ++
 crypto/sidh/sidhkex_err.c                |  105 ++
 crypto/sidh/sidhkex_key.c                |  395 +++++++
 crypto/sidh/sidhkex_locl.h               |   44 +
 crypto/sidh/sidhkextest.c                |  212 ++++
 crypto/sidh/sidhlib/AMD64/fp_x64.c       |  865 ++++++++++++++
 crypto/sidh/sidhlib/AMD64/fp_x64_asm.S   | 1864 ++++++++++++++++++++++++++++++
 crypto/sidh/sidhlib/License.txt          |   21 +
 crypto/sidh/sidhlib/README.txt           |   46 +
 crypto/sidh/sidhlib/SIDH.c               |  102 ++
 crypto/sidh/sidhlib/SIDH.h               |  274 +++++
 crypto/sidh/sidhlib/SIDH_internal.h      |  429 +++++++
 crypto/sidh/sidhlib/SIDH_setup.c         |  265 +++++
 crypto/sidh/sidhlib/ec_isogeny.c         |  586 ++++++++++
 crypto/sidh/sidhlib/fpx.c                |  485 ++++++++
 crypto/sidh/sidhlib/generic/fp_generic.c |  251 ++++
 crypto/sidh/sidhlib/kex.c                |  387 +++++++
 crypto/sidh/sidhlib/makefile_kat_tests   |  109 ++
 crypto/sidh/sidhlib/validate.c           |  223 ++++
 ssl/Makefile                             | 1293 +++++++++++----------
 ssl/s3_clnt.c                            |  238 +++-
 ssl/s3_lib.c                             |   70 +-
 ssl/s3_srvr.c                            |  251 +++-
 ssl/ssl.h                                |    3 +
 ssl/ssl3.h                               |    7 +
 ssl/ssl_cert.c                           |    4 +
 ssl/ssl_ciph.c                           |    5 +
 ssl/ssl_err.c                            |    1 +
 ssl/ssl_lib.c                            |    8 +-
 ssl/ssl_locl.h                           |   11 +
 ssl/t1_lib.c                             |    6 +-
 ssl/t1_trce.c                            |   11 +-
 ssl/tls1.h                               |   15 +
 test/Makefile                            |  126 +-
 util/libeay.num                          |   18 +
 util/mk1mf.pl                            |    3 +
 util/mkdef.pl                            |   10 +-
 util/mkfiles.pl                          |    1 +
 47 files changed, 8670 insertions(+), 735 deletions(-)
 create mode 100644 .gitignore
 create mode 100644 README.SIDH
 create mode 100644 crypto/sidh/Makefile
 create mode 100644 crypto/sidh/sidh.h
 create mode 100644 crypto/sidh/sidhkex_err.c
 create mode 100644 crypto/sidh/sidhkex_key.c
 create mode 100644 crypto/sidh/sidhkex_locl.h
 create mode 100644 crypto/sidh/sidhkextest.c
 create mode 100644 crypto/sidh/sidhlib/AMD64/fp_x64.c
 create mode 100644 crypto/sidh/sidhlib/AMD64/fp_x64_asm.S
 create mode 100644 crypto/sidh/sidhlib/License.txt
 create mode 100644 crypto/sidh/sidhlib/README.txt
 create mode 100644 crypto/sidh/sidhlib/SIDH.c
 create mode 100644 crypto/sidh/sidhlib/SIDH.h
 create mode 100644 crypto/sidh/sidhlib/SIDH_internal.h
 create mode 100644 crypto/sidh/sidhlib/SIDH_setup.c
 create mode 100644 crypto/sidh/sidhlib/ec_isogeny.c
 create mode 100644 crypto/sidh/sidhlib/fpx.c
 create mode 100644 crypto/sidh/sidhlib/generic/fp_generic.c
 create mode 100644 crypto/sidh/sidhlib/kex.c
 create mode 100644 crypto/sidh/sidhlib/makefile_kat_tests
 create mode 100644 crypto/sidh/sidhlib/validate.c

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..a6a2262
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,121 @@
+# Object files
+*.o
+*.obj
+
+# editor artefacts
+*.swp
+.#*
+#*#
+*~
+/.dir-locals.el
+
+# Top level excludes
+/Makefile.bak
+/Makefile
+/MINFO
+/*.a
+/include
+/*.pc
+/rehash.time
+/inc.*
+/makefile.*
+/out.*
+/tmp.*
+
+# Most *.c files under test/ are symlinks
+/test/*.c
+# Apart from these
+!/test/asn1test.c
+!/test/methtest.c
+!/test/dummytest.c
+!/test/igetest.c
+!/test/r160test.c
+!/test/fips_algvs.c
+
+/test/*.ss
+/test/*.srl
+/test/.rnd
+/test/test*.pem
+/test/newkey.pem
+
+# Certificate symbolic links
+*.0
+
+# Links under apps
+/apps/CA.pl
+/apps/md4.c
+
+
+# Auto generated headers
+/crypto/buildinf.h
+/crypto/opensslconf.h
+
+# Auto generated assembly language source files
+*.s
+!/crypto/bn/asm/pa-risc2.s
+!/crypto/bn/asm/pa-risc2W.s
+crypto/aes/asm/a_win32.asm
+crypto/bf/asm/b_win32.asm
+crypto/bn/asm/bn_win32.asm
+crypto/bn/asm/co_win32.asm
+crypto/bn/asm/mt_win32.asm
+crypto/cast/asm/c_win32.asm
+crypto/cpu_win32.asm
+crypto/des/asm/d_win32.asm
+crypto/des/asm/y_win32.asm
+crypto/md5/asm/m5_win32.asm
+crypto/rc4/asm/r4_win32.asm
+crypto/rc5/asm/r5_win32.asm
+crypto/ripemd/asm/rm_win32.asm
+crypto/sha/asm/s1_win32.asm
+crypto/sha/asm/sha512-sse2.asm
+ms/uptable.asm
+
+# Executables
+/apps/openssl
+/test/sha256t
+/test/sha512t
+/test/*test
+/test/fips_aesavs
+/test/fips_desmovs
+/test/fips_dhvs
+/test/fips_drbgvs
+/test/fips_dssvs
+/test/fips_ecdhvs
+/test/fips_ecdsavs
+/test/fips_rngvs
+/test/fips_test_suite
+*.so*
+*.dylib*
+*.dll*
+*.exe
+# Exceptions
+!/test/bctest
+!/crypto/des/times/486-50.sol
+
+# Misc auto generated files
+/tools/c_rehash
+/test/evptests.txt
+lib
+Makefile.save
+*.bak
+tags
+TAGS
+
+# Windows
+/tmp32
+/tmp32.dbg
+/tmp32dll
+/tmp32dll.dbg
+/out32
+/out32.dbg
+/out32dll
+/out32dll.dbg
+/inc32
+/MINFO
+ms/bcb.mak
+ms/libeay32.def
+ms/nt.mak
+ms/ntdll.mak
+ms/ssleay32.def
+ms/version32.rc
diff --git a/Makefile b/Makefile
index 0b894ff..db4429d 100644
--- a/Makefile
+++ b/Makefile
@@ -11,11 +11,11 @@ SHLIB_VERSION_NUMBER=1.0.0
 SHLIB_VERSION_HISTORY=
 SHLIB_MAJOR=1
 SHLIB_MINOR=0.0
-SHLIB_EXT=
-PLATFORM=dist
-OPTIONS= no-ec_nistp_64_gcc_128 no-gmp no-jpake no-krb5 no-libunbound no-md2 no-rc5 no-rfc3779 no-sctp no-shared no-ssl-trace no-ssl2 no-store no-unit-test no-weak-ssl-ciphers no-zlib no-zlib-dynamic static-engine
-CONFIGURE_ARGS=dist
-SHLIB_TARGET=
+SHLIB_EXT=.so.$(SHLIB_MAJOR).$(SHLIB_MINOR)
+PLATFORM=linux-x86_64
+OPTIONS=-Wa,--noexecstack no-ec_nistp_64_gcc_128 no-gmp no-jpake no-krb5 no-libunbound no-md2 no-rc5 no-rfc3779 no-sctp no-shared no-ssl-trace no-ssl2 no-store no-unit-test no-weak-ssl-ciphers no-zlib no-zlib-dynamic static-engine
+CONFIGURE_ARGS=linux-x86_64 -Wa,--noexecstack
+SHLIB_TARGET=linux-shared
 
 # HERE indicates where this Makefile lives.  This can be used to indicate
 # where sub-Makefiles are expected to be.  Currently has very limited usage,
@@ -59,11 +59,11 @@ OPENSSLDIR=/usr/local/ssl
 # equal 4.
 # PKCS1_CHECK - pkcs1 tests.
 
-CC= cc
-CFLAG= -O
+CC= gcc
+CFLAG= -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -Wa,--noexecstack -m64 -DL_ENDIAN -O3 -Wall -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DRC4_ASM -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM -DECP_NISTZ256_ASM
 DEPFLAG= -DOPENSSL_NO_EC_NISTP_64_GCC_128 -DOPENSSL_NO_GMP -DOPENSSL_NO_JPAKE -DOPENSSL_NO_LIBUNBOUND -DOPENSSL_NO_MD2 -DOPENSSL_NO_RC5 -DOPENSSL_NO_RFC3779 -DOPENSSL_NO_SCTP -DOPENSSL_NO_SSL_TRACE -DOPENSSL_NO_SSL2 -DOPENSSL_NO_STORE -DOPENSSL_NO_UNIT_TEST -DOPENSSL_NO_WEAK_SSL_CIPHERS
 PEX_LIBS= 
-EX_LIBS= 
+EX_LIBS= -ldl
 EXE_EXT= 
 ARFLAGS= 
 AR= ar $(ARFLAGS) r
@@ -73,7 +73,7 @@ NM= nm
 PERL= /usr/bin/perl
 TAR= tar
 TARFLAGS= --no-recursion
-MAKEDEPPROG=makedepend
+MAKEDEPPROG= gcc
 LIBDIR=lib
 
 # We let the C compiler driver to take care of .s files. This is done in
@@ -89,23 +89,23 @@ ASFLAG=$(CFLAG)
 PROCESSOR= 
 
 # CPUID module collects small commonly used assembler snippets
-CPUID_OBJ= mem_clr.o
-BN_ASM= bn_asm.o
-EC_ASM= 
+CPUID_OBJ= x86_64cpuid.o
+BN_ASM= x86_64-gcc.o x86_64-mont.o x86_64-mont5.o x86_64-gf2m.o rsaz_exp.o rsaz-x86_64.o rsaz-avx2.o
+EC_ASM= ecp_nistz256.o ecp_nistz256-x86_64.o
 DES_ENC= des_enc.o fcrypt_b.o
-AES_ENC= aes_core.o aes_cbc.o
+AES_ENC= aes-x86_64.o vpaes-x86_64.o bsaes-x86_64.o aesni-x86_64.o aesni-sha1-x86_64.o aesni-sha256-x86_64.o aesni-mb-x86_64.o
 BF_ENC= bf_enc.o
 CAST_ENC= c_enc.o
-RC4_ENC= rc4_enc.o rc4_skey.o
+RC4_ENC= rc4-x86_64.o rc4-md5-x86_64.o
 RC5_ENC= rc5_enc.o
-MD5_ASM_OBJ= 
-SHA1_ASM_OBJ= 
+MD5_ASM_OBJ= md5-x86_64.o
+SHA1_ASM_OBJ= sha1-x86_64.o sha256-x86_64.o sha512-x86_64.o sha1-mb-x86_64.o sha256-mb-x86_64.o
 RMD160_ASM_OBJ= 
-WP_ASM_OBJ= wp_block.o
-CMLL_ENC= camellia.o cmll_misc.o cmll_cbc.o
-MODES_ASM_OBJ= 
+WP_ASM_OBJ= wp-x86_64.o
+CMLL_ENC= cmll-x86_64.o cmll_misc.o
+MODES_ASM_OBJ= ghash-x86_64.o aesni-gcm-x86_64.o
 ENGINES_ASM_OBJ= 
-PERLASM_SCHEME= 
+PERLASM_SCHEME= elf
 
 # KRB5 stuff
 KRB5_INCLUDES=
@@ -148,7 +148,7 @@ SDIRS=  \
 	objects \
 	md4 md5 sha mdc2 hmac ripemd whrlpool \
 	des aes rc2 rc4 idea bf cast camellia seed modes \
-	bn ec rsa dsa ecdsa dh ecdh dso engine \
+	bn ec rsa dsa ecdsa dh ecdh sidh dso engine \
 	buffer bio stack lhash rand err \
 	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
 	cms pqueue ts srp cmac
@@ -177,8 +177,8 @@ LIBS=   libcrypto.a libssl.a
 SHARED_CRYPTO=libcrypto$(SHLIB_EXT)
 SHARED_SSL=libssl$(SHLIB_EXT)
 SHARED_LIBS=
-SHARED_LIBS_LINK_EXTS=
-SHARED_LDFLAGS=
+SHARED_LIBS_LINK_EXTS=.so.$(SHLIB_MAJOR) .so
+SHARED_LDFLAGS=-m64
 
 GENERAL=        Makefile
 BASENAME=       openssl
diff --git a/Makefile.org b/Makefile.org
index 61a329b..71edfa2 100644
--- a/Makefile.org
+++ b/Makefile.org
@@ -146,7 +146,7 @@ SDIRS=  \
 	objects \
 	md2 md4 md5 sha mdc2 hmac ripemd whrlpool \
 	des aes rc2 rc4 rc5 idea bf cast camellia seed modes \
-	bn ec rsa dsa ecdsa dh ecdh dso engine \
+	bn ec rsa dsa ecdsa dh ecdh sidh dso engine \
 	buffer bio stack lhash rand err \
 	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
 	cms pqueue ts jpake srp store cmac
diff --git a/README.SIDH b/README.SIDH
new file mode 100644
index 0000000..4426342
--- /dev/null
+++ b/README.SIDH
@@ -0,0 +1,46 @@
+Supersingular Isogeny-based Diffie-Hellman (SIDH) key exchange
+--------------------------------------------------------------
+
+This version of OpenSSL has been modified to support the Supersingular Isogeny-based 
+Diffie-Hellman (SIDH) key exchange [1], using the implementation of Microsoft Research [2].
+This scheme provides approximately 128 bits of quantum security and 192 bits of classical 
+security.
+
+ABOUT THE INTEGRATION
+---------------------
+
+The library specifies four ciphersuites
+* SIDH-ECDSA-AES128-GCM-SHA256
+* SIDH-RSA-AES128-GCM-SHA256
+* SIDH-ECDHE-ECDSA-AES128-GCM-SHA256
+* SIDH-ECDHE-RSA-AES128-GCM-SHA256
+
+The first two consist of a SIDH key exchange, as described in [1], authentication based on 
+ECDSA or RSA digital signatures, authenticated encryption (with associated data) (AEAD) 
+based on AES-128 in GCM (Galois Counter Mode); and key derivation and hashing based on 
+SHA-256. The last two offer hybrid ciphersuites that are as above, except the key exchange 
+includes both SIDH and ECDH key exchange; the pre-master secret is the concatenation of the 
+ECDH shared secret and the SIDH shared secret. All these ciphersuites require TLSv1.2 because 
+of the use of AES-GCM.
+
+BUILDING THE LIBRARY
+--------------------
+
+The library is built normally, as explained in INSTALL. The SIDH code can be compiled out 
+using the OPENSSL_NO_SIDH flag.
+
+The SIDH code can make use of the assembly implementation, by declaring the SIDH_ASM flag:
+
+./config -DSIDH_ASM
+
+USING THE SIDH CIPHERSUITES
+---------------------------
+
+To use the SIDH ciphersuites, simply specify the suite identifier as you normally would.
+
+REFERENCES
+----------
+
+[1] Craig Costello, Patrick Longa, and Michael Naehrig (Microsoft Research). "Efficient algorithms for
+supersingular isogeny Diffe-Hellman." https://eprint.iacr.org/2016/413.pdf.
+[2] http://research.microsoft.com/en-us/projects/sidh/
diff --git a/apps/speed.c b/apps/speed.c
index 6cd1021..05d5a8c 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -79,6 +79,7 @@
 # define DSA_SECONDS     10
 # define ECDSA_SECONDS   10
 # define ECDH_SECONDS    10
+# define SIDH_SECONDS    10
 
 /* 11-Sep-92 Andrew Daviel   Support for Silicon Graphics IRIX added */
 /* 06-Apr-92 Luke Brennan    Support for VMS and add extra signal calls */
@@ -191,6 +192,9 @@
 # ifndef OPENSSL_NO_ECDH
 #  include <openssl/ecdh.h>
 # endif
+# ifndef OPENSSL_NO_SIDH
+#  include <openssl/sidh.h>
+# endif
 # include <openssl/modes.h>
 
 # ifdef OPENSSL_FIPS
@@ -249,6 +253,9 @@ static int do_multi(int multi);
 # define EC_NUM       16
 # define MAX_ECDH_SIZE 256
 
+# define SIDH_NUM     1
+# define MAX_SIDH_SIZE 256
+
 static const char *names[ALGOR_NUM] = {
     "md2", "mdc2", "md4", "md5", "hmac(md5)", "sha1", "rmd160", "rc4",
     "des cbc", "des ede3", "idea cbc", "seed cbc",
@@ -274,6 +281,9 @@ static double ecdsa_results[EC_NUM][2];
 # ifndef OPENSSL_NO_ECDH
 static double ecdh_results[EC_NUM][1];
 # endif
+# ifndef OPENSSL_NO_SIDH
+static double sidh_results[SIDH_NUM][3];
+# endif
 
 # if defined(OPENSSL_NO_DSA) && !(defined(OPENSSL_NO_ECDSA) && defined(OPENSSL_NO_ECDH))
 static const char rnd_seed[] =
@@ -349,7 +359,8 @@ static double Time_F(int s)
 }
 # endif
 
-# ifndef OPENSSL_NO_ECDH
+#if defined(OPENSSL_NO_ECDH) && defined(OPENSSL_NO_SIDH)
+#else
 static const int KDF1_SHA1_len = 20;
 static void *KDF1_SHA1(const void *in, size_t inlen, void *out,
                        size_t *outlen)
@@ -364,7 +375,7 @@ static void *KDF1_SHA1(const void *in, size_t inlen, void *out,
     return NULL;
 #  endif                        /* OPENSSL_NO_SHA */
 }
-# endif                         /* OPENSSL_NO_ECDH */
+# endif	/* defined(OPENSSL_NO_ECDH) || defined(OPENSSL_NO_SIDH) */
 
 static void multiblock_speed(const EVP_CIPHER *evp_cipher);
 
@@ -633,6 +644,16 @@ int MAIN(int argc, char **argv)
     long ecdh_c[EC_NUM][2];
 # endif
 
+# ifndef OPENSSL_NO_SIDH
+    int sidh_keysize = 4512;
+    SIDH_CTX *sidh_ctx;
+    SIDH_PAIR *sidh_server_pair[SIDH_NUM];
+    SIDH_PAIR *sidh_client_pair[SIDH_NUM];
+    unsigned char sidh_secret_a[MAX_SIDH_SIZE], sidh_secret_b[MAX_SIDH_SIZE];
+    int sidh_secret_size_a, sidh_secret_size_b;
+    long sidh_c[SIDH_NUM][3];
+# endif
+
     int rsa_doit[RSA_NUM];
     int dsa_doit[DSA_NUM];
 # ifndef OPENSSL_NO_ECDSA
@@ -641,6 +662,9 @@ int MAIN(int argc, char **argv)
 # ifndef OPENSSL_NO_ECDH
     int ecdh_doit[EC_NUM];
 # endif
+# ifndef OPENSSL_NO_SIDH
+    int sidh_doit[SIDH_NUM];
+# endif
     int doit[ALGOR_NUM];
     int pr_header = 0;
     const EVP_CIPHER *evp_cipher = NULL;
@@ -674,6 +698,13 @@ int MAIN(int argc, char **argv)
     for (i = 0; i < RSA_NUM; i++)
         rsa_key[i] = NULL;
 # endif
+# ifndef OPENSSL_NO_SIDH
+    for (i=0; i<SIDH_NUM; i++)
+      {
+	sidh_server_pair[i] = NULL;
+	sidh_client_pair[i] = NULL;
+      }
+# endif
 
     if (bio_err == NULL)
         if ((bio_err = BIO_new(BIO_s_file())) != NULL)
@@ -709,6 +740,10 @@ int MAIN(int argc, char **argv)
     for (i = 0; i < EC_NUM; i++)
         ecdh_doit[i] = 0;
 # endif
+# ifndef OPENSSL_NO_SIDH
+    for (i = 0; i < SIDH_NUM; i++)
+      sidh_doit[i] = 0;
+# endif
 
     j = 0;
     argc--;
@@ -1062,6 +1097,14 @@ int MAIN(int argc, char **argv)
                 ecdh_doit[i] = 1;
         } else
 # endif
+#ifndef OPENSSL_NO_SIDH
+	  if (strcmp(*argv,"sidh") == 0)
+	    {
+	      for (i=0; i < SIDH_NUM; i++)
+		sidh_doit[i]=1;
+	    }
+	  else
+#endif
         {
             BIO_printf(bio_err, "Error: bad option or value\n");
             BIO_printf(bio_err, "\n");
@@ -1164,6 +1207,9 @@ int MAIN(int argc, char **argv)
                        "ecdhb163  ecdhb233  ecdhb283  ecdhb409  ecdhb571\n");
             BIO_printf(bio_err, "ecdh\n");
 # endif
+#ifndef OPENSSL_NO_SIDH
+	    BIO_printf(bio_err,"sidh\n");
+#endif
 
 # ifndef OPENSSL_NO_IDEA
             BIO_printf(bio_err, "idea     ");
@@ -1247,6 +1293,10 @@ int MAIN(int argc, char **argv)
         for (i = 0; i < EC_NUM; i++)
             ecdh_doit[i] = 1;
 # endif
+#ifndef OPENSSL_NO_SIDH
+	for (i=0; i<SIDH_NUM; i++)
+	  sidh_doit[i]=1;
+#endif
     }
     for (i = 0; i < ALGOR_NUM; i++)
         if (doit[i])
@@ -1529,6 +1579,12 @@ int MAIN(int argc, char **argv)
         }
     }
 #   endif
+#ifndef OPENSSL_NO_SIDH
+    for (i=0; i<=SIDH_NUM; i++) {
+      sidh_c[i][0]=count/1000;
+      sidh_c[i][1]=count/1000;
+    }
+#endif
 
 #   define COND(d) (count < (d))
 #   define COUNT(d) (d)
@@ -2353,6 +2409,104 @@ int MAIN(int argc, char **argv)
     if (rnd_fake)
         RAND_cleanup();
 # endif
+
+#ifndef OPENSSL_NO_SIDH
+    if (RAND_status() != 1)
+      {
+	RAND_seed(rnd_seed, sizeof rnd_seed);
+	rnd_fake = 1;
+      }
+    sidh_ctx = SIDH_CTX_new();
+    if (sidh_ctx == NULL)
+      {
+	BIO_printf(bio_err,"SIDH failure.\n");
+	ERR_print_errors(bio_err);
+	rsa_count=1;
+      }
+    else
+      {
+	for (j=0; j<SIDH_NUM; j++)
+	  {
+	    if (!sidh_doit[j]) continue;
+	    sidh_server_pair[j] = SIDH_PAIR_new();
+	    sidh_client_pair[j] = SIDH_PAIR_new();
+	    if ((sidh_server_pair[j] == NULL) || (sidh_client_pair[j] == NULL))
+	      {
+		BIO_printf(bio_err,"SIDH failure.\n");
+		ERR_print_errors(bio_err);
+		rsa_count=1;
+	      }
+	    else
+	      {
+
+		/* Time SIDH key generation */
+		pkey_print_message("sidh","key generation", sidh_c[j][0], sidh_keysize, SIDH_SECONDS);
+		Time_F(START);
+		for (count=0,run=1; COND(sidh_c[j][0]); count++)
+		  {
+		      SIDH_PAIR_generate_key_server(sidh_server_pair[j], sidh_ctx);
+		  }
+		d=Time_F(STOP);
+		BIO_printf(bio_err, mr ? "+R9:%ld:%d:%.2f\n" :"%ld n=%d SIDH key generations in %.2fs\n",
+			   count, sidh_keysize, d);
+		sidh_results[j][0]=d/(double)count;
+		rsa_count=count;
+
+		sidh_secret_size_b = KDF1_SHA1_len;
+		sidh_secret_size_a = KDF1_SHA1_len;
+		/* generate two SIDH key pairs */
+		if (!SIDH_PAIR_generate_key_server(sidh_server_pair[j], sidh_ctx) ||
+		    !SIDH_PAIR_generate_key_client(sidh_client_pair[j], sidh_ctx))
+		  {
+		    BIO_printf(bio_err,"SIDH key generation failure.\n");
+		    ERR_print_errors(bio_err);
+		    rsa_count=1;		
+		  }
+		else
+		  {
+		    /* Time SIDH Client shared secret generation */
+		    pkey_print_message("sidh", "Client shared secret", sidh_c[j][1], sidh_keysize, SIDH_SECONDS);
+		    Time_F(START);
+		    for (count=0,run=1; COND(sidh_c[j][1]); count++)
+		      {
+			SIDH_compute_key_client(sidh_secret_b, sidh_secret_size_b, 
+						SIDH_PAIR_get_publickey(sidh_server_pair[j]), sidh_client_pair[j], KDF1_SHA1, sidh_ctx);
+		      }
+		    d=Time_F(STOP);
+		    BIO_printf(bio_err, mr ? "+R10:%ld:%d:%.2f\n" :"%ld n=%d SIDH Client shared secret in %.2fs\n",
+			       count, sidh_keysize, d);
+		    sidh_results[j][1]=d/(double)count;
+		    rsa_count=count;
+
+		    /* Time SIDH Server shared secret generation */
+		    pkey_print_message("sidh", "Server shared secret", sidh_c[j][2], sidh_keysize, SIDH_SECONDS);
+		    Time_F(START);
+		    for (count=0,run=1; COND(sidh_c[j][2]); count++)
+		      {
+			SIDH_compute_key_server(sidh_secret_a, sidh_secret_size_a, 
+						SIDH_PAIR_get_publickey(sidh_client_pair[j]), sidh_server_pair[j], KDF1_SHA1, sidh_ctx);
+		      }
+		    d=Time_F(STOP);
+		    BIO_printf(bio_err, mr ? "+R11:%ld:%d:%.2f\n" :"%ld n=%d SIDH Server shared secret in %.2fs\n",
+			       count, sidh_keysize, d);
+		    sidh_results[j][2]=d/(double)count;
+		    rsa_count=count;
+
+		  }
+	      }
+
+	    if (rsa_count <= 1)
+	      {
+		/* if longer than 10s, don't do any more */
+		for (j++; j<SIDH_NUM; j++)
+		  sidh_doit[j]=0;
+	      }
+	  }
+      }
+
+    if (rnd_fake) RAND_cleanup();
+#endif
+
 # ifndef NO_FORK
  show_res:
 # endif
@@ -2492,6 +2646,30 @@ int MAIN(int argc, char **argv)
     }
 # endif
 
+#ifndef OPENSSL_NO_SIDH
+    j=1;
+    for (k=0; k<SIDH_NUM; k++)
+      {
+	if (!sidh_doit[k]) continue;
+	if (j && !mr)
+	  {
+	    printf("%19skeygen   keygen/s   Client shared      Client/s   Server shared    Server/s\n"," ");
+	    j=0;
+	  }
+	if (mr)
+	  fprintf(stdout,"+F6:%u:%u:%f:%f:%f\n",
+		  k, sidh_keysize,
+		  sidh_results[k][0], sidh_results[k][1], sidh_results[k][2]);
+	
+	else
+	  fprintf(stdout,"sidh n=%4u     %8.4fs    %8.1f   %8.4fs   %8.1f      %8.4fs   %8.1f\n",
+		  sidh_keysize,
+		  sidh_results[k][0], 1.0/sidh_results[k][0],
+		  sidh_results[k][1], 1.0/sidh_results[k][1],
+		  sidh_results[k][2], 1.0/sidh_results[k][2]);
+      }
+#endif
+
     mret = 0;
 
  end:
@@ -2524,6 +2702,17 @@ int MAIN(int argc, char **argv)
             EC_KEY_free(ecdh_b[i]);
     }
 # endif
+#ifndef OPENSSL_NO_SIDH
+    for (i=0; i<SIDH_NUM; i++)
+      {
+	if (sidh_server_pair[i] != NULL)
+	  SIDH_PAIR_free(sidh_server_pair[i]);
+	if (sidh_client_pair[i] != NULL)
+	  SIDH_PAIR_free(sidh_client_pair[i]);
+      }
+    if (sidh_ctx != NULL)
+      SIDH_CTX_free(sidh_ctx);
+#endif
 
     release_engine(e);
     apps_shutdown();
@@ -2755,6 +2944,24 @@ static int do_multi(int multi)
             }
 #  endif
 
+#ifndef OPENSSL_NO_SIDH
+	    else if(!strncmp(buf,"+F6:",4))
+	      {
+		int k;
+		double d;
+		
+		p=buf+4;
+		k=atoi(sstrsep(&p,sep));
+		sstrsep(&p,sep);
+		
+		d=atof(sstrsep(&p,sep));
+		if(n)
+		  sidh_results[k][0]=1/(1/sidh_results[k][0]+1/d);
+		else
+		  sidh_results[k][0]=d;
+	      }
+#endif
+
             else if (!strncmp(buf, "+H:", 3)) {
             } else
                 fprintf(stderr, "Unknown type '%s' from child %d\n", buf, n);
diff --git a/crypto/err/err.h b/crypto/err/err.h
index 585aa8b..9ac4fb4 100644
--- a/crypto/err/err.h
+++ b/crypto/err/err.h
@@ -191,6 +191,7 @@ typedef struct err_state_st {
 # define ERR_LIB_COMP            41
 # define ERR_LIB_ECDSA           42
 # define ERR_LIB_ECDH            43
+# define ERR_LIB_SIDH            51
 # define ERR_LIB_STORE           44
 # define ERR_LIB_FIPS            45
 # define ERR_LIB_CMS             46
@@ -227,6 +228,7 @@ typedef struct err_state_st {
 # define COMPerr(f,r) ERR_PUT_error(ERR_LIB_COMP,(f),(r),__FILE__,__LINE__)
 # define ECDSAerr(f,r)  ERR_PUT_error(ERR_LIB_ECDSA,(f),(r),__FILE__,__LINE__)
 # define ECDHerr(f,r)  ERR_PUT_error(ERR_LIB_ECDH,(f),(r),__FILE__,__LINE__)
+# define SIDHerr(f,r)  ERR_PUT_error(ERR_LIB_SIDH,(f),(r),__FILE__,__LINE__)
 # define STOREerr(f,r) ERR_PUT_error(ERR_LIB_STORE,(f),(r),__FILE__,__LINE__)
 # define FIPSerr(f,r) ERR_PUT_error(ERR_LIB_FIPS,(f),(r),__FILE__,__LINE__)
 # define CMSerr(f,r) ERR_PUT_error(ERR_LIB_CMS,(f),(r),__FILE__,__LINE__)
@@ -289,6 +291,7 @@ typedef struct err_state_st {
 # define ERR_R_ECDH_LIB  ERR_LIB_ECDH/* 43 */
 # define ERR_R_STORE_LIB ERR_LIB_STORE/* 44 */
 # define ERR_R_TS_LIB    ERR_LIB_TS/* 45 */
+# define ERR_R_SIDH_LIB  ERR_LIB_SIDH/* 47 */
 
 # define ERR_R_NESTED_ASN1_ERROR                 58
 # define ERR_R_BAD_ASN1_OBJECT_HEADER            59
diff --git a/crypto/err/openssl.ec b/crypto/err/openssl.ec
index 04dc9ce..03a87ab 100644
--- a/crypto/err/openssl.ec
+++ b/crypto/err/openssl.ec
@@ -30,6 +30,7 @@ L UI		crypto/ui/ui.h			crypto/ui/ui_err.c
 L COMP		crypto/comp/comp.h		crypto/comp/comp_err.c
 L ECDSA		crypto/ecdsa/ecdsa.h		crypto/ecdsa/ecs_err.c
 L ECDH		crypto/ecdh/ecdh.h		crypto/ecdh/ech_err.c
+L SIDH		crypto/sidh/sidh.h		crypto/sidh/sidhkex_err.c
 L STORE		crypto/store/store.h		crypto/store/str_err.c
 L TS		crypto/ts/ts.h			crypto/ts/ts_err.c
 #L HMAC		crypto/hmac/hmac.h		crypto/hmac/hmac_err.c
diff --git a/crypto/opensslconf.h b/crypto/opensslconf.h
index f533508..ac0ad50 100644
--- a/crypto/opensslconf.h
+++ b/crypto/opensslconf.h
@@ -53,6 +53,9 @@ extern "C" {
 
 #endif /* OPENSSL_DOING_MAKEDEPEND */
 
+#ifndef OPENSSL_THREADS
+# define OPENSSL_THREADS
+#endif
 #ifndef OPENSSL_NO_DYNAMIC_ENGINE
 # define OPENSSL_NO_DYNAMIC_ENGINE
 #endif
@@ -106,6 +109,8 @@ extern "C" {
 # endif
 #endif
 
+#define OPENSSL_CPUID_OBJ
+
 /* crypto/opensslconf.h.in */
 
 /* Generate 80386 code? */
@@ -152,7 +157,7 @@ extern "C" {
  * This enables code handling data aligned at natural CPU word
  * boundary. See crypto/rc4/rc4_enc.c for further details.
  */
-#undef RC4_CHUNK
+#define RC4_CHUNK unsigned long
 #endif
 #endif
 
@@ -160,7 +165,7 @@ extern "C" {
 /* If this is set to 'unsigned int' on a DEC Alpha, this gives about a
  * %20 speed up (longs are 8 bytes, int's are 4). */
 #ifndef DES_LONG
-#define DES_LONG unsigned long
+#define DES_LONG unsigned int
 #endif
 #endif
 
@@ -171,9 +176,9 @@ extern "C" {
 /* Should we define BN_DIV2W here? */
 
 /* Only one for the following should be defined */
-#undef SIXTY_FOUR_BIT_LONG
+#define SIXTY_FOUR_BIT_LONG
 #undef SIXTY_FOUR_BIT
-#define THIRTY_TWO_BIT
+#undef THIRTY_TWO_BIT
 #endif
 
 #if defined(HEADER_RC4_LOCL_H) && !defined(CONFIG_HEADER_RC4_LOCL_H)
@@ -215,7 +220,7 @@ extern "C" {
 /* Unroll the inner loop, this sometimes helps, sometimes hinders.
  * Very mucy CPU dependant */
 #ifndef DES_UNROLL
-#undef DES_UNROLL
+#define DES_UNROLL
 #endif
 
 /* These default values were supplied by
diff --git a/crypto/sidh/Makefile b/crypto/sidh/Makefile
new file mode 100644
index 0000000..7afa6d9
--- /dev/null
+++ b/crypto/sidh/Makefile
@@ -0,0 +1,113 @@
+#
+# crypto/sidh/Makefile
+#
+
+DIR=	sidh
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g -Wall
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+ifneq (,$(findstring SIDH_ASM,$(CFLAGS)))
+DO_SIDH_ASM=TRUE
+endif
+
+GENERAL=Makefile
+TEST=sidhkextest.c
+APPS=
+
+ifdef DO_SIDH_ASM
+ASM_OBJECTS=fp_x64_asm.o
+endif
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	sidhkex_key.c sidhkex_err.c
+
+LIBOBJ=	sidhkex_key.o sidhkex_err.o $(ASM_OBJECTS)
+
+SRC= $(LIBSRC)
+
+EXHEADER= sidh.h
+HEADER=	sidhkex_locl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+
+ifdef DO_SIDH_ASM
+fp_x64_asm.o:	sidhlib/AMD64/fp_x64_asm.S
+	$(CC) $(CFLAGS) -c -o $@ sidhlib/AMD64/fp_x64_asm.S
+endif
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+sidhkex_err.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+sidhkex_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+sidhkex_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+sidhkex_err.o: ../../include/openssl/opensslconf.h
+sidhkex_err.o: ../../include/openssl/opensslv.h
+sidhkex_err.o: ../../include/openssl/ossl_typ.h
+sidhkex_err.o: ../../include/openssl/safestack.h ../../include/openssl/sidh.h
+sidhkex_err.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+sidhkex_err.o: sidhkex_err.c
+sidhkex_key.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+sidhkex_key.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+sidhkex_key.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+sidhkex_key.o: ../../include/openssl/opensslconf.h
+sidhkex_key.o: ../../include/openssl/opensslv.h
+sidhkex_key.o: ../../include/openssl/ossl_typ.h ../../include/openssl/rand.h
+sidhkex_key.o: ../../include/openssl/safestack.h ../../include/openssl/sidh.h
+sidhkex_key.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+sidhkex_key.o: sidhkex_key.c sidhkex_locl.h sidhlib/SIDH.c sidhlib/SIDH.h
+sidhkex_key.o: sidhlib/SIDH_internal.h sidhlib/SIDH_setup.c
+sidhkex_key.o: sidhlib/ec_isogeny.c sidhlib/fpx.c
+sidhkex_key.o: sidhlib/generic/../SIDH_internal.h sidhlib/generic/fp_generic.c
+sidhkex_key.o: sidhlib/kex.c sidhlib/validate.c
diff --git a/crypto/sidh/sidh.h b/crypto/sidh/sidh.h
new file mode 100644
index 0000000..420d463
--- /dev/null
+++ b/crypto/sidh/sidh.h
@@ -0,0 +1,103 @@
+/* crypto/sidh/sidh.h */
+#ifndef HEADER_SIDH_H
+#define HEADER_SIDH_H
+
+#include <openssl/opensslconf.h>
+
+#ifdef OPENSSL_NO_SIDH
+#error SIDH is disabled.
+#endif
+
+#include <openssl/ossl_typ.h>
+#include <openssl/bn.h>
+#include <openssl/err.h>
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Size of SIDH secret key = (CurveIsogeny_SIDHp751.owordbits + 7)/8
+ * Number of bytes in an element in [1, order]
+ */
+#define SIDH_SECRETKEY_LEN 48
+/*
+ * Number of bytes in a field element 
+ * PBYTES_SIDHp751 ((CurveIsogeny_SIDHp751.pwordbits + 7)/8)
+ * Size of SIDH public key = 3*2*PBYTES_SIDHp751
+ */
+#define SIDH_PUBKEY_LEN 576
+/* Size of SIDH shared key = 2*PBYTES_SIDHp751 */
+#define SIDH_SHAREDKEY_LEN 192
+
+typedef struct sidh_pub_st  SIDH_PUB;
+typedef struct sidh_pair_st SIDH_PAIR;
+typedef struct sidh_ctx_st  SIDH_CTX;
+
+/* Allocate and deallocate context, public keys, and key pairs structures */
+SIDH_CTX *SIDH_CTX_new(void);
+void SIDH_CTX_free(SIDH_CTX *ctx);
+
+SIDH_PUB *SIDH_PUB_new(void);
+SIDH_PUB *SIDH_PUB_copy(SIDH_PUB *dest, const SIDH_PUB *src);
+void SIDH_PUB_free(SIDH_PUB *pub);
+
+SIDH_PAIR *SIDH_PAIR_new(void);
+SIDH_PAIR *SIDH_PAIR_copy(SIDH_PAIR *dest, const SIDH_PAIR *src);
+SIDH_PAIR *SIDH_PAIR_dup(const SIDH_PAIR *pair);
+void SIDH_PAIR_free(SIDH_PAIR *pair);
+
+/* Generate key pair */
+int SIDH_PAIR_generate_key_server(SIDH_PAIR *key, SIDH_CTX *ctx);
+int SIDH_PAIR_generate_key_client(SIDH_PAIR *key, SIDH_CTX *ctx);
+
+/* Convert public keys and reconciliation data structures from/to binary */
+SIDH_PUB *o2i_SIDH_PUB(SIDH_PUB **pub, const unsigned char *in, long len);
+int i2o_SIDH_PUB(SIDH_PUB *pub, unsigned char **out);
+
+/* Get public key from a key pair */
+SIDH_PUB *SIDH_PAIR_get_publickey(SIDH_PAIR *pair);
+/* Does private key exist? */
+int SIDH_PAIR_has_privatekey(SIDH_PAIR *pair);
+
+/* Compute shared secret values */
+int SIDH_compute_key_server(void *out, size_t outlen, const SIDH_PUB *peer_pub_key, const SIDH_PAIR *priv_pub_key, 
+			    void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen), SIDH_CTX *ctx);
+int SIDH_compute_key_client(void *out, size_t outlen, const SIDH_PUB *peer_pub_key, const SIDH_PAIR *priv_pub_key, 
+			    void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen), SIDH_CTX *ctx);
+
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_SIDH_strings(void);
+
+/* Error codes for the SIDH functions. */
+
+/* Function codes. */
+#define SIDH_F_I2O_SIDH_PUB  			 100
+#define SIDH_F_O2I_SIDH_PUB  			 101
+#define SIDH_F_SIDH_COMPUTE_KEY_SERVER		 102
+#define SIDH_F_SIDH_COMPUTE_KEY_CLIENT		 103
+#define SIDH_F_SIDH_PAIR_COPY			 114
+#define SIDH_F_SIDH_PAIR_NEW			 105
+#define SIDH_F_SIDH_PUB_COPY			 106
+#define SIDH_F_SIDH_PUB_NEW			 107
+#define SIDH_F_SIDH_PAIR_GENERATE_KEY_SERVER     108
+#define SIDH_F_SIDH_PAIR_GENERATE_KEY_CLIENT     109
+#define SIDH_F_SIDH_CTX_NEW			 110
+
+/* Reason codes. */
+#define SIDH_R_INVALID_LENGTH			 100
+#define SIDH_R_KDF_FAILED			 101
+#define SIDH_R_RANDOM_FAILED			 102
+#define SIDH_R_KEX_FAILED			 103
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/crypto/sidh/sidhkex_err.c b/crypto/sidh/sidhkex_err.c
new file mode 100644
index 0000000..487e992
--- /dev/null
+++ b/crypto/sidh/sidhkex_err.c
@@ -0,0 +1,105 @@
+/* crypto/sidh/sidhkex_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/sidh.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+#define ERR_FUNC(func) ERR_PACK(ERR_LIB_SIDH,func,0)
+#define ERR_REASON(reason) ERR_PACK(ERR_LIB_SIDH,0,reason)
+
+static ERR_STRING_DATA SIDH_str_functs[]=
+  {
+{ERR_FUNC(SIDH_F_I2O_SIDH_PUB),	"i2o_SIDH_PUB"},
+{ERR_FUNC(SIDH_F_O2I_SIDH_PUB),	"o2i_SIDH_PUB"},
+{ERR_FUNC(SIDH_F_SIDH_COMPUTE_KEY_SERVER), "SIDH_compute_key_server"},
+{ERR_FUNC(SIDH_F_SIDH_COMPUTE_KEY_CLIENT), "SIDH_compute_key_client"},
+{ERR_FUNC(SIDH_F_SIDH_PAIR_COPY),	"SIDH_PAIR_copy"},
+{ERR_FUNC(SIDH_F_SIDH_PAIR_NEW),	"SIDH_PAIR_new"},
+{ERR_FUNC(SIDH_F_SIDH_PUB_COPY),	"SIDH_PUB_copy"},
+{ERR_FUNC(SIDH_F_SIDH_PUB_NEW),	"SIDH_PUB_new"},
+{ERR_FUNC(SIDH_F_SIDH_CTX_NEW),	"SIDH_CTX_new"},
+{0,NULL}
+};
+
+static ERR_STRING_DATA SIDH_str_reasons[]=
+	{
+{ERR_REASON(SIDH_R_INVALID_LENGTH)    ,"invalid length"},
+{ERR_REASON(SIDH_R_KDF_FAILED)        ,"kdf failed"},
+{ERR_REASON(SIDH_R_RANDOM_FAILED)     ,"random failed"},
+{0,NULL}
+	};
+
+#endif
+
+void ERR_load_SIDH_strings(void)
+	{
+#ifndef OPENSSL_NO_ERR
+
+	if (ERR_func_error_string(SIDH_str_functs[0].error) == NULL)
+		{
+		ERR_load_strings(0,SIDH_str_functs);
+		ERR_load_strings(0,SIDH_str_reasons);
+		}
+#endif
+	}
diff --git a/crypto/sidh/sidhkex_key.c b/crypto/sidh/sidhkex_key.c
new file mode 100644
index 0000000..407e62d
--- /dev/null
+++ b/crypto/sidh/sidhkex_key.c
@@ -0,0 +1,395 @@
+/* crypto/sidh/sidhkex_key.c */
+
+#include <string.h>
+#include "sidhkex_locl.h"
+#include "sidhlib/fpx.c"
+#include "sidhlib/kex.c"
+#include "sidhlib/ec_isogeny.c"
+#include "sidhlib/SIDH.c"
+#include "sidhlib/SIDH_setup.c"
+#include "sidhlib/validate.c"
+#ifdef SIDH_ASM
+#include "sidhlib/AMD64/fp_x64.c"
+#else
+#include "sidhlib/generic/fp_generic.c"
+#endif
+
+/* Allocate and deallocate context data structure */
+
+SIDH_CTX *SIDH_CTX_new(void) {
+	SIDH_CTX *ret;
+	ret = (SIDH_CTX *)OPENSSL_malloc(sizeof(SIDH_CTX));
+	if (ret == NULL) {
+	  SIDHerr(SIDH_F_SIDH_CTX_NEW, ERR_R_MALLOC_FAILURE);
+	  return (NULL);
+	}
+	ret->pCurveIsogeny = SIDH_curve_allocate(&CurveIsogeny_SIDHp751);
+	if (ret->pCurveIsogeny == NULL) {
+	  SIDHerr(SIDH_F_SIDH_CTX_NEW, ERR_R_MALLOC_FAILURE);
+	  goto err;
+	}
+	if (SIDH_curve_initialize(ret->pCurveIsogeny, &CurveIsogeny_SIDHp751) != CRYPTO_SUCCESS) {
+	  goto err;
+	}
+
+	return (ret);
+  err:
+	if (ret != NULL) {
+	  if (ret->pCurveIsogeny != NULL) {
+	    SIDH_curve_free(ret->pCurveIsogeny);
+	    ret->pCurveIsogeny = NULL;
+	  }
+	  OPENSSL_free(ret);
+	}
+  	return (NULL);
+}
+
+void SIDH_CTX_free(SIDH_CTX *ctx) {
+	if (ctx == NULL) return;
+	if (ctx != NULL) {
+	  if (ctx->pCurveIsogeny != NULL) {
+	    SIDH_curve_free(ctx->pCurveIsogeny);
+	    ctx->pCurveIsogeny = NULL;
+	  }
+	  OPENSSL_cleanse((void *)ctx, sizeof(SIDH_CTX));
+	  OPENSSL_free(ctx);
+	}
+}
+
+
+/* Allocate and deallocate public key data structure */
+SIDH_PUB *SIDH_PUB_new() {
+  SIDH_PUB *ret;
+  ret = (SIDH_PUB *)OPENSSL_malloc(sizeof(SIDH_PUB));
+  if (ret == NULL) {
+    SIDHerr(SIDH_F_SIDH_PUB_NEW, ERR_R_MALLOC_FAILURE);
+    return NULL;
+  }
+
+  ret->pubKey = (unsigned char*) OPENSSL_malloc(SIDH_PUBKEY_LEN);
+  if (ret->pubKey == NULL) {
+    SIDHerr(SIDH_F_SIDH_PUB_NEW, ERR_R_MALLOC_FAILURE);
+    SIDH_PUB_free(ret);
+    return NULL;
+  }
+  ret->version = 1;
+  ret->flags = 0;
+  ret->references = 1;
+
+  return ret;
+}
+
+SIDH_PUB *SIDH_PUB_copy(SIDH_PUB *dest, const SIDH_PUB *src) {
+  if (dest == NULL || src == NULL) {
+    SIDHerr(SIDH_F_SIDH_PUB_COPY, ERR_R_PASSED_NULL_PARAMETER);
+    return NULL;
+  }
+  /* copy the public key */
+  if (src->pubKey) {
+    int pubKeySize = SIDH_PUBKEY_LEN;
+    if (!dest->pubKey) {
+      dest->pubKey = (unsigned char*) OPENSSL_malloc(pubKeySize);
+    }
+    memcpy(dest->pubKey, src->pubKey, pubKeySize);
+  }
+
+  /* copy the rest */
+  dest->version = src->version;
+  dest->flags = src->flags;
+
+  return dest;
+}
+
+void SIDH_PUB_free(SIDH_PUB *r) {
+  int i;
+
+  if (r == NULL) return;
+
+  i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_EC);
+#ifdef REF_PRINT
+  REF_PRINT("SIDH_PUB", r);
+#endif
+  if (i > 0) return;
+#ifdef REF_CHECK
+  if (i < 0) {
+    fprintf(stderr, "SIDH_PUB_free, bad reference count\n");
+    abort();
+  }
+#endif
+  if (r->pubKey) {
+    int pubKeySize = SIDH_PUBKEY_LEN;
+    OPENSSL_cleanse(r->pubKey, pubKeySize);
+    OPENSSL_free(r->pubKey);
+  }
+  OPENSSL_cleanse((void *)r, sizeof(SIDH_PUB));
+  OPENSSL_free(r);
+}
+
+/* Allocate and deallocate public key / private key pair data structure */
+
+SIDH_PAIR *SIDH_PAIR_new(void) {
+  SIDH_PAIR *ret;
+
+  ret = (SIDH_PAIR *)OPENSSL_malloc(sizeof(SIDH_PAIR));
+  if (ret == NULL) {
+    SIDHerr(SIDH_F_SIDH_PAIR_NEW, ERR_R_MALLOC_FAILURE);
+    return (NULL);
+  }
+
+  ret->version = 1;
+  ret->flags = 0;
+  ret->references = 1;
+
+  /* init the public key */
+  ret->pub = NULL;
+  ret->pub = SIDH_PUB_new();
+  if (ret->pub == NULL) {
+    return NULL;
+  }
+  ret->secretKey = (unsigned char*) OPENSSL_malloc(SIDH_SECRETKEY_LEN);
+  return (ret);
+}
+
+SIDH_PAIR *SIDH_PAIR_copy(SIDH_PAIR *dest, const SIDH_PAIR *src) {
+  if (dest == NULL || src == NULL) {
+    SIDHerr(SIDH_F_SIDH_PAIR_COPY, ERR_R_PASSED_NULL_PARAMETER);
+    return NULL;
+  }
+
+  /* copy the public key */
+
+  if (src->pub) {
+    if (dest->pub){
+      SIDH_PUB_free(dest->pub);
+    }
+    dest->pub = SIDH_PUB_new();
+    if (dest->pub == NULL) {
+      return NULL;
+    }
+    if (!SIDH_PUB_copy(dest->pub, src->pub)) {
+      return NULL;
+    }
+  }
+
+  /* copy the private key */
+  if (src->secretKey) {
+    if (!dest->secretKey) {
+      dest->secretKey = (unsigned char*) OPENSSL_malloc(SIDH_SECRETKEY_LEN);
+      memcpy(dest->secretKey, src->secretKey, SIDH_SECRETKEY_LEN);
+    }
+  }
+
+  /* copy the rest */
+  dest->version   = src->version;
+  dest->flags = src->flags;
+
+  return dest;
+}
+
+SIDH_PAIR *SIDH_PAIR_dup(const SIDH_PAIR *pair) {
+  SIDH_PAIR *ret = SIDH_PAIR_new();
+  if (ret == NULL) {
+    return NULL;
+  }
+  if (SIDH_PAIR_copy(ret, pair) == NULL) {
+    SIDH_PAIR_free(ret);
+    return NULL;
+  }
+  return ret;
+}
+
+void SIDH_PAIR_free(SIDH_PAIR *r) {
+  int i;
+
+  if (r == NULL) return;
+
+  i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_EC);
+#ifdef REF_PRINT
+  REF_PRINT("SIDH_PAIR", r);
+#endif
+  if (i > 0) return;
+#ifdef REF_CHECK
+  if (i < 0) {
+    fprintf(stderr, "SIDH_PAIR_free, bad reference count\n");
+    abort();
+  }
+#endif
+
+  SIDH_PUB_free(r->pub);
+  OPENSSL_cleanse(r->secretKey, SIDH_SECRETKEY_LEN);
+  OPENSSL_free(r->secretKey);
+  OPENSSL_cleanse((void *)r, sizeof(SIDH_PAIR));
+  OPENSSL_free(r);
+}
+
+/* Generate key pair */
+
+int SIDH_PAIR_generate_key_server(SIDH_PAIR *key, SIDH_CTX *ctx) {
+  if (key == NULL || ctx == NULL) {
+    SIDHerr(SIDH_F_SIDH_PAIR_GENERATE_KEY_SERVER, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+  if (KeyGeneration_A(key->secretKey, key->pub->pubKey, ctx->pCurveIsogeny) != CRYPTO_SUCCESS) {
+    SIDHerr(SIDH_F_SIDH_PAIR_GENERATE_KEY_SERVER, SIDH_R_KEX_FAILED);
+    return 0;
+  }
+  return 1;
+}
+
+int SIDH_PAIR_generate_key_client(SIDH_PAIR *key, SIDH_CTX *ctx) {
+  if (key == NULL || ctx == NULL) {
+    SIDHerr(SIDH_F_SIDH_PAIR_GENERATE_KEY_CLIENT, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+
+  if (KeyGeneration_B(key->secretKey, key->pub->pubKey, ctx->pCurveIsogeny) != CRYPTO_SUCCESS) {
+    SIDHerr(SIDH_F_SIDH_PAIR_GENERATE_KEY_CLIENT, SIDH_R_KEX_FAILED);
+    return 0;
+  }
+  return 1;
+}
+
+/* Convert pubkey data structures from/to binary */
+SIDH_PUB *o2i_SIDH_PUB(SIDH_PUB **pub, const unsigned char *in, long len) {
+  if (pub == NULL) {
+    SIDHerr(SIDH_F_O2I_SIDH_PUB, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+  if (*pub == NULL && (*pub = SIDH_PUB_new()) == NULL) {
+    SIDHerr(SIDH_F_O2I_SIDH_PUB, ERR_R_MALLOC_FAILURE);
+    return 0;
+  }
+
+  int expected_len = SIDH_PUBKEY_LEN;
+  if (len != expected_len) {
+    SIDHerr(SIDH_F_O2I_SIDH_PUB, SIDH_R_INVALID_LENGTH);
+    return 0;
+  }
+  memcpy((*pub)->pubKey, in, len);
+  return *pub;
+}
+
+int i2o_SIDH_PUB(SIDH_PUB *pub, unsigned char **out) {
+  size_t buf_len = 0;
+  int new_buffer = 0;
+
+  if (pub == NULL) {
+    SIDHerr(SIDH_F_I2O_SIDH_PUB, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+  buf_len = SIDH_PUBKEY_LEN;
+
+  if (out == NULL )
+    return buf_len;
+
+  if (*out == NULL) {
+    if ((*out = OPENSSL_malloc(buf_len)) == NULL) {
+      SIDHerr(SIDH_F_I2O_SIDH_PUB, ERR_R_MALLOC_FAILURE);
+      return 0;
+    }
+    new_buffer = 1;
+  }
+  memcpy(*out, pub->pubKey, buf_len);
+  if (!new_buffer) {
+    *out += buf_len;
+  }
+  return buf_len;
+}
+
+/* Get public key from a key pair */
+SIDH_PUB *SIDH_PAIR_get_publickey(SIDH_PAIR *pair) {
+  if (pair == NULL) return NULL;
+  return pair->pub;
+}
+
+/* Does private key exist? */
+int SIDH_PAIR_has_privatekey(SIDH_PAIR *pair) {
+  return pair->secretKey != NULL;
+}
+
+/* Compute shared secret values */
+int SIDH_compute_key_server(void *out, size_t outlen, const SIDH_PUB *peer_pub_key, const SIDH_PAIR *priv_pub_key, 
+			       void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen), SIDH_CTX *ctx) {
+  int ret = -1;
+  if (peer_pub_key == NULL || priv_pub_key == NULL || ctx == NULL) {
+    SIDHerr(SIDH_F_SIDH_COMPUTE_KEY_SERVER, ERR_R_PASSED_NULL_PARAMETER);    
+    return ret;
+  }
+
+  unsigned int sharedSecretA_len = SIDH_SHAREDKEY_LEN;
+  unsigned char *sharedSecretA = NULL;
+
+  if (out != NULL) {
+    sharedSecretA = (unsigned char*)OPENSSL_malloc(sharedSecretA_len);
+    if (SecretAgreement_A(priv_pub_key->secretKey, peer_pub_key->pubKey, sharedSecretA, false, ctx->pCurveIsogeny) != CRYPTO_SUCCESS) {
+      goto err;
+    }
+    if (KDF != 0) {
+      if (KDF((unsigned char *) sharedSecretA, sharedSecretA_len, out, &outlen) == NULL) {
+	SIDHerr(SIDH_F_SIDH_COMPUTE_KEY_SERVER, SIDH_R_KDF_FAILED);
+	goto err;
+      }
+      ret = outlen;
+    } else {
+      /* no KDF, just copy as much as we can */
+      if (outlen > sharedSecretA_len) {
+	outlen = sharedSecretA_len;
+      }
+      memcpy(out, (unsigned char *) sharedSecretA, outlen);
+      ret = outlen;
+    }
+  }
+  else {
+    ret = sharedSecretA_len;    
+  }
+
+ err:
+  if (sharedSecretA) {
+    clear_words((void*)sharedSecretA, NBYTES_TO_NWORDS(sharedSecretA_len));
+    OPENSSL_free(sharedSecretA);
+  }
+  return (ret);
+}
+
+int SIDH_compute_key_client(void *out, size_t outlen, const SIDH_PUB *peer_pub_key, const SIDH_PAIR *priv_pub_key,
+			       void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen), SIDH_CTX *ctx) {
+  int ret = -1;
+  if (peer_pub_key == NULL || priv_pub_key == NULL || ctx == NULL) {
+    SIDHerr(SIDH_F_SIDH_COMPUTE_KEY_CLIENT, ERR_R_PASSED_NULL_PARAMETER);    
+    return ret;
+  }
+
+  unsigned int sharedSecretB_len = SIDH_SHAREDKEY_LEN;
+  unsigned char *sharedSecretB = NULL;
+
+  if (out != NULL) {
+    sharedSecretB = (unsigned char*)OPENSSL_malloc(sharedSecretB_len);
+    if (SecretAgreement_B(priv_pub_key->secretKey, peer_pub_key->pubKey, sharedSecretB, false, ctx->pCurveIsogeny) != CRYPTO_SUCCESS) {
+      goto err;
+    }
+    if (KDF != 0) {
+      if (KDF((unsigned char *) sharedSecretB, sharedSecretB_len, out, &outlen) == NULL) {
+        SIDHerr(SIDH_F_SIDH_COMPUTE_KEY_CLIENT, SIDH_R_KDF_FAILED);
+        goto err;
+      }
+      ret = outlen;
+    } else {
+    /* no KDF, just copy as much as we can */
+    if (outlen > sharedSecretB_len) {
+      outlen = sharedSecretB_len;
+    }
+    memcpy(out, (unsigned char *) sharedSecretB, outlen);
+    ret = outlen;
+    }
+  }
+  else {
+    ret = sharedSecretB_len;    
+  }
+
+ err:
+  if (sharedSecretB) {
+    clear_words((void*)sharedSecretB, NBYTES_TO_NWORDS(sharedSecretB_len));
+    OPENSSL_free(sharedSecretB);
+  }
+  return (ret);
+}
diff --git a/crypto/sidh/sidhkex_locl.h b/crypto/sidh/sidhkex_locl.h
new file mode 100644
index 0000000..c815522
--- /dev/null
+++ b/crypto/sidh/sidhkex_locl.h
@@ -0,0 +1,44 @@
+/* crypto/sidh/sidhkex_locl.h */
+
+#ifndef HEADER_SIDHKEX_LOCL_H
+#define HEADER_SIDHKEX_LOCL_H
+
+#include <openssl/sidh.h>
+#include "sidhlib/SIDH_internal.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+  /*
+   * FIXME: maybe this should have the actual values of pubKey, and not the encoding
+   *        this way the i2o_ and o2i_ functions would actually do something.
+   */
+
+  struct sidh_pub_st {
+    int version;
+    unsigned char* pubKey;
+    int references;
+    int	flags;
+  };
+
+  struct sidh_pair_st {
+    int version;
+    SIDH_PUB *pub;
+    unsigned char* secretKey;
+    int references;
+    int	flags;
+  };
+
+  struct sidh_ctx_st {
+    int version;
+    PCurveIsogenyStruct pCurveIsogeny;
+    int references;
+    int flags;
+  };
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /* HEADER_SIDHKEX_LOCL_H */
diff --git a/crypto/sidh/sidhkextest.c b/crypto/sidh/sidhkextest.c
new file mode 100644
index 0000000..cc7281a
--- /dev/null
+++ b/crypto/sidh/sidhkextest.c
@@ -0,0 +1,212 @@
+/* crypto/sidh/sidhkextest.c */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include "../e_os.h"
+
+#include <openssl/opensslconf.h>
+#include <openssl/crypto.h>
+#include <openssl/bio.h>
+#include <openssl/bn.h>
+#include <openssl/objects.h>
+#include <openssl/rand.h>
+#include <openssl/sha.h>
+#include <openssl/err.h>
+
+#ifdef OPENSSL_NO_SIDH
+int main(int argc, char *argv[]) {
+	printf("No SIDH support\n");
+	return (0);
+}
+#else
+#include <openssl/sidh.h>
+
+#ifdef OPENSSL_SYS_WIN16
+#define MS_CALLBACK	_far _loadds
+#else
+#define MS_CALLBACK
+#endif
+
+static const char rnd_seed[] = "string to make the random number generator think it has entropy";
+
+static const int KDF1_SHA1_len = 20;
+static void *KDF1_SHA1(const void *in, size_t inlen, void *out, size_t *outlen) {
+#ifndef OPENSSL_NO_SHA
+	if (*outlen < SHA_DIGEST_LENGTH)
+		return NULL;
+	else
+		*outlen = SHA_DIGEST_LENGTH;
+	return SHA1(in, inlen, out);
+#else
+	return NULL;
+#endif
+}
+
+static int test_sidhkex(BIO *out, int single) {
+
+	SIDH_PAIR *server = NULL;
+	SIDH_PAIR *client = NULL;
+	SIDH_PUB *server_reconstructed = NULL, *client_reconstructed = NULL;
+	SIDH_CTX *ctx = NULL;
+
+	unsigned char *server_pub_buffer = NULL, *client_pub_buffer = NULL;
+	size_t server_pub_len = 0, client_pub_len = 0;
+
+	unsigned char *server_sharedkey_buffer = NULL, *client_sharedkey_buffer = NULL;
+	size_t server_sharedkey_len = 0, client_sharedkey_len = 0;
+
+	int i, ret = 0;
+
+	ctx = SIDH_CTX_new();
+	server = SIDH_PAIR_new();
+	server_reconstructed = SIDH_PUB_new();
+	client = SIDH_PAIR_new();
+	client_reconstructed = SIDH_PUB_new();
+	if ((ctx == NULL) || (server == NULL) || (client == NULL) || (server_reconstructed == NULL) || (client_reconstructed == NULL) ) {
+	  goto err;
+	}
+
+	if (single) BIO_puts(out, "Testing key generation\n");
+
+	if (!SIDH_PAIR_generate_key_server(server, ctx)) goto err;
+	if (!SIDH_PAIR_generate_key_client(client, ctx)) goto err;
+	server_pub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(server), &server_pub_buffer);
+	if (single) BIO_printf(out, "  pub_A (%i bytes) = ", (int)server_pub_len);
+	if (server_pub_len <= 0) {
+		fprintf(stderr, "Error in SIDH routines\n");
+		ret = 0;
+		goto err;
+	}
+	if (single) {
+		for (i = 0; i < server_pub_len; i++) {
+			BIO_printf(out, "%02X", server_pub_buffer[i]);
+		}
+		BIO_puts(out, "\n");
+	}
+
+	if (single) BIO_puts(out, "Testing Client shared secret generation\n");
+
+	if (o2i_SIDH_PUB(&server_reconstructed, server_pub_buffer, server_pub_len) == NULL) {
+		fprintf(stderr, "Error in SIDH routines (Server public key reconstruction)\n");
+		ret = 0;
+		goto err;
+	}
+
+	client_sharedkey_len = KDF1_SHA1_len;
+	client_sharedkey_buffer = (unsigned char *)OPENSSL_malloc(client_sharedkey_len);
+	client_sharedkey_len = SIDH_compute_key_client(client_sharedkey_buffer, client_sharedkey_len, 
+							  server_reconstructed, client, KDF1_SHA1, ctx);
+	if (single) {
+		BIO_printf(out, "  key_B (%i bytes) = ", (int)client_sharedkey_len);
+		for (i = 0; i < client_sharedkey_len; i++) {
+			BIO_printf(out, "%02X", client_sharedkey_buffer[i]);
+		}
+		BIO_puts(out, "\n");
+	}
+
+	client_pub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(client), &client_pub_buffer);
+	if (single) {
+		BIO_printf(out, "\n  pub_B (%i bytes) = ", (int)client_pub_len);
+		for (i = 0; i < client_pub_len; i++) {
+			BIO_printf(out, "%02X", client_pub_buffer[i]);
+		}
+		BIO_puts(out, "\n");
+	}
+
+	if (single) BIO_puts(out, "Reconstructing Client's values\n");
+
+	if (o2i_SIDH_PUB(&client_reconstructed, client_pub_buffer, client_pub_len) == NULL) {
+		fprintf(stderr, "Error in SIDH routines (Client public key reconstruction)\n");
+		ret = 0;
+		goto err;
+	}
+
+	if (single) BIO_puts(out, "Testing Server shared secret generation\n");
+
+	server_sharedkey_len = KDF1_SHA1_len;
+	server_sharedkey_buffer = (unsigned char *)OPENSSL_malloc(server_sharedkey_len);
+	server_sharedkey_len = SIDH_compute_key_server(server_sharedkey_buffer, server_sharedkey_len, client_reconstructed, server, KDF1_SHA1, ctx);
+	if (single) {
+		BIO_printf(out, "  key_A (%i bytes) = ", (int)server_sharedkey_len);
+		for (i = 0; i < server_sharedkey_len; i++) {
+			BIO_printf(out, "%02X", server_sharedkey_buffer[i]);
+		}
+		BIO_puts(out, "\n");
+	}
+
+	if ((client_sharedkey_len != server_sharedkey_len) || (memcmp(server_sharedkey_buffer, client_sharedkey_buffer, server_sharedkey_len) != 0)) {
+		BIO_printf(out, " failed\n\n");
+		fprintf(stderr, "Error in SIDH routines (mismatched shared secrets)\n");
+		ret = 0;
+	}
+	else {
+		if (single) BIO_printf(out, "ok!\n");
+		ret = 1;
+	}
+err:
+	ERR_print_errors_fp(stderr);
+
+	OPENSSL_free(client_sharedkey_buffer);
+	OPENSSL_free(server_sharedkey_buffer);
+	OPENSSL_free(server_pub_buffer);
+	OPENSSL_free(client_pub_buffer);
+	SIDH_PUB_free(server_reconstructed);
+	SIDH_PUB_free(client_reconstructed);
+	SIDH_PAIR_free(client);
+	SIDH_PAIR_free(server);
+	SIDH_CTX_free(ctx);
+	return (ret);
+}
+
+int main(int argc, char *argv[]) {
+	int ret = 1;
+	BIO *out;
+
+	CRYPTO_malloc_debug_init();
+	CRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);
+	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+#ifdef OPENSSL_SYS_WIN32
+	CRYPTO_malloc_init();
+#endif
+
+	RAND_seed(rnd_seed, sizeof rnd_seed);
+
+	out = BIO_new(BIO_s_file());
+	if (out == NULL) EXIT(1);
+	BIO_set_fp(out, stdout, BIO_NOCLOSE);
+
+	if (argc == 1) {
+		if (!test_sidhkex(out, 1)) goto err;
+	} else {
+		int iterations = 0;
+		int failures = 0;
+		time_t starttime = time(NULL);
+		while (1) {
+			iterations++;
+			if (test_sidhkex(out, 0) == 1) {
+			} else {
+				failures++;
+			}
+			if ((iterations % 100) == 0) {
+				BIO_printf(out, "Iterations: %d, failures: %d, elapsed time: %ld\n", iterations, failures, time(NULL) - starttime);
+			}
+		}
+	}
+
+	ret = 0;
+
+err:
+	ERR_print_errors_fp(stderr);
+	BIO_free(out);
+	CRYPTO_cleanup_all_ex_data();
+	ERR_remove_thread_state(NULL);
+	CRYPTO_mem_leaks_fp(stderr);
+	EXIT(ret);
+	return (ret);
+}
+
+#endif
diff --git a/crypto/sidh/sidhlib/AMD64/fp_x64.c b/crypto/sidh/sidhlib/AMD64/fp_x64.c
new file mode 100644
index 0000000..2b89d77
--- /dev/null
+++ b/crypto/sidh/sidhlib/AMD64/fp_x64.c
@@ -0,0 +1,865 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: modular arithmetic optimized for x64 platforms
+*
+*********************************************************************************************/
+
+#include "../SIDH_internal.h"
+
+
+// Global constants
+extern const uint64_t p751[NWORDS_FIELD];
+extern const uint64_t p751p1[NWORDS_FIELD]; 
+extern const uint64_t p751x2[NWORDS_FIELD]; 
+
+
+__inline void fpadd751(digit_t* a, digit_t* b, digit_t* c)
+{ // Modular addition, c = a+b mod p751.
+  // Inputs: a, b in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    
+#if (OS_TARGET == OS_WIN)
+    unsigned int i, carry = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, a[i], b[i], carry, c[i]); 
+    }
+
+    carry = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(carry, c[i], ((digit_t*)p751x2)[i], carry, c[i]); 
+    }
+    mask = 0 - (digit_t)carry;
+
+    carry = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, c[i], ((digit_t*)p751x2)[i] & mask, carry, c[i]); 
+    } 
+    
+#elif (OS_TARGET == OS_LINUX)                 
+    
+    fpadd751_asm(a, b, c);    
+
+#endif
+} 
+
+
+__inline void fpsub751(digit_t* a, digit_t* b, digit_t* c)
+{ // Modular subtraction, c = a-b mod p751.
+  // Inputs: a, b in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    
+#if (OS_TARGET == OS_WIN)
+    unsigned int i, borrow = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, a[i], b[i], borrow, c[i]); 
+    }
+    mask = 0 - (digit_t)borrow;
+
+    borrow = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(borrow, c[i], ((digit_t*)p751x2)[i] & mask, borrow, c[i]); 
+    }
+    
+#elif (OS_TARGET == OS_LINUX)                 
+    
+    fpsub751_asm(a, b, c);    
+
+#endif
+}
+
+
+__inline void fpneg751(digit_t* a)
+{ // Modular negation, a = -a mod p751.
+  // Input/output: a in [0, 2*p751-1] 
+    unsigned int i, borrow = 0;
+    
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, ((digit_t*)p751x2)[i], a[i], borrow, a[i]); 
+    }
+}
+
+
+void fpdiv2_751(digit_t* a, digit_t* c)
+{ // Modular division by two, c = a/2 mod p751.
+  // Input : a in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    unsigned int i, carry = 0;
+    digit_t mask;
+        
+    mask = 0 - (digit_t)(a[0] & 1);    // If a is odd compute a+p521
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, a[i], ((digit_t*)p751)[i] & mask, carry, c[i]); 
+    }
+
+    mp_shiftr1(c, NWORDS_FIELD);
+}  
+
+
+void fpcorrection751(digit_t* a)
+{ // Modular correction to reduce field element a in [0, 2*p751-1] to [0, p751-1].
+    unsigned int i, borrow = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, a[i], ((digit_t*)p751)[i], borrow, a[i]); 
+    }
+    mask = 0 - (digit_t)borrow;
+
+    borrow = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(borrow, a[i], ((digit_t*)p751)[i] & mask, borrow, a[i]); 
+    }
+}
+
+
+void mp_mul(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)
+{ // Multiprecision multiply, c = a*b, where lng(a) = lng(b) = nwords.
+        
+    UNREFERENCED_PARAMETER(nwords);
+
+#if (OS_TARGET == OS_WIN)
+    digit_t t = 0;
+    uint128_t uv = {0};
+    unsigned int carry = 0;
+        
+    MULADD128(a[0], b[0], uv, carry, uv);
+    t += carry;
+    c[0] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[0], uv, carry, uv);
+    t += carry;
+    c[1] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[0], uv, carry, uv);
+    t += carry;
+    c[2] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[0], uv, carry, uv);
+    t += carry;
+    c[3] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[0], uv, carry, uv);
+    t += carry;
+    c[4] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[0], uv, carry, uv);
+    t += carry;
+    c[5] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[0], uv, carry, uv);
+    t += carry;
+    c[6] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[0], uv, carry, uv);
+    t += carry;
+    c[7] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[0], uv, carry, uv);
+    t += carry;
+    c[8] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[0], uv, carry, uv);
+    t += carry;
+    c[9] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[0], uv, carry, uv);
+    t += carry;
+    c[10] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[11], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[11], b[0], uv, carry, uv);
+    t += carry;
+    c[11] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;    
+    
+    MULADD128(a[1], b[11], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[11], b[1], uv, carry, uv);
+    t += carry;
+    c[12] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[11], uv, carry, uv);
+    t += carry;
+    c[13] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[11], uv, carry, uv);
+    t += carry;
+    c[14] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[11], uv, carry, uv);
+    t += carry;
+    c[15] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[11], uv, carry, uv);
+    t += carry;
+    c[16] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[11], uv, carry, uv);
+    t += carry;
+    c[17] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[11], uv, carry, uv);
+    t += carry;
+    c[18] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[11], uv, carry, uv);
+    t += carry;
+    c[19] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[11], uv, carry, uv);
+    t += carry;
+    c[20] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[11], uv, carry, uv);
+    t += carry;
+    c[21] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    
+    MULADD128(a[11], b[11], uv, carry, uv);
+    c[22] = uv[0];
+    c[23] = uv[1];
+
+#elif (OS_TARGET == OS_LINUX)
+    
+    mul751_asm(a, b, c);
+
+#endif
+}
+
+
+void rdc_mont(dfelm_t ma, felm_t mc)
+{ // Optimized Montgomery reduction using comba and exploiting the special form of the prime p751.
+  // mc = ma*mb*R^-1 mod p751, where ma,mb,mc in [0, 2*p751-1] and R = 2^768.
+  // ma and mb are assumed to be in Montgomery representation.
+        
+#if (OS_TARGET == OS_WIN)
+    unsigned int carry;
+    digit_t t = 0;
+    uint128_t uv = {0};
+    
+    mc[0] = ma[0];
+    mc[1] = ma[1];
+    mc[2] = ma[2];
+    mc[3] = ma[3];
+    mc[4] = ma[4];
+    MUL128(mc[0], ((digit_t*)p751p1)[5], uv);
+    ADDC(0, uv[0], ma[5], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    mc[5] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[6], uv, carry, uv);
+    MULADD128(mc[1], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[6], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[6] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[1], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[7], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[7] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[1], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[8], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[8] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[1], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[9], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[9] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[1], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[10], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[10] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[1], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[11], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[11] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[1], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[12], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[0] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[2], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[13], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[1] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[3], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[14], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[2] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[4], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[15], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[3] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[5], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[16], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[4] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[6], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[17], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[5] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[7], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[18], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[6] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[8], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[19], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[7] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[9], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[20], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[8] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[10], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[21], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[9] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[11], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[22], carry, mc[10]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    ADDC(0, uv[1], ma[23], carry, mc[11]); 
+    
+#elif (OS_TARGET == OS_LINUX)                 
+    
+    rdc751_asm(ma, mc);    
+
+#endif
+}
\ No newline at end of file
diff --git a/crypto/sidh/sidhlib/AMD64/fp_x64_asm.S b/crypto/sidh/sidhlib/AMD64/fp_x64_asm.S
new file mode 100644
index 0000000..056fada
--- /dev/null
+++ b/crypto/sidh/sidhlib/AMD64/fp_x64_asm.S
@@ -0,0 +1,1864 @@
+//*******************************************************************************************
+// SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+//       exchange providing 128 bits of quantum security and 192 bits of classical security.
+//
+//    Copyright (c) Microsoft Corporation. All rights reserved.
+//
+//
+// Abstract: field arithmetic in x64 assembly for Linux 
+//
+//*******************************************************************************************  
+
+.intel_syntax noprefix 
+
+// Registers that are used for parameter passing:
+#define reg_p1  rdi
+#define reg_p2  rsi
+#define reg_p3  rdx
+
+// p751 + 1
+#define p751p1_5   0xEEB0000000000000
+#define p751p1_6   0xE3EC968549F878A8
+#define p751p1_7   0xDA959B1A13F7CC76
+#define p751p1_8   0x084E9867D6EBE876
+#define p751p1_9   0x8562B5045CB25748
+#define p751p1_10  0x0E12909F97BADC66
+#define p751p1_11  0x00006FE5D541F71C
+
+#define p751_0     0xFFFFFFFFFFFFFFFF
+#define p751_5     0xEEAFFFFFFFFFFFFF
+#define p751_6     0xE3EC968549F878A8
+#define p751_7     0xDA959B1A13F7CC76
+#define p751_8     0x084E9867D6EBE876
+#define p751_9     0x8562B5045CB25748
+#define p751_10    0x0E12909F97BADC66
+#define p751_11    0x00006FE5D541F71C
+
+#define p751x2_0   0xFFFFFFFFFFFFFFFE
+#define p751x2_1   0xFFFFFFFFFFFFFFFF
+#define p751x2_5   0xDD5FFFFFFFFFFFFF
+#define p751x2_6   0xC7D92D0A93F0F151
+#define p751x2_7   0xB52B363427EF98ED
+#define p751x2_8   0x109D30CFADD7D0ED
+#define p751x2_9   0x0AC56A08B964AE90
+#define p751x2_10  0x1C25213F2F75B8CD
+#define p751x2_11  0x0000DFCBAA83EE38
+
+
+.text
+//***********************************************************************
+//  Field addition
+//  Operation: c [reg_p3] = a [reg_p1] + b [reg_p2]
+//*********************************************************************** 
+.global fpadd751_asm
+fpadd751_asm:
+  push   r12
+  push   r13
+  push   r14
+  push   r15
+  
+  mov    r8, [reg_p1]
+  mov    r9, [reg_p1+8]
+  mov    r10, [reg_p1+16]
+  mov    r11, [reg_p1+24]
+  mov    r12, [reg_p1+32]
+  mov    r13, [reg_p1+40]
+  mov    r14, [reg_p1+48]
+  mov    r15, [reg_p1+56] 
+  mov    rcx, [reg_p1+64]
+  add    r8, [reg_p2] 
+  adc    r9, [reg_p2+8] 
+  adc    r10, [reg_p2+16] 
+  adc    r11, [reg_p2+24] 
+  adc    r12, [reg_p2+32] 
+  adc    r13, [reg_p2+40] 
+  adc    r14, [reg_p2+48] 
+  adc    r15, [reg_p2+56]
+  adc    rcx, [reg_p2+64] 
+  mov    rax, [reg_p1+72]
+  adc    rax, [reg_p2+72] 
+  mov    [reg_p3+72], rax
+  mov    rax, [reg_p1+80]
+  adc    rax, [reg_p2+80] 
+  mov    [reg_p3+80], rax
+  mov    rax, [reg_p1+88]
+  adc    rax, [reg_p2+88] 
+  mov    [reg_p3+88], rax
+
+  movq   rax, p751x2_0
+  sub    r8, rax
+  movq   rax, p751x2_1
+  sbb    r9, rax
+  sbb    r10, rax
+  sbb    r11, rax
+  sbb    r12, rax
+  movq   rax, p751x2_5
+  sbb    r13, rax
+  movq   rax, p751x2_6
+  sbb    r14, rax
+  movq   rax, p751x2_7
+  sbb    r15, rax
+  movq   rax, p751x2_8
+  sbb    rcx, rax
+  mov    [reg_p3], r8
+  mov    [reg_p3+8], r9
+  mov    [reg_p3+16], r10
+  mov    [reg_p3+24], r11
+  mov    [reg_p3+32], r12
+  mov    [reg_p3+40], r13
+  mov    [reg_p3+48], r14
+  mov    [reg_p3+56], r15
+  mov    [reg_p3+64], rcx
+  mov    r8, [reg_p3+72]
+  mov    r9, [reg_p3+80]
+  mov    r10, [reg_p3+88]
+  movq   rax, p751x2_9
+  sbb    r8, rax
+  movq   rax, p751x2_10
+  sbb    r9, rax
+  movq   rax, p751x2_11
+  sbb    r10, rax
+  mov    [reg_p3+72], r8
+  mov    [reg_p3+80], r9
+  mov    [reg_p3+88], r10
+  movq   rax, 0
+  sbb    rax, 0
+  
+  mov    rsi, p751x2_0
+  and    rsi, rax
+  mov    r8, p751x2_1
+  and    r8, rax
+  movq   r9, p751x2_5
+  and    r9, rax
+  movq   r10, p751x2_6
+  and    r10, rax
+  movq   r11, p751x2_7
+  and    r11, rax
+  movq   r12, p751x2_8
+  and    r12, rax
+  movq   r13, p751x2_9
+  and    r13, rax
+  movq   r14, p751x2_10
+  and    r14, rax
+  movq   r15, p751x2_11
+  and    r15, rax
+  
+  mov    rax, [reg_p3]
+  add    rax, rsi  
+  mov    [reg_p3], rax
+  mov    rax, [reg_p3+8]
+  adc    rax, r8 
+  mov    [reg_p3+8], rax  
+  mov    rax, [reg_p3+16]
+  adc    rax, r8 
+  mov    [reg_p3+16], rax  
+  mov    rax, [reg_p3+24]  
+  adc    rax, r8 
+  mov    [reg_p3+24], rax 
+  mov    rax, [reg_p3+32]  
+  adc    rax, r8 
+  mov    [reg_p3+32], rax 
+  mov    rax, [reg_p3+40]    
+  adc    rax, r9 
+  mov    [reg_p3+40], rax 
+  mov    rax, [reg_p3+48]   
+  adc    rax, r10 
+  mov    [reg_p3+48], rax 
+  mov    rax, [reg_p3+56]   
+  adc    rax, r11  
+  mov    [reg_p3+56], rax 
+  mov    rax, [reg_p3+64]  
+  adc    rax, r12 
+  mov    [reg_p3+64], rax 
+  mov    rax, [reg_p3+72]   
+  adc    rax, r13 
+  mov    [reg_p3+72], rax 
+  mov    rax, [reg_p3+80]   
+  adc    rax, r14 
+  mov    [reg_p3+80], rax 
+  mov    rax, [reg_p3+88]   
+  adc    rax, r15
+  mov    [reg_p3+88], rax 
+  
+  pop    r15
+  pop    r14
+  pop    r13
+  pop    r12
+  ret
+
+
+//***********************************************************************
+//  Field subtraction
+//  Operation: c [reg_p3] = a [reg_p1] - b [reg_p2]
+//*********************************************************************** 
+.global fpsub751_asm
+fpsub751_asm:
+  push   r12
+  push   r13
+  push   r14
+  push   r15
+  
+  mov    r8, [reg_p1]
+  mov    r9, [reg_p1+8]
+  mov    r10, [reg_p1+16]
+  mov    r11, [reg_p1+24]
+  mov    r12, [reg_p1+32]
+  mov    r13, [reg_p1+40]
+  mov    r14, [reg_p1+48]
+  mov    r15, [reg_p1+56] 
+  mov    rcx, [reg_p1+64]
+  sub    r8, [reg_p2] 
+  sbb    r9, [reg_p2+8] 
+  sbb    r10, [reg_p2+16] 
+  sbb    r11, [reg_p2+24] 
+  sbb    r12, [reg_p2+32] 
+  sbb    r13, [reg_p2+40] 
+  sbb    r14, [reg_p2+48] 
+  sbb    r15, [reg_p2+56]
+  sbb    rcx, [reg_p2+64] 
+  mov    [reg_p3], r8
+  mov    [reg_p3+8], r9
+  mov    [reg_p3+16], r10
+  mov    [reg_p3+24], r11
+  mov    [reg_p3+32], r12
+  mov    [reg_p3+40], r13
+  mov    [reg_p3+48], r14
+  mov    [reg_p3+56], r15
+  mov    [reg_p3+64], rcx
+  mov    rax, [reg_p1+72]
+  sbb    rax, [reg_p2+72] 
+  mov    [reg_p3+72], rax
+  mov    rax, [reg_p1+80]
+  sbb    rax, [reg_p2+80] 
+  mov    [reg_p3+80], rax
+  mov    rax, [reg_p1+88]
+  sbb    rax, [reg_p2+88] 
+  mov    [reg_p3+88], rax
+  movq   rax, 0
+  sbb    rax, 0
+  
+  mov    rsi, p751x2_0
+  and    rsi, rax
+  mov    r8, p751x2_1
+  and    r8, rax
+  movq   r9, p751x2_5
+  and    r9, rax
+  movq   r10, p751x2_6
+  and    r10, rax
+  movq   r11, p751x2_7
+  and    r11, rax
+  movq   r12, p751x2_8
+  and    r12, rax
+  movq   r13, p751x2_9
+  and    r13, rax
+  movq   r14, p751x2_10
+  and    r14, rax
+  movq   r15, p751x2_11
+  and    r15, rax
+  
+  mov    rax, [reg_p3]
+  add    rax, rsi  
+  mov    [reg_p3], rax
+  mov    rax, [reg_p3+8]
+  adc    rax, r8 
+  mov    [reg_p3+8], rax  
+  mov    rax, [reg_p3+16]
+  adc    rax, r8 
+  mov    [reg_p3+16], rax  
+  mov    rax, [reg_p3+24]  
+  adc    rax, r8 
+  mov    [reg_p3+24], rax 
+  mov    rax, [reg_p3+32]  
+  adc    rax, r8 
+  mov    [reg_p3+32], rax 
+  mov    rax, [reg_p3+40]    
+  adc    rax, r9 
+  mov    [reg_p3+40], rax 
+  mov    rax, [reg_p3+48]   
+  adc    rax, r10 
+  mov    [reg_p3+48], rax 
+  mov    rax, [reg_p3+56]   
+  adc    rax, r11  
+  mov    [reg_p3+56], rax 
+  mov    rax, [reg_p3+64]  
+  adc    rax, r12 
+  mov    [reg_p3+64], rax 
+  mov    rax, [reg_p3+72]   
+  adc    rax, r13 
+  mov    [reg_p3+72], rax 
+  mov    rax, [reg_p3+80]   
+  adc    rax, r14 
+  mov    [reg_p3+80], rax 
+  mov    rax, [reg_p3+88]   
+  adc    rax, r15
+  mov    [reg_p3+88], rax 
+  
+  pop    r15
+  pop    r14
+  pop    r13
+  pop    r12
+  ret
+
+
+//***********************************************************************
+//  Integer multiplication
+//  Based on Karatsuba method
+//  Operation: c [reg_p3] = a [reg_p1] * b [reg_p2]
+//  NOTE: a=c or b=c are not allowed
+//***********************************************************************
+.global mul751_asm
+mul751_asm:
+  push   r12
+  push   r13
+  push   r14
+  mov    rcx, reg_p3
+  
+  // rcx[0-5] <- AH+AL
+  xor    rax, rax
+  mov    r8, [reg_p1+48]
+  mov    r9, [reg_p1+56]
+  mov    r10, [reg_p1+64]
+  mov    r11, [reg_p1+72]
+  mov    r12, [reg_p1+80]
+  mov    r13, [reg_p1+88]
+  add    r8, [reg_p1] 
+  adc    r9, [reg_p1+8] 
+  adc    r10, [reg_p1+16] 
+  adc    r11, [reg_p1+24] 
+  adc    r12, [reg_p1+32] 
+  adc    r13, [reg_p1+40] 
+  push   r15  
+  mov    [rcx], r8
+  mov    [rcx+8], r9
+  mov    [rcx+16], r10
+  mov    [rcx+24], r11
+  mov    [rcx+32], r12
+  mov    [rcx+40], r13
+  sbb    rax, 0 
+  sub    rsp, 96           // Allocating space in stack
+       
+  // rcx[6-11] <- BH+BL
+  xor    rdx, rdx
+  mov    r8, [reg_p2+48]
+  mov    r9, [reg_p2+56]
+  mov    r10, [reg_p2+64]
+  mov    r11, [reg_p2+72]
+  mov    r12, [reg_p2+80]
+  mov    r13, [reg_p2+88]
+  add    r8, [reg_p2] 
+  adc    r9, [reg_p2+8] 
+  adc    r10, [reg_p2+16] 
+  adc    r11, [reg_p2+24] 
+  adc    r12, [reg_p2+32] 
+  adc    r13, [reg_p2+40] 
+  mov    [rcx+48], r8
+  mov    [rcx+56], r9
+  mov    [rcx+64], r10
+  mov    [rcx+72], r11
+  mov    [rcx+80], r12
+  mov    [rcx+88], r13
+  sbb    rdx, 0 
+  mov    [rsp+80], rax
+  mov    [rsp+88], rdx
+  
+  // (rsp[0-8],r10,r8,r9) <- (AH+AL)*(BH+BL)
+  mov    r11, [rcx]
+  mov    rax, r8 
+  mul    r11
+  mov    [rsp], rax        // c0
+  mov    r14, rdx
+  
+  xor    r15, r15
+  mov    rax, r9
+  mul    r11
+  xor    r9, r9
+  add    r14, rax
+  adc    r9, rdx
+  
+  mov    r12, [rcx+8] 
+  mov    rax, r8 
+  mul    r12
+  add    r14, rax
+  mov    [rsp+8], r14      // c1 
+  adc    r9, rdx
+  adc    r15, 0
+  
+  xor    r8, r8
+  mov    rax, r10 
+  mul    r11
+  add    r9, rax
+  mov    r13, [rcx+48] 
+  adc    r15, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+16] 
+  mul    r13
+  add    r9, rax
+  adc    r15, rdx 
+  mov    rax, [rcx+56] 
+  adc    r8, 0
+  
+  mul    r12
+  add    r9, rax
+  mov    [rsp+16], r9      // c2 
+  adc    r15, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [rcx+72] 
+  mul    r11
+  add    r15, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [rcx+24] 
+  mul    r13
+  add    r15, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, r10 
+  mul    r12
+  add    r15, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    r14, [rcx+16] 
+  mov    rax, [rcx+56] 
+  mul    r14
+  add    r15, rax
+  mov    [rsp+24], r15     // c3 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [rcx+80] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [rcx+64] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    r15, [rcx+48] 
+  mov    rax, [rcx+32] 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [rcx+72] 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    r13, [rcx+24] 
+  mov    rax, [rcx+56] 
+  mul    r13
+  add    r8, rax
+  mov    [rsp+32], r8      // c4 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [rcx+88] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+64] 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+72] 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+40] 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+80] 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r15, [rcx+32] 
+  mov    rax, [rcx+56] 
+  mul    r15
+  add    r9, rax
+  mov    [rsp+40], r9      // c5 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [rcx+64] 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [rcx+88] 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [rcx+80] 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    r11, [rcx+40] 
+  mov    rax, [rcx+56] 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [rcx+72] 
+  mul    r13
+  add    r10, rax
+  mov    [rsp+48], r10     // c6 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [rcx+88] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [rcx+64] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [rcx+80]
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [rcx+72] 
+  mul    r15
+  add    r8, rax
+  mov    [rsp+56], r8      // c7 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [rcx+72] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+80] 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+88] 
+  mul    r13
+  add    r9, rax
+  mov    [rsp+64], r9      // c8 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [rcx+88]
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+
+  mov    rax, [rcx+80] 
+  mul    r11
+  add    r10, rax          // c9 
+  adc    r8, rdx
+  adc    r9, 0
+
+  mov    rax, [rcx+88] 
+  mul    r11
+  add    r8, rax           // c10 
+  adc    r9, rdx           // c11 
+  
+  mov    rax, [rsp+88]
+  mov    rdx, [rcx]
+  and    r12, rax
+  and    r14, rax
+  and    rdx, rax
+  and    r13, rax
+  and    r15, rax
+  and    r11, rax
+  mov    rax, [rsp+48]
+  add    rdx, rax
+  mov    rax, [rsp+56]
+  adc    r12, rax
+  mov    rax, [rsp+64]
+  adc    r14, rax
+  adc    r13, r10
+  adc    r15, r8
+  adc    r11, r9
+  mov    rax, [rsp+80]
+  mov    [rsp+48], rdx
+  mov    [rsp+56], r12
+  mov    [rsp+64], r14
+  mov    [rsp+72], r13
+  mov    [rsp+80], r15
+  mov    [rsp+88], r11
+  
+  mov    r8, [rcx+48]
+  mov    r9, [rcx+56]
+  mov    r10, [rcx+64]
+  mov    r11, [rcx+72]
+  mov    r12, [rcx+80]
+  mov    r13, [rcx+88]
+  and    r8, rax
+  and    r9, rax
+  and    r10, rax
+  and    r11, rax
+  and    r12, rax
+  and    r13, rax
+  mov    rax, [rsp+48]
+  add    r8, rax
+  mov    rax, [rsp+56]
+  adc    r9, rax
+  mov    rax, [rsp+64]
+  adc    r10, rax
+  mov    rax, [rsp+72]
+  adc    r11, rax
+  mov    rax, [rsp+80]
+  adc    r12, rax
+  mov    rax, [rsp+88]
+  adc    r13, rax
+  mov    [rsp+48], r8
+  mov    [rsp+56], r9
+  mov    [rsp+72], r11
+  
+  // rcx[0-11] <- AL*BL
+  mov    r11, [reg_p1]
+  mov    rax, [reg_p2] 
+  mul    r11
+  xor    r9, r9
+  mov    [rcx], rax        // c0
+  mov    [rsp+64], r10
+  mov    r8, rdx
+
+  mov    rax, [reg_p2+8]
+  mul    r11
+  xor    r10, r10
+  add    r8, rax
+  mov    [rsp+80], r12
+  adc    r9, rdx
+
+  mov    r12, [reg_p1+8] 
+  mov    rax, [reg_p2] 
+  mul    r12
+  add    r8, rax
+  mov    [rcx+8], r8       // c1 
+  adc    r9, rdx
+  mov    [rsp+88], r13
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+16] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r13, [reg_p2] 
+  mov    rax, [reg_p1+16] 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+8] 
+  mul    r12
+  add    r9, rax
+  mov    [rcx+16], r9      // c2 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [reg_p2+24] 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p1+24] 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+16] 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    r14, [reg_p1+16] 
+  mov    rax, [reg_p2+8] 
+  mul    r14
+  add    r10, rax
+  mov    [rcx+24], r10     // c3 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [reg_p2+32] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+16] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p1+32] 
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+24] 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    r13, [reg_p1+24] 
+  mov    rax, [reg_p2+8] 
+  mul    r13
+  add    r8, rax
+  mov    [rcx+32], r8      // c4 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+40] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+16] 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+24] 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r11, [reg_p1+40] 
+  mov    rax, [reg_p2] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+32] 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r15, [reg_p1+32] 
+  mov    rax, [reg_p2+8] 
+  mul    r15
+  add    r9, rax
+  mov    [rcx+40], r9      // c5 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [reg_p2+16] 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+40] 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+32] 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+8] 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+24] 
+  mul    r13
+  add    r10, rax
+  mov    [rcx+48], r10     // c6 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [reg_p2+40] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+16] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+32]
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+24] 
+  mul    r15
+  add    r8, rax
+  mov    [rcx+56], r8      // c7 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+24] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+32] 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+40] 
+  mul    r13
+  add    r9, rax
+  mov    [rcx+64], r9     // c8 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [reg_p2+40]
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+
+  mov    rax, [reg_p2+32] 
+  mul    r11
+  add    r10, rax
+  mov    [rcx+72], r10     // c9 
+  adc    r8, rdx
+  adc    r9, 0
+
+  mov    rax, [reg_p2+40] 
+  mul    r11
+  add    r8, rax
+  mov    [rcx+80], r8      // c10 
+  adc    r9, rdx   
+  mov    [rcx+88], r9      // c11 
+
+  // rcx[12-23] <- AH*BH
+  mov    r11, [reg_p1+48]
+  mov    rax, [reg_p2+48] 
+  mul    r11
+  xor    r9, r9
+  mov    [rcx+96], rax       // c0
+  mov    r8, rdx
+
+  mov    rax, [reg_p2+56]
+  mul    r11
+  xor    r10, r10
+  add    r8, rax
+  adc    r9, rdx
+
+  mov    r12, [reg_p1+56] 
+  mov    rax, [reg_p2+48] 
+  mul    r12
+  add    r8, rax
+  mov    [rcx+104], r8      // c1 
+  adc    r9, rdx
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+64] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r13, [reg_p2+48] 
+  mov    rax, [reg_p1+64] 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+56] 
+  mul    r12
+  add    r9, rax
+  mov    [rcx+112], r9     // c2 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [reg_p2+72] 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p1+72] 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+64] 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    r14, [reg_p1+64] 
+  mov    rax, [reg_p2+56] 
+  mul    r14
+  add    r10, rax
+  mov    [rcx+120], r10    // c3 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [reg_p2+80] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+64] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    r15, [reg_p1+80] 
+  mov    rax, r13 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+72] 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    r13, [reg_p1+72] 
+  mov    rax, [reg_p2+56] 
+  mul    r13
+  add    r8, rax
+  mov    [rcx+128], r8     // c4 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+88] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+64] 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+72] 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r11, [reg_p1+88] 
+  mov    rax, [reg_p2+48] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+80] 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+56] 
+  mul    r15
+  add    r9, rax
+  mov    [rcx+136], r9     // c5 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [reg_p2+64] 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+88] 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+80] 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+56] 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+72] 
+  mul    r13
+  add    r10, rax
+  mov    [rcx+144], r10    // c6 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [reg_p2+88] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+64] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+80]
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+72] 
+  mul    r15
+  add    r8, rax
+  mov    [rcx+152], r8     // c7 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+72] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+80] 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+88] 
+  mul    r13
+  add    r9, rax
+  mov    [rcx+160], r9     // c8 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+88]
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+
+  mov    rax, [reg_p2+80] 
+  mul    r11
+  add    r10, rax
+  mov    [rcx+168], r10     // c9 
+  adc    r8, rdx
+
+  mov    rax, [reg_p2+88] 
+  mul    r11
+  add    r8, rax
+  mov    [rcx+176], r8      // c10 
+  adc    rdx, 0   
+  mov    [rcx+184], rdx     // c11  
+      
+  // [r8-r15,rax,rdx,rdi,[rsp]] <- (AH+AL)*(BH+BL) - AL*BL 
+  mov    r8,  [rsp]
+  sub    r8,  [rcx] 
+  mov    r9,  [rsp+8]
+  sbb    r9,  [rcx+8]
+  mov    r10, [rsp+16]
+  sbb    r10, [rcx+16]
+  mov    r11, [rsp+24]
+  sbb    r11, [rcx+24] 
+  mov    r12, [rsp+32]
+  sbb    r12, [rcx+32]
+  mov    r13, [rsp+40]
+  sbb    r13, [rcx+40] 
+  mov    r14, [rsp+48]
+  sbb    r14, [rcx+48] 
+  mov    r15, [rsp+56]
+  sbb    r15, [rcx+56] 
+  mov    rax, [rsp+64]
+  sbb    rax, [rcx+64]
+  mov    rdx, [rsp+72]
+  sbb    rdx, [rcx+72] 
+  mov    rdi, [rsp+80]
+  sbb    rdi, [rcx+80] 
+  mov    rsi, [rsp+88]
+  sbb    rsi, [rcx+88] 
+  mov    [rsp], rsi
+      
+  // [r8-r15,rax,rdx,rdi,[rsp]] <- (AH+AL)*(BH+BL) - AL*BL - AH*BH
+  mov    rsi, [rcx+96]
+  sub    r8,  rsi 
+  mov    rsi, [rcx+104]
+  sbb    r9,  rsi
+  mov    rsi, [rcx+112]
+  sbb    r10, rsi
+  mov    rsi, [rcx+120]
+  sbb    r11, rsi 
+  mov    rsi, [rcx+128]
+  sbb    r12, rsi
+  mov    rsi, [rcx+136]
+  sbb    r13, rsi
+  mov    rsi, [rcx+144]
+  sbb    r14, rsi 
+  mov    rsi, [rcx+152]
+  sbb    r15, rsi 
+  mov    rsi, [rcx+160]
+  sbb    rax, rsi
+  mov    rsi, [rcx+168]
+  sbb    rdx, rsi
+  mov    rsi, [rcx+176] 
+  sbb    rdi, rsi
+  mov    rsi, [rsp] 
+  sbb    rsi, [rcx+184]
+      
+  // Final result
+  add    r8,  [rcx+48] 
+  mov    [rcx+48], r8
+  adc    r9,  [rcx+56]
+  mov    [rcx+56], r9
+  adc    r10, [rcx+64]
+  mov    [rcx+64], r10
+  adc    r11, [rcx+72]
+  mov    [rcx+72], r11
+  adc    r12, [rcx+80]
+  mov    [rcx+80], r12
+  adc    r13, [rcx+88]
+  mov    [rcx+88], r13
+  adc    r14, [rcx+96] 
+  mov    [rcx+96], r14
+  adc    r15, [rcx+104] 
+  mov    [rcx+104], r15
+  adc    rax, [rcx+112]
+  mov    [rcx+112], rax
+  adc    rdx, [rcx+120]
+  mov    [rcx+120], rdx
+  adc    rdi, [rcx+128]
+  mov    [rcx+128], rdi
+  adc    rsi, [rcx+136]
+  mov    [rcx+136], rsi  
+  mov    rax, [rcx+144]
+  adc    rax, 0
+  mov    [rcx+144], rax
+  mov    rax, [rcx+152]
+  adc    rax, 0
+  mov    [rcx+152], rax
+  mov    rax, [rcx+160]
+  adc    rax, 0
+  mov    [rcx+160], rax
+  mov    rax, [rcx+168]
+  adc    rax, 0
+  mov    [rcx+168], rax
+  mov    rax, [rcx+176]
+  adc    rax, 0
+  mov    [rcx+176], rax
+  mov    rax, [rcx+184]
+  adc    rax, 0
+  mov    [rcx+184], rax
+    
+  add    rsp, 96           // Restoring space in stack
+  pop    r15
+  pop    r14
+  pop    r13
+  pop    r12
+  ret
+
+  
+//***********************************************************************
+//  Montgomery reduction
+//  Based on comba method
+//  Operation: c [reg_p2] = a [reg_p1]
+//  NOTE: a=c is not allowed
+//*********************************************************************** 
+.global rdc751_asm
+rdc751_asm:
+  push   r12
+  push   r13 
+  push   r14 
+  push   r15 
+
+  mov    r11, [reg_p1]
+  movq   rax, p751p1_5 
+  mul    r11
+  xor    r8, r8
+  add    rax, [reg_p1+40]
+  mov    [reg_p2+40], rax    // z5
+  adc    r8, rdx
+  
+  xor    r9, r9
+  movq   rax, p751p1_6 
+  mul    r11
+  xor    r10, r10
+  add    r8, rax
+  adc    r9, rdx
+
+  mov    r12, [reg_p1+8]
+  movq   rax, p751p1_5 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+48]
+  mov    [reg_p2+48], r8    // z6
+  adc    r9, 0
+  adc    r10, 0
+  
+  xor    r8, r8
+  movq   rax, p751p1_7 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_6 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  mov    r13, [reg_p1+16]
+  movq   rax, p751p1_5 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  add    r9, [reg_p1+56]
+  mov    [reg_p2+56], r9    // z7
+  adc    r10, 0
+  adc    r8, 0
+  
+  xor    r9, r9
+  movq   rax, p751p1_8 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_7 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_6 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  mov    r14, [reg_p1+24]
+  movq   rax, p751p1_5 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  add    r10, [reg_p1+64]
+  mov    [reg_p2+64], r10   // z8
+  adc    r8, 0
+  adc    r9, 0
+  
+  xor    r10, r10
+  movq   rax, p751p1_9 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_8 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_7 
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_6 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  mov    r15, [reg_p1+32]
+  movq   rax, p751p1_5 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+72]
+  mov    [reg_p2+72], r8    // z9
+  adc    r9, 0
+  adc    r10, 0
+  
+  xor    r8, r8
+  movq   rax, p751p1_10 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_9 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_8 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_7 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_6 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  mov    rcx, [reg_p2+40]
+  movq   rax, p751p1_5 
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  add    r9, [reg_p1+80]
+  mov    [reg_p2+80], r9    // z10
+  adc    r10, 0
+  adc    r8, 0
+  
+  xor    r9, r9
+  movq   rax, p751p1_11 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_10 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_9 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_8 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_7 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_6 
+  mul    rcx
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  mov    r11, [reg_p2+48]
+  movq   rax, p751p1_5 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  add    r10, [reg_p1+88]
+  mov    [reg_p2+88], r10    // z11
+  adc    r8, 0
+  adc    r9, 0
+  
+  xor    r10, r10
+  movq   rax, p751p1_11 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_10 
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_9 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_8 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_7 
+  mul    rcx
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_6 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  mov    r12, [reg_p2+56]
+  movq   rax, p751p1_5 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+96]
+  mov    [reg_p2], r8        // z0
+  adc    r9, 0
+  adc    r10, 0
+  
+  xor    r8, r8
+  movq   rax, p751p1_11 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+
+  movq   rax, p751p1_10 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+
+  movq   rax, p751p1_9
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+
+  movq   rax, p751p1_8
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+
+  movq   rax, p751p1_7
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+
+  movq   rax, p751p1_6
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  mov    r13, [reg_p2+64]
+  movq   rax, p751p1_5
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  add    r9, [reg_p1+104]
+  mov    [reg_p2+8], r9      // z1
+  adc    r10, 0
+  adc    r8, 0
+  
+  xor    r9, r9
+  movq   rax, p751p1_11 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_10 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_9 
+  mul    rcx
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_8 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_7 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_6 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  mov    r14, [reg_p2+72]
+  movq   rax, p751p1_5 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  add    r10, [reg_p1+112]
+  mov    [reg_p2+16], r10    // z2
+  adc    r8, 0
+  adc    r9, 0
+  
+  xor    r10, r10
+  movq   rax, p751p1_11 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_10 
+  mul    rcx
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_9 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_8 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_7 
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_6 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  mov    r15, [reg_p2+80]
+  movq   rax, p751p1_5 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+120]
+  mov    [reg_p2+24], r8     // z3
+  adc    r9, 0
+  adc    r10, 0
+  
+  xor    r8, r8
+  movq   rax, p751p1_11 
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_10 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_9 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_8 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_7 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_6 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  mov    rcx, [reg_p2+88]
+  movq   rax, p751p1_5 
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  add    r9, [reg_p1+128]
+  mov    [reg_p2+32], r9     // z4
+  adc    r10, 0
+  adc    r8, 0
+  
+  xor    r9, r9
+  movq   rax, p751p1_11 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_10 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_9 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_8 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_7 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_6 
+  mul    rcx
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  add    r10, [reg_p1+136]
+  mov    [reg_p2+40], r10    // z5
+  adc    r8, 0
+  adc    r9, 0
+  
+  xor    r10, r10
+  movq   rax, p751p1_11 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_10 
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_9 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_8 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_7 
+  mul    rcx
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+144]
+  mov    [reg_p2+48], r8     // z6
+  adc    r9, 0
+  adc    r10, 0
+  
+  xor    r8, r8
+  movq   rax, p751p1_11 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_10 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_9 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_8 
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  add    r9, [reg_p1+152]
+  mov    [reg_p2+56], r9     // z7
+  adc    r10, 0
+  adc    r8, 0
+  
+  xor    r9, r9
+  movq   rax, p751p1_11 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_10 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_9 
+  mul    rcx
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  add    r10, [reg_p1+160]
+  mov    [reg_p2+64], r10    // z8
+  adc    r8, 0
+  adc    r9, 0
+  
+  xor    r10, r10
+  movq   rax, p751p1_11 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+
+  movq   rax, p751p1_10 
+  mul    rcx
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+168]    // z9
+  mov    [reg_p2+72], r8     // z9
+  adc    r9, 0
+  adc    r10, 0
+  
+  movq   rax, p751p1_11 
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  add    r9, [reg_p1+176]    // z10
+  mov    [reg_p2+80], r9     // z10
+  adc    r10, 0  
+  add    r10, [reg_p1+184]   // z11
+  mov    [reg_p2+88], r10    // z11
+
+  pop    r15
+  pop    r14
+  pop    r13
+  pop    r12
+  ret
diff --git a/crypto/sidh/sidhlib/License.txt b/crypto/sidh/sidhlib/License.txt
new file mode 100644
index 0000000..3b4ffcc
--- /dev/null
+++ b/crypto/sidh/sidhlib/License.txt
@@ -0,0 +1,21 @@
+SIDH Library
+
+Copyright (c) Microsoft Corporation
+All rights reserved. 
+
+MIT License
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
+associated documentation files (the ""Software""), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial 
+portions of the Software.
+
+THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
+LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/crypto/sidh/sidhlib/README.txt b/crypto/sidh/sidhlib/README.txt
new file mode 100644
index 0000000..88a628d
--- /dev/null
+++ b/crypto/sidh/sidhlib/README.txt
@@ -0,0 +1,46 @@
+                                        SIDH v1.1 (C Edition)
+                                       =======================
+
+The SIDH v1.1 library (C Edition) is a supersingular isogeny-based cryptography library that implements a
+new suite of algorithms for a post-quantum resistant Diffie-Hellman key exchange scheme [2]. This scheme 
+provides approximately 128 bits of quantum security and 192 bits of classical security. 
+
+The library was developed by Microsoft Research for experimentation purposes. 
+
+*** THE ORIGINAL README HAS BEEN TRIMMED LEAVING ONLY THE INFO RELEVANT FOR THE OPENSSL INTEGRATION ***
+
+1. CONTENTS:
+   --------
+
+/                              - Library C and header files                                     
+AMD64/                         - Optimized implementation of the field arithmetic for x64 platforms
+generic/                       - Implementation of the field arithmetic in portable C
+README.txt                     - This readme file
+
+
+2. MAIN FEATURES:
+   -------------
+   
+- Support key exchange providing 128 bits of quantum security and 192 bits of classical security.
+- Support a peace-of-mind hybrid key exchange mode that adds a classical elliptic curve Diffie-Hellman 
+  key exchange on a high-security Montgomery curve providing 384 bits of classical ECDH security.
+- Protected against timing and cache-timing attacks through regular, constant-time implementation of 
+  all operations on secret key material.
+- Support for public key validation in static key exchange when private keys are used more than once.
+- Basic implementation of the underlying arithmetic functions using portable C to enable support on
+  a wide range of platforms including x64, x86 and ARM. 
+- Optimized implementation of the underlying arithmetic functions for x64 platforms with optional, 
+  high-performance x64 assembly for Linux.
+
+
+REFERENCES:
+----------
+
+[1]   Craig Costello, Patrick Longa, and Michael Naehrig.
+      Efficient algorithms for supersingular isogeny Diffie-Hellman.      
+      Advances in Cryptology - CRYPTO 2016 (to appear), 2016. 
+      Extended version available at: http://eprint.iacr.org/2016/413. 
+
+[2]   David Jao and Luca DeFeo. 
+      Towards quantum-resistant cryptosystems from supersingular elliptic curve isogenies.
+      PQCrypto 2011, LNCS 7071, pp. 19-34, 2011. 
\ No newline at end of file
diff --git a/crypto/sidh/sidhlib/SIDH.c b/crypto/sidh/sidhlib/SIDH.c
new file mode 100644
index 0000000..99935f5
--- /dev/null
+++ b/crypto/sidh/sidhlib/SIDH.c
@@ -0,0 +1,102 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: supersingular elliptic curve isogeny parameters
+*
+*********************************************************************************************/  
+
+#include "SIDH_internal.h"
+
+
+// Encoding of field elements, elements over Z_order, elements over GF(p^2) and elliptic curve points:
+// --------------------------------------------------------------------------------------------------
+// Elements over GF(p) and Z_order are encoded with the least significant octet (and digit) located
+// at the leftmost position (i.e., little endian format). 
+// Elements (a+b*i) over GF(p^2), where a and b are defined over GF(p), are encoded as {b, a}, with b 
+// in the least significant position.
+// Elliptic curve points P = (x,y) are encoded as {x, y}, with x in the least significant position. 
+
+//
+// Curve isogeny system "SIDHp751". Base curve: Montgomery curve By^2 = Cx^3 + Ax^2 + Cx defined over GF(p751^2), where A=0, B=1 and C=1
+//
+
+CurveIsogenyStaticData CurveIsogeny_SIDHp751 = {
+    "SIDHp751", 768, 384,         // Curve isogeny system ID, smallest multiple of 32 larger than the prime bitlength and smallest multiple of 32 larger than the order bitlength
+    751,                          // Bitlength of the prime 
+    // Prime p751 = 2^372*3^239-1
+    { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xEEAFFFFFFFFFFFFF, 
+      0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x00006FE5D541F71C },                                                
+    // Base curve parameter "A"
+    { 0 },
+    // Base curve parameter "C"
+    { 1 },
+    // Order bitlength for Alice
+    372,
+    // Order of Alice's subgroup
+    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0010000000000000 }, 
+    // Order bitlength for Bob
+    379,
+    // Power of Bob's subgroup order
+    239,
+    // Order of Bob's subgroup
+    { 0xC968549F878A8EEB, 0x59B1A13F7CC76E3E, 0xE9867D6EBE876DA9, 0x2B5045CB25748084, 0x2909F97BADC66856, 0x06FE5D541F71C0E1 },    
+    // Alice's generator PA = (XPA,YPA), where XPA and YPA are defined over GF(p751)
+    { 0x4B0346F5CCE233E9, 0x632646086CE3ACD5, 0x5661D14AB7347693, 0xA58A20449AF1F133, 0xB9AC2F40C56D6FA4, 0x8E561E008FA0E3F3, 
+      0x6CAE096D5DB822C9, 0x83FDB7A4AD3E83E8, 0xB1317AD904386217, 0x3FA23F89F6BE06D2, 0x429C8D36FF46BCC9, 0x00003E82027A38E9,
+      0x12E0D620BFB341D5, 0x0F8EEA7370893430, 0x5A99EBEC3B5B8B00, 0x236C7FAC9E69F7FD, 0x0F147EF3BD0CFEC5, 0x8ED5950D80325A8D, 
+      0x1E911F50BF3F721A, 0x163A7421DFA8378D, 0xC331B043DA010E6A, 0x5E15915A755883B7, 0xB6236F5F598D56EB, 0x00003BBF8DCD4E7E },
+    // Bob's generator PB = (XPB,YPB), where XPB and YPB are defined over GF(p751)
+    { 0x76ED2325DCC93103, 0xD9E1DF566C1D26D3, 0x76AECB94B919AEED, 0xD3785AAAA4D646C5, 0xCB610E30288A7770, 0x9BD3778659023B9E, 
+      0xD5E69CF26DF23742, 0xA3AD8E17B9F9238C, 0xE145FE2D525160E0, 0xF8D5BCE859ED725D, 0x960A01AB8FF409A2, 0x00002F1D80EF06EF,
+      0x91479226A0687894, 0xBBC6BAF5F6BA40BB, 0x15B529122CFE3CA6, 0x7D12754F00E898A3, 0x76EBA0C8419745E9, 0x0A94F06CDFB3EADE,
+      0x399A6EDB2EEB2F9B, 0xE302C5129C049EEB, 0xC35892123951D4B6, 0x15445287ED1CC55D, 0x1ACAF351F09AB55A, 0x00000127A46D082A },
+    // BigMont's curve parameter A24 = (A+2)/4
+    156113,
+    // BigMont's order, where BigMont is defined by y^2=x^3+A*x^2+x
+    { 0xA59B73D250E58055, 0xCB063593D0BE10E1, 0xF6515CCB5D076CBB, 0x66880747EDDF5E20, 0xBA515248A6BFD4AB, 0x3B8EF00DDDDC789D,
+      0xB8FB25A1527E1E2A, 0xB6A566C684FDF31D, 0x0213A619F5BAFA1D, 0xA158AD41172C95D2, 0x0384A427E5EEB719, 0x00001BF975507DC7 },
+    // Montgomery constant Montgomery_R2 = (2^768)^2 mod p751
+    { 0x233046449DAD4058, 0xDB010161A696452A, 0x5E36941472E3FD8E, 0xF40BFE2082A2E706, 0x4932CCA8904F8751 ,0x1F735F1F1EE7FC81, 
+      0xA24F4D80C1048E18, 0xB56C383CCDB607C5, 0x441DD47B735F9C90, 0x5673ED2C6A6AC82A, 0x06C905261132294B, 0x000041AD830F1F35 },
+    // Montgomery constant -p751^-1 mod 2^768
+    { 0x0000000000000001, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0xEEB0000000000000, 
+      0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x258C28E5D541F71C },
+    // Value one in Montgomery representation
+    { 0x00000000000249ad, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x8310000000000000,
+      0x5527b1e4375c6c66, 0x697797bf3f4f24d0, 0xc89db7b2ac5c4e2e, 0x4ca4b439d2076956, 0x10f7926c7512c7e9, 0x00002d5b24bce5e2 }
+};
+
+
+// Fixed parameters for isogeny tree computation
+
+const unsigned int splits_Alice[MAX_Alice] = {
+ 0, 1, 1, 2, 2, 2, 3, 4, 4, 4, 4, 5, 5, 6, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 12, 
+ 11, 12, 12, 13, 14, 15, 16, 16, 16, 16, 16, 16, 17, 17, 18, 18, 17, 21, 17, 
+ 18, 21, 20, 21, 21, 21, 21, 21, 22, 25, 25, 25, 26, 27, 28, 28, 29, 30, 31, 
+ 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 35, 36, 36, 33, 36, 35, 36, 36, 35, 
+ 36, 36, 37, 38, 38, 39, 40, 41, 42, 38, 39, 40, 41, 42, 40, 46, 42, 43, 46, 
+ 46, 46, 46, 48, 48, 48, 48, 49, 49, 48, 53, 54, 51, 52, 53, 54, 55, 56, 57, 
+ 58, 59, 59, 60, 62, 62, 63, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 
+ 65, 66, 67, 65, 66, 67, 66, 69, 70, 66, 67, 66, 69, 70, 69, 70, 70, 71, 72, 
+ 71, 72, 72, 74, 74, 75, 72, 72, 74, 74, 75, 72, 72, 74, 75, 75, 72, 72, 74, 
+ 75, 75, 77, 77, 79, 80, 80, 82 };
+
+const unsigned int splits_Bob[MAX_Bob] = {
+  0, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 
+ 10, 12, 12, 12, 12, 12, 12, 13, 14, 14, 15, 16, 16, 16, 16, 16, 17, 16, 16, 
+ 17, 19, 19, 20, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 24, 24, 25, 27, 
+ 27, 28, 28, 29, 28, 29, 28, 28, 28, 30, 28, 28, 28, 29, 30, 33, 33, 33, 33, 
+ 34, 35, 37, 37, 37, 37, 38, 38, 37, 38, 38, 38, 38, 38, 39, 43, 38, 38, 38, 
+ 38, 43, 40, 41, 42, 43, 48, 45, 46, 47, 47, 48, 49, 49, 49, 50, 51, 50, 49, 
+ 49, 49, 49, 51, 49, 53, 50, 51, 50, 51, 51, 51, 52, 55, 55, 55, 56, 56, 56, 
+ 56, 56, 58, 58, 61, 61, 61, 63, 63, 63, 64, 65, 65, 65, 65, 66, 66, 65, 65, 
+ 66, 66, 66, 66, 66, 66, 66, 71, 66, 73, 66, 66, 71, 66, 73, 66, 66, 71, 66, 
+ 73, 68, 68, 71, 71, 73, 73, 73, 75, 75, 78, 78, 78, 80, 80, 80, 81, 81, 82, 
+ 83, 84, 85, 86, 86, 86, 86, 86, 87, 86, 88, 86, 86, 86, 86, 88, 86, 88, 86, 
+ 86, 86, 88, 88, 86, 86, 86, 93, 90, 90, 92, 92, 92, 93, 93, 93, 93, 93, 97, 
+ 97, 97, 97, 97, 97 };
+                                         
\ No newline at end of file
diff --git a/crypto/sidh/sidhlib/SIDH.h b/crypto/sidh/sidhlib/SIDH.h
new file mode 100644
index 0000000..d03b47a
--- /dev/null
+++ b/crypto/sidh/sidhlib/SIDH.h
@@ -0,0 +1,274 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: main header file
+*
+*********************************************************************************************/  
+
+#ifndef __SIDH_H__
+#define __SIDH_H__
+
+
+// For C++
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+
+// Definition of operating system
+
+#define OS_WIN       1
+#define OS_LINUX     2
+
+#if (defined(OPENSSL_SYS_WINDOWS) || defined(WINDOWS) || defined(OPENSSL_SYS_WIN64) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN32_UWIN) || defined(OPENSSL_SYS_WIN32_CYGWIN))
+    #define OS_TARGET OS_WIN
+#else
+    #define OS_TARGET OS_LINUX 
+#endif
+
+#if (defined(__x86_64__) || defined(__x86_64) || defined(__arch64__) || defined(_M_AMD64) || defined(_M_X64) || defined(_WIN64) || !defined(__LP64__))
+    #define TARGET TARGET_AMD64
+    #define RADIX           64
+    typedef uint64_t        digit_t;        // Unsigned 64-bit digit
+    typedef int64_t         sdigit_t;       // Signed 64-bit digit
+    #define NWORDS_FIELD    12              // Number of words of a 751-bit field element
+    #define p751_ZERO_WORDS 5               // Number of "0" digits in the least significant part of p751 - 1     
+#else
+    #define TARGET TARGET_x86
+    #define TARGET TARGET_ARM
+    #define RADIX           32
+    typedef uint32_t        digit_t;        // Unsigned 32-bit digit
+    typedef int32_t         sdigit_t;       // Signed 32-bit digit
+    #define NWORDS_FIELD    24 
+    #define p751_ZERO_WORDS 11
+#endif
+
+#define RADIX64         64
+
+// Extended datatype support
+#if defined(SIDH_ASM)
+#if (TARGET == TARGET_AMD64 && OS_TARGET == OS_WIN)
+    #define SCALAR_INTRIN_SUPPORT   
+    typedef uint64_t uint128_t[2];
+#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_LINUX)
+    #define UINT128_SUPPORT
+    typedef unsigned uint128_t __attribute__((mode(TI))); 
+#endif
+#else   /* generic implementation */
+  typedef uint64_t uint128_t[2];
+#endif
+
+// Basic constants
+
+#define NBITS_FIELD     751  
+#define MAXBITS_FIELD   768                
+#define MAXWORDS_FIELD  ((MAXBITS_FIELD+RADIX-1)/RADIX)     // Max. number of words to represent field elements
+#define NWORDS64_FIELD  ((NBITS_FIELD+63)/64)               // Number of 64-bit words of a 751-bit field element 
+#define NBITS_ORDER     384
+#define NWORDS_ORDER    ((NBITS_ORDER+RADIX-1)/RADIX)       // Number of words of oA and oB, where oA and oB are the subgroup orders of Alice and Bob, resp.
+#define MAXBITS_ORDER   NBITS_ORDER                         
+#define MAXWORDS_ORDER  ((MAXBITS_ORDER+RADIX-1)/RADIX)     // Max. number of words to represent elements in [1, oA-1] or [1, oB].
+  
+// Basic constants for elliptic curve BigMont
+
+#define BIGMONT_NBITS_ORDER     749 
+#define BIGMONT_MAXBITS_ORDER   768  
+#define BIGMONT_NWORDS_ORDER    ((BIGMONT_NBITS_ORDER+RADIX-1)/RADIX)       // Number of words of BigMont's subgroup order.
+#define BIGMONT_MAXWORDS_ORDER  ((BIGMONT_MAXBITS_ORDER+RADIX-1)/RADIX)     // Max. number of words to represent elements in [1, BigMont_order].
+   
+
+// Definitions of the error-handling type and error codes
+
+typedef enum {
+    CRYPTO_SUCCESS,                          // 0x00
+    CRYPTO_ERROR,                            // 0x01
+    CRYPTO_ERROR_DURING_TEST,                // 0x02
+    CRYPTO_ERROR_UNKNOWN,                    // 0x03
+    CRYPTO_ERROR_NOT_IMPLEMENTED,            // 0x04
+    CRYPTO_ERROR_NO_MEMORY,                  // 0x05
+    CRYPTO_ERROR_INVALID_PARAMETER,          // 0x06
+    CRYPTO_ERROR_SHARED_KEY,                 // 0x07
+    CRYPTO_ERROR_PUBLIC_KEY_VALIDATION,      // 0x08
+    CRYPTO_ERROR_TOO_MANY_ITERATIONS,        // 0x09
+    CRYPTO_ERROR_END_OF_LIST
+} CRYPTO_STATUS;
+
+#define CRYPTO_STATUS_TYPE_SIZE (CRYPTO_ERROR_END_OF_LIST)
+
+
+// Definitions of the error messages
+// NOTE: they must match the error codes above
+
+#define CRYPTO_MSG_SUCCESS                                "CRYPTO_SUCCESS"
+#define CRYPTO_MSG_ERROR                                  "CRYPTO_ERROR"
+#define CRYPTO_MSG_ERROR_DURING_TEST                      "CRYPTO_ERROR_DURING_TEST"
+#define CRYPTO_MSG_ERROR_UNKNOWN                          "CRYPTO_ERROR_UNKNOWN"
+#define CRYPTO_MSG_ERROR_NOT_IMPLEMENTED                  "CRYPTO_ERROR_NOT_IMPLEMENTED"
+#define CRYPTO_MSG_ERROR_NO_MEMORY                        "CRYPTO_ERROR_NO_MEMORY"
+#define CRYPTO_MSG_ERROR_INVALID_PARAMETER                "CRYPTO_ERROR_INVALID_PARAMETER"
+#define CRYPTO_MSG_ERROR_SHARED_KEY                       "CRYPTO_ERROR_SHARED_KEY"
+#define CRYPTO_MSG_ERROR_PUBLIC_KEY_VALIDATION            "CRYPTO_ERROR_PUBLIC_KEY_VALIDATION"
+#define CRYPTO_MSG_ERROR_TOO_MANY_ITERATIONS              "CRYPTO_ERROR_TOO_MANY_ITERATIONS"                                                    
+
+
+// Definition of type for curve isogeny system identifiers. Currently valid value is "SIDHp751" (see SIDH.h)
+typedef char CurveIsogeny_ID[10];
+
+
+// Supersingular elliptic curve isogeny structures:
+
+// This data struct contains the static curve isogeny data
+typedef struct
+{    
+    CurveIsogeny_ID  CurveIsogeny;                           // Curve isogeny system identifier, base curve defined over GF(p^2) 
+    unsigned int     pwordbits;                              // Smallest multiple of 32 larger than the prime bitlength
+    unsigned int     owordbits;                              // Smallest multiple of 32 larger than the order bitlength
+    unsigned int     pbits;                                  // Bitlength of the prime p
+    uint64_t         prime[MAXWORDS_FIELD];                  // Prime p
+    uint64_t         A[MAXWORDS_FIELD];                      // Base curve parameter "A"
+    uint64_t         C[MAXWORDS_FIELD];                      // Base curve parameter "C"
+    unsigned int     oAbits;                                 // Order bitlength for Alice 
+    uint64_t         Aorder[MAXWORDS_ORDER];                 // Order of Alice's (sub)group 
+    unsigned int     oBbits;                                 // Order bitlength for Bob 
+    unsigned int     eB;                                     // Power of Bob's subgroup order (i.e., oB = 3^eB) 
+    uint64_t         Border[MAXWORDS_ORDER];                 // Order of Bob's (sub)group 
+    uint64_t         PA[2*MAXWORDS_FIELD];                   // Alice's generator PA = (XPA,YPA), where XPA and YPA are defined over GF(p)
+    uint64_t         PB[2*MAXWORDS_FIELD];                   // Bob's generator PB = (XPB,YPB), where XPB and YPB are defined over GF(p)
+    unsigned int     BigMont_A24;                            // BigMont's curve parameter A24 = (A+2)/4
+    uint64_t         BigMont_order[BIGMONT_MAXWORDS_ORDER];  // BigMont's subgroup order 
+    uint64_t         Montgomery_R2[MAXWORDS_FIELD];          // Montgomery constant (2^W)^2 mod p, using a suitable value W
+    uint64_t         Montgomery_pp[MAXWORDS_FIELD];          // Montgomery constant -p^-1 mod 2^W, using a suitable value W
+    uint64_t         Montgomery_one[MAXWORDS_FIELD];         // Value one in Montgomery representation
+} CurveIsogenyStaticData, *PCurveIsogenyStaticData;
+
+
+// This data struct is initialized with the targeted curve isogeny system during setup
+typedef struct
+{
+    CurveIsogeny_ID  CurveIsogeny;                           // Curve isogeny system identifier, base curve defined over GF(p^2) 
+    unsigned int     pwordbits;                              // Closest multiple of 32 to prime bitlength
+    unsigned int     owordbits;                              // Closest multiple of 32 to order bitlength
+    unsigned int     pbits;                                  // Bitlength of the prime p
+    digit_t*         prime;                                  // Prime p
+    digit_t*         A;                                      // Base curve parameter "A"
+    digit_t*         C;                                      // Base curve parameter "C"
+    unsigned int     oAbits;                                 // Order bitlength for Alice 
+    digit_t*         Aorder;                                 // Order of Alice's (sub)group 
+    unsigned int     oBbits;                                 // Order bitlength for Bob 
+    unsigned int     eB;                                     // Power of Bob's subgroup order (i.e., oB = 3^eB) 
+    digit_t*         Border;                                 // Order of Bob's (sub)group 
+    digit_t*         PA;                                     // Alice's generator PA = (XPA,YPA), where XPA and YPA are defined over GF(p)
+    digit_t*         PB;                                     // Bob's generator PB = (XPB,YPB), where XPB and YPB are defined over GF(p)
+    unsigned int     BigMont_A24;                            // BigMont's curve parameter A24 = (A+2)/4
+    digit_t*         BigMont_order;                          // BigMont's subgroup order
+    digit_t*         Montgomery_R2;                          // Montgomery constant (2^W)^2 mod p, using a suitable value W
+    digit_t*         Montgomery_pp;                          // Montgomery constant -p^-1 mod 2^W, using a suitable value W
+    digit_t*         Montgomery_one;                         // Value one in Montgomery representation
+} CurveIsogenyStruct, *PCurveIsogenyStruct;
+
+
+// Supported curve isogeny systems:
+
+// "SIDHp751", base curve: supersingular elliptic curve E: y^2 = x^3 + x
+extern CurveIsogenyStaticData CurveIsogeny_SIDHp751;
+
+
+/******************** Function prototypes ***********************/
+/*************** Setup/initialization functions *****************/ 
+
+// Dynamic allocation of memory for curve isogeny structure.
+// Returns NULL on error.
+PCurveIsogenyStruct SIDH_curve_allocate(PCurveIsogenyStaticData CurveData);
+
+// Initialize curve isogeny structure pCurveIsogeny with static data extracted from pCurveIsogenyData. 
+// This needs to be called after allocating memory for "pCurveIsogeny" using SIDH_curve_allocate().
+CRYPTO_STATUS SIDH_curve_initialize(PCurveIsogenyStruct pCurveIsogeny, PCurveIsogenyStaticData pCurveIsogenyData); 
+
+// Free memory for curve isogeny structure
+void SIDH_curve_free(PCurveIsogenyStruct pCurveIsogeny);
+
+// Output error/success message for a given CRYPTO_STATUS
+const char* SIDH_get_error_message(CRYPTO_STATUS Status);
+
+// Output random values in the range [1, order-1] in little endian format that can be used as private keys.
+CRYPTO_STATUS random_mod_order(digit_t* random_digits, unsigned int AliceOrBob, PCurveIsogenyStruct pCurveIsogeny);
+
+// Output random values in the range [1, BigMont_order-1] in little endian format that can be used as private keys
+// to compute scalar multiplications using the elliptic curve BigMont.
+CRYPTO_STATUS random_BigMont_mod_order(digit_t* random_digits, PCurveIsogenyStruct pCurveIsogeny);
+
+// Clear "nwords" digits from memory
+void clear_words(void* mem, digit_t nwords);
+
+/*********************** Key exchange API ***********************/ 
+
+// Alice's key-pair generation
+// It produces a private key pPrivateKeyA and computes the public key pPublicKeyA.
+// The private key is an even integer in the range [2, oA-2], where oA = 2^372 (i.e., 372 bits in total).  
+// The public key consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS KeyGeneration_A(unsigned char* pPrivateKeyA, unsigned char* pPublicKeyA, PCurveIsogenyStruct CurveIsogeny);
+
+// Bob's key-pair generation
+// It produces a private key pPrivateKeyB and computes the public key pPublicKeyB.
+// The private key is an integer in the range [1, oB-1], where oA = 3^239 (i.e., 379 bits in total).  
+// The public key consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS KeyGeneration_B(unsigned char* pPrivateKeyB, unsigned char* pPublicKeyB, PCurveIsogenyStruct CurveIsogeny);
+
+// Alice's shared secret generation
+// It produces a shared secret key pSharedSecretA using her secret key pPrivateKeyA and Bob's public key pPublicKeyB
+// Inputs: Alice's pPrivateKeyA is an even integer in the range [2, oA-2], where oA = 2^372 (i.e., 372 bits in total). 
+//         Bob's pPublicKeyB consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+//         "validate" flag that indicates if Alice must validate Bob's public key. 
+// Output: a shared secret pSharedSecretA that consists of one element in GF(p751^2), i.e., 1502 bits in total. 
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS SecretAgreement_A(unsigned char* pPrivateKeyA, unsigned char* pPublicKeyB, unsigned char* pSharedSecretA, bool validate, PCurveIsogenyStruct CurveIsogeny);
+
+// Bob's shared secret generation
+// It produces a shared secret key pSharedSecretB using his secret key pPrivateKeyB and Alice's public key pPublicKeyA
+// Inputs: Bob's pPrivateKeyB is an integer in the range [1, oB-1], where oA = 3^239 (i.e., 379 bits in total). 
+//         Alice's pPublicKeyA consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+//         "validate" flag that indicates if Bob must validate Alice's public key. 
+// Output: a shared secret pSharedSecretB that consists of one element in GF(p751^2), i.e., 1502 bits in total. 
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS SecretAgreement_B(unsigned char* pPrivateKeyB, unsigned char* pPublicKeyA, unsigned char* pSharedSecretB, bool validate, PCurveIsogenyStruct CurveIsogeny);
+
+/*********************** Scalar multiplication API using BigMont ***********************/ 
+
+// BigMont's scalar multiplication using the Montgomery ladder
+// Inputs: x, the affine x-coordinate of a point P on BigMont: y^2=x^3+A*x^2+x, 
+//         scalar m.
+// Output: xout, the affine x-coordinate of m*(x:1)
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS BigMont_ladder(unsigned char* x, digit_t* m, unsigned char* xout, PCurveIsogenyStruct CurveIsogeny);
+
+
+// Encoding of keys for isogeny system "SIDHp751" (wire format):
+// ------------------------------------------------------------
+// Elements over GF(p751) are encoded in 96 octets in little endian format (i.e., the least significant octet located at the leftmost position). 
+// Elements (a+b*i) over GF(p751^2), where a and b are defined over GF(p751), are encoded as {b, a}, with b in the least significant position.
+// Elements over Z_oA and Z_oB are encoded in 48 octets in little endian format. 
+//
+// Private keys pPrivateKeyA and pPrivateKeyB are defined in Z_oA and Z_oB (resp.) and can have values in the range [2, 2^372-2] and [1, 3^239-1], resp.
+// In the key exchange API, they are encoded in 48 octets in little endian format. 
+// Public keys pPublicKeyA and pPublicKeyB consist of four elements in GF(p751^2). In the key exchange API, they are encoded in 768 octets in little
+// endian format. 
+// Shared keys pSharedSecretA and pSharedSecretB consist of one element in GF(p751^2). In the key exchange API, they are encoded in 192 octets in little
+// endian format. 
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff --git a/crypto/sidh/sidhlib/SIDH_internal.h b/crypto/sidh/sidhlib/SIDH_internal.h
new file mode 100644
index 0000000..3dbea50
--- /dev/null
+++ b/crypto/sidh/sidhlib/SIDH_internal.h
@@ -0,0 +1,429 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: internal header file
+*
+*********************************************************************************************/  
+
+#ifndef __SIDH_INTERNAL_H__
+#define __SIDH_INTERNAL_H__
+
+
+// For C++
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include "SIDH.h"   
+    
+
+// Basic constants
+
+#define ALICE                 0
+#define BOB                   1 
+#define MAX_INT_POINTS_ALICE  8      
+// Fixed parameters for isogeny tree computation    
+#define MAX_INT_POINTS_BOB    10 
+#define MAX_Alice             185   
+#define MAX_Bob               239
+   
+
+// SIDH's basic element definitions and point representations
+
+typedef digit_t felm_t[NWORDS_FIELD];                             // Datatype for representing 751-bit field elements (768-bit max.)
+typedef digit_t dfelm_t[2*NWORDS_FIELD];                          // Datatype for representing double-precision 2x751-bit field elements (2x768-bit max.) 
+typedef felm_t  f2elm_t[2];                                       // Datatype for representing quadratic extension field elements GF(p751^2)
+typedef f2elm_t publickey_t[3];                                   // Datatype for representing public keys equivalent to three GF(p751^2) elements
+        
+typedef struct { f2elm_t x; f2elm_t y; } point_affine;            // Point representation in affine coordinates on Montgomery curve.
+typedef point_affine point_t[1]; 
+        
+typedef struct { f2elm_t X; f2elm_t Z; } point_proj;              // Point representation in projective XZ Montgomery coordinates.
+typedef point_proj point_proj_t[1]; 
+        
+typedef struct { felm_t x; felm_t y; } point_basefield_affine;    // Point representation in affine coordinates on Montgomery curve over the base field.
+typedef point_basefield_affine point_basefield_t[1];  
+        
+typedef struct { felm_t X; felm_t Z; } point_basefield_proj;      // Point representation in projective XZ Montgomery coordinates over the base field.
+typedef point_basefield_proj point_basefield_proj_t[1]; 
+    
+
+// Macro definitions
+
+#define NBITS_TO_NBYTES(nbits)      (((nbits)+7)/8)                                          // Conversion macro from number of bits to number of bytes
+#define NBITS_TO_NWORDS(nbits)      (((nbits)+(sizeof(digit_t)*8)-1)/(sizeof(digit_t)*8))    // Conversion macro from number of bits to number of computer words
+#define NBYTES_TO_NWORDS(nbytes)    (((nbytes)+sizeof(digit_t)-1)/sizeof(digit_t))           // Conversion macro from number of bytes to number of computer words
+
+// Macro to avoid compiler warnings when detecting unreferenced parameters
+#define UNREFERENCED_PARAMETER(PAR) (PAR)
+
+
+/********************** Constant-time unsigned comparisons ***********************/
+
+// The following functions return 1 (TRUE) if condition is true, 0 (FALSE) otherwise
+
+static __inline unsigned int is_digit_nonzero_ct(digit_t x)
+{ // Is x != 0?
+    return (unsigned int)((x | (0-x)) >> (RADIX-1));
+}
+
+static __inline unsigned int is_digit_zero_ct(digit_t x)
+{ // Is x = 0?
+    return (unsigned int)(1 ^ is_digit_nonzero_ct(x));
+}
+
+static __inline unsigned int is_digit_lessthan_ct(digit_t x, digit_t y)
+{ // Is x < y?
+    return (unsigned int)((x ^ ((x ^ y) | ((x - y) ^ y))) >> (RADIX-1)); 
+}
+
+
+/********************** Macros for platform-dependent operations **********************/
+
+#if !defined(SIDH_ASM)
+
+// Digit multiplication
+#define MUL(multiplier, multiplicand, hi, lo)                                                     \
+    digit_x_digit((multiplier), (multiplicand), &(lo));
+    
+// Digit addition with carry
+#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \
+    { digit_t tempReg = (addend1) + (digit_t)(carryIn);                                           \
+    (sumOut) = (addend2) + tempReg;                                                               \
+    (carryOut) = (is_digit_lessthan_ct(tempReg, (digit_t)(carryIn)) | is_digit_lessthan_ct((sumOut), tempReg)); }
+
+// Digit subtraction with borrow
+#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \
+    { digit_t tempReg = (minuend) - (subtrahend);                                                 \
+    unsigned int borrowReg = (is_digit_lessthan_ct((minuend), (subtrahend)) | ((borrowIn) & is_digit_zero_ct(tempReg)));  \
+    (differenceOut) = tempReg - (digit_t)(borrowIn);                                              \
+    (borrowOut) = borrowReg; }
+    
+// Shift right with flexible datatype
+#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (DigitSize - (shift)));
+    
+// Shift left with flexible datatype
+#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (DigitSize - (shift)));
+
+// 64x64-bit multiplication
+#define MUL128(multiplier, multiplicand, product)                                                 \
+    mp_mul((digit_t*)&(multiplier), (digit_t*)&(multiplicand), (digit_t*)&(product), NWORDS_FIELD/2);
+
+// 128-bit addition, inputs < 2^127
+#define ADD128(addend1, addend2, addition)                                                        \
+    mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);
+
+// 128-bit addition with output carry
+#define ADC128(addend1, addend2, carry, addition)                                                 \
+    (carry) = mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);
+
+#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_WIN)
+
+// Digit multiplication
+#define MUL(multiplier, multiplicand, hi, lo)                                                     \
+    (lo) = _umul128((multiplier), (multiplicand), (hi));                
+
+// Digit addition with carry
+#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \
+    (carryOut) = _addcarry_u64((carryIn), (addend1), (addend2), &(sumOut));
+
+// Digit subtraction with borrow
+#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \
+    (borrowOut) = _subborrow_u64((borrowIn), (minuend), (subtrahend), &(differenceOut));
+
+// Digit shift right
+#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = __shiftright128((lowIn), (highIn), (shift));
+
+// Digit shift left
+#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = __shiftleft128((lowIn), (highIn), (shift));
+
+// 64x64-bit multiplication
+#define MUL128(multiplier, multiplicand, product)                                                 \
+    (product)[0] = _umul128((multiplier), (multiplicand), &(product)[1]);
+
+// 128-bit addition, inputs < 2^127
+#define ADD128(addend1, addend2, addition)                                                        \
+    { unsigned char carry = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);         \
+    _addcarry_u64(carry, (addend1)[1], (addend2)[1], &(addition)[1]); }
+
+// 128-bit addition with output carry
+#define ADC128(addend1, addend2, carry, addition)                                                 \
+    (carry) = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);                       \
+    (carry) = _addcarry_u64((carry), (addend1)[1], (addend2)[1], &(addition)[1]); 
+
+// 128-bit subtraction, subtrahend < 2^127
+#define SUB128(minuend, subtrahend, difference)                                                   \
+    { unsigned char borrow = _subborrow_u64(0, (minuend)[0], (subtrahend)[0], &(difference)[0]);  \
+    _subborrow_u64(borrow, (minuend)[1], (subtrahend)[1], &(difference)[1]); }
+
+// 128-bit right shift, max. shift value is 64
+#define SHIFTR128(Input, shift, shiftOut)                                                         \
+    (shiftOut)[0]  = __shiftright128((Input)[0], (Input)[1], (shift));                            \
+    (shiftOut)[1] = (Input)[1] >> (shift);    
+
+// 128-bit left shift, max. shift value is 64
+#define SHIFTL128(Input, shift, shiftOut)                                                         \
+    (shiftOut)[1]  = __shiftleft128((Input)[0], (Input)[1], (shift));                             \
+    (shiftOut)[0] = (Input)[0] << (shift);  
+
+#define MULADD128(multiplier, multiplicand, addend, carry, result);    \
+    { uint128_t product;                                               \
+      MUL128(multiplier, multiplicand, product);                       \
+      ADC128(addend, product, carry, result); }   
+
+#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_LINUX)
+
+// Digit multiplication
+#define MUL(multiplier, multiplicand, hi, lo)                                                     \
+    { uint128_t tempReg = (uint128_t)(multiplier) * (uint128_t)(multiplicand);                    \
+    *(hi) = (digit_t)(tempReg >> RADIX);                                                          \
+    (lo) = (digit_t)tempReg; }
+
+// Digit addition with carry
+#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \
+    { uint128_t tempReg = (uint128_t)(addend1) + (uint128_t)(addend2) + (uint128_t)(carryIn);     \
+    (carryOut) = (digit_t)(tempReg >> RADIX);                                                     \
+    (sumOut) = (digit_t)tempReg; }  
+    
+// Digit subtraction with borrow
+#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \
+    { uint128_t tempReg = (uint128_t)(minuend) - (uint128_t)(subtrahend) - (uint128_t)(borrowIn); \
+    (borrowOut) = (digit_t)(tempReg >> (sizeof(uint128_t)*8 - 1));                                \
+    (differenceOut) = (digit_t)tempReg; }
+
+// Digit shift right
+#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (RADIX - (shift)));
+
+// Digit shift left
+#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (RADIX - (shift)));
+
+#endif
+
+
+// Multiprecision multiplication selection
+#if !defined(SIDH_ASM) && (TARGET == TARGET_AMD64)
+    #define mp_mul_comba         mp_mul
+#else
+    #define mp_mul_schoolbook    mp_mul
+#endif
+
+
+
+/**************** Function prototypes ****************/
+/************* Multiprecision functions **************/ 
+
+// Copy wordsize digits, c = a, where lng(a) = nwords
+void copy_words(digit_t* a, digit_t* c, unsigned int nwords);
+
+// Multiprecision addition, c = a+b, where lng(a) = lng(b) = nwords. Returns the carry bit 
+extern unsigned int mp_add(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);
+
+// Multiprecision subtraction, c = a-b, where lng(a) = lng(b) = nwords. Returns the borrow bit 
+extern unsigned int mp_sub(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);
+
+// Multiprecision right shift by one
+void mp_shiftr1(digit_t* x, unsigned int nwords);
+
+// Multiprecision left right shift by one    
+void mp_shiftl1(digit_t* x, unsigned int nwords);
+
+// Digit multiplication, digit * digit -> 2-digit result
+void digit_x_digit(digit_t a, digit_t b, digit_t* c);    
+
+// Multiprecision schoolbook multiply, c = a*b, where lng(a) = lng(b) = nwords.
+void mp_mul_schoolbook(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);
+
+// Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.
+void mp_mul_comba(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);
+
+/************ Field arithmetic functions *************/
+
+// Copy of a field element, c = a
+void fpcopy751(felm_t a, felm_t c);
+
+// Zeroing a field element, a = 0
+void fpzero751(felm_t a);
+
+// Modular addition, c = a+b mod p751
+extern void fpadd751(digit_t* a, digit_t* b, digit_t* c);
+extern void fpadd751_asm(digit_t* a, digit_t* b, digit_t* c);
+
+// Modular subtraction, c = a-b mod p751
+extern void fpsub751(digit_t* a, digit_t* b, digit_t* c);
+extern void fpsub751_asm(digit_t* a, digit_t* b, digit_t* c);
+
+// Modular negation, a = -a mod p751        
+extern void fpneg751(digit_t* a);  
+
+// Modular division by two, c = a/2 mod p751.
+void fpdiv2_751(digit_t* a, digit_t* c);
+
+// Modular correction to reduce field element a in [0, 2*p751-1] to [0, p751-1].
+void fpcorrection751(digit_t* a);
+
+// 751-bit Montgomery reduction, c = a mod p
+void rdc_mont(digit_t* a, digit_t* c);
+            
+// Field multiplication using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768
+void fpmul751_mont(felm_t a, felm_t b, felm_t c);
+void mul751_asm(felm_t a, felm_t b, dfelm_t c);
+void rdc751_asm(dfelm_t ma, dfelm_t mc);
+   
+// Field squaring using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768
+void fpsqr751_mont(felm_t ma, felm_t mc);
+
+// Conversion to Montgomery representation
+void to_mont(felm_t a, felm_t mc);
+    
+// Conversion from Montgomery representation to standard representation
+void from_mont(felm_t ma, felm_t c);
+
+// Field inversion, a = a^-1 in GF(p751)
+void fpinv751_mont(felm_t a);
+
+/************ GF(p^2) arithmetic functions *************/
+    
+// Copy of a GF(p751^2) element, c = a
+void fp2copy751(f2elm_t a, f2elm_t c);
+
+// Zeroing a GF(p751^2) element, a = 0
+void fp2zero751(f2elm_t a);
+
+// GF(p751^2) negation, a = -a in GF(p751^2)
+void fp2neg751(f2elm_t a);
+
+// GF(p751^2) addition, c = a+b in GF(p751^2)
+extern void fp2add751(f2elm_t a, f2elm_t b, f2elm_t c);           
+
+// GF(p751^2) subtraction, c = a-b in GF(p751^2)
+extern void fp2sub751(f2elm_t a, f2elm_t b, f2elm_t c); 
+
+// GF(p751^2) division by two, c = a/2  in GF(p751^2) 
+void fp2div2_751(f2elm_t a, f2elm_t c);
+
+// Modular correction, a = a in GF(p751^2)
+void fp2correction751(f2elm_t a);
+            
+// GF(p751^2) squaring using Montgomery arithmetic, c = a^2 in GF(p751^2)
+void fp2sqr751_mont(f2elm_t a, f2elm_t c);
+ 
+// GF(p751^2) multiplication using Montgomery arithmetic, c = a*b in GF(p751^2)
+void fp2mul751_mont(f2elm_t a, f2elm_t b, f2elm_t c);
+    
+// Conversion of a GF(p751^2) element to Montgomery representation
+void to_fp2mont(f2elm_t a, f2elm_t mc);
+
+// Conversion of a GF(p751^2) element from Montgomery representation to standard representation
+void from_fp2mont(f2elm_t ma, f2elm_t c);
+
+// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2)
+void fp2inv751_mont(f2elm_t a);
+
+// Select either x or y depending on value of option 
+void select_f2elm(f2elm_t x, f2elm_t y, f2elm_t z, digit_t option);
+
+/************ Elliptic curve and isogeny functions *************/
+
+// Check if curve isogeny structure is NULL
+bool is_CurveIsogenyStruct_null(PCurveIsogenyStruct pCurveIsogeny);
+
+// Swap points over the base field 
+void swap_points_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, digit_t option);
+
+// Swap points
+void swap_points(point_proj_t P, point_proj_t Q, digit_t option);
+
+// Computes the j-invariant of a Montgomery curve with projective constant.
+void j_inv(f2elm_t A, f2elm_t C, f2elm_t jinv);
+
+// Simultaneous doubling and differential addition.
+void xDBLADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ, f2elm_t A24);
+
+// Doubling of a Montgomery point in projective coordinates (X:Z).
+void xDBL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24);
+
+// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings.
+void xDBLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e);
+
+// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings and collects a few intermediate multiples.
+void xDBLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);
+
+// Differential addition.
+void xADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ);
+
+// Doubling of a Montgomery point in projective coordinates (X:Z) over the base field.
+void xDBL_basefield(point_basefield_proj_t P, point_basefield_proj_t Q);
+
+// Simultaneous doubling and differential addition over the base field.
+void xDBLADD_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, felm_t xPQ, felm_t A24);
+
+// The Montgomery ladder
+void ladder(felm_t x, digit_t* m, point_basefield_proj_t P, point_basefield_proj_t Q, felm_t A24, unsigned int order_bits, unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny);
+
+// Computes key generation entirely in the base field
+CRYPTO_STATUS secret_pt(point_basefield_t P, digit_t* m, unsigned int AliceOrBob, point_proj_t R, PCurveIsogenyStruct CurveIsogeny);
+
+// Computes P+[m]Q via x-only arithmetic.
+CRYPTO_STATUS ladder_3_pt(f2elm_t xP, f2elm_t xQ, f2elm_t xPQ, digit_t* m, unsigned int AliceOrBob, point_proj_t W, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);
+
+// Computes the corresponding 4-isogeny of a projective Montgomery point (X4:Z4) of order 4.
+void get_4_isog(point_proj_t P, f2elm_t A, f2elm_t C, f2elm_t* coeff);
+
+// Evaluates the isogeny at the point (X:Z) in the domain of the isogeny
+void eval_4_isog(point_proj_t P, f2elm_t* coeff);
+
+// Computes first 4-isogeny computed by Alice.
+void first_4_isog(point_proj_t P, f2elm_t A, f2elm_t Aout, f2elm_t Cout, PCurveIsogenyStruct CurveIsogeny);
+
+// Tripling of a Montgomery point in projective coordinates (X:Z).
+void xTPL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24);
+
+// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings.
+void xTPLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e);
+
+// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings and collects a few intermediate multiples.    
+void xTPLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);
+
+// Computes the corresponding 3-isogeny of a projective Montgomery point (X3:Z3) of order 3.
+void get_3_isog(point_proj_t P, f2elm_t A, f2elm_t C);
+
+// Computes the 3-isogeny R=phi(X:Z), given projective point (X3:Z3) of order 3 on a Montgomery curve and a point P = (X:Z).
+void eval_3_isog(point_proj_t P, point_proj_t Q);
+
+// 3-way simultaneous inversion
+void inv_3_way(f2elm_t z1, f2elm_t z2, f2elm_t z3);
+
+// Computing the point D = (x(Q-P),z(Q-P))
+void distort_and_diff(felm_t xP, point_proj_t d, PCurveIsogenyStruct CurveIsogeny);
+
+// Given the x-coordinates of P, Q, and R, returns the value A corresponding to the Montgomery curve E_A: y^2=x^3+A*x^2+x such that R=Q-P on E_A.
+void get_A(f2elm_t xP, f2elm_t xQ, f2elm_t xR, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);
+
+/************ Public key validation functions *************/
+
+// Validation of Alice's public key (ran by Bob)
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS Validate_PKA(f2elm_t A, publickey_t PKA, bool* valid, PCurveIsogenyStruct CurveIsogeny);
+
+// Validation of Bob's public key (ran by Alice)
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS Validate_PKB(f2elm_t A, publickey_t PKB, bool* valid, PCurveIsogenyStruct CurveIsogeny);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff --git a/crypto/sidh/sidhlib/SIDH_setup.c b/crypto/sidh/sidhlib/SIDH_setup.c
new file mode 100644
index 0000000..fc68d65
--- /dev/null
+++ b/crypto/sidh/sidhlib/SIDH_setup.c
@@ -0,0 +1,265 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: functions for initialization and getting randomness
+*
+*********************************************************************************************/ 
+
+#include <openssl/rand.h>
+#include "SIDH_internal.h"
+
+
+CRYPTO_STATUS SIDH_curve_initialize(PCurveIsogenyStruct pCurveIsogeny, PCurveIsogenyStaticData pCurveIsogenyData)
+{ // Initialize curve isogeny structure pCurveIsogeny with static data extracted from pCurveIsogenyData.
+  // This needs to be called after allocating memory for "pCurveIsogeny" using SIDH_curve_allocate().
+    unsigned int i, pwords, owords;
+
+    if (is_CurveIsogenyStruct_null(pCurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+
+    for (i = 0; i < 8; i++) {    // Copy 8-character identifier
+        pCurveIsogeny->CurveIsogeny[i] = pCurveIsogenyData->CurveIsogeny[i];
+    }
+    pCurveIsogeny->pwordbits = pCurveIsogenyData->pwordbits;
+    pCurveIsogeny->owordbits = pCurveIsogenyData->owordbits;
+    pCurveIsogeny->pbits = pCurveIsogenyData->pbits;
+    pCurveIsogeny->oAbits = pCurveIsogenyData->oAbits;
+    pCurveIsogeny->oBbits = pCurveIsogenyData->oBbits;
+    pCurveIsogeny->eB = pCurveIsogenyData->eB;
+    pCurveIsogeny->BigMont_A24 = pCurveIsogenyData->BigMont_A24;
+
+    pwords = (pCurveIsogeny->pwordbits + RADIX - 1)/RADIX;
+    owords = (pCurveIsogeny->owordbits + RADIX - 1)/RADIX;
+    copy_words((digit_t*)pCurveIsogenyData->prime, pCurveIsogeny->prime, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->A, pCurveIsogeny->A, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->C, pCurveIsogeny->C, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->Aorder, pCurveIsogeny->Aorder, owords);
+    copy_words((digit_t*)pCurveIsogenyData->Border, pCurveIsogeny->Border, owords);
+    copy_words((digit_t*)pCurveIsogenyData->PA, pCurveIsogeny->PA, 2*pwords);
+    copy_words((digit_t*)pCurveIsogenyData->PB, pCurveIsogeny->PB, 2*pwords);
+    copy_words((digit_t*)pCurveIsogenyData->BigMont_order, pCurveIsogeny->BigMont_order, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->Montgomery_R2, pCurveIsogeny->Montgomery_R2, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->Montgomery_pp, pCurveIsogeny->Montgomery_pp, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->Montgomery_one, pCurveIsogeny->Montgomery_one, pwords);
+    
+    return CRYPTO_SUCCESS;
+}
+
+
+PCurveIsogenyStruct SIDH_curve_allocate(PCurveIsogenyStaticData CurveData)
+{ // Dynamic allocation of memory for curve isogeny structure.
+  // Returns NULL on error.
+    digit_t pbytes = (CurveData->pwordbits + 7)/8;
+    digit_t obytes = (CurveData->owordbits + 7)/8;
+    PCurveIsogenyStruct pCurveIsogeny = NULL;
+
+    pCurveIsogeny = (PCurveIsogenyStruct)OPENSSL_malloc(sizeof(CurveIsogenyStruct));
+    pCurveIsogeny->prime = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->A = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->C = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->Aorder = (digit_t*)OPENSSL_malloc(obytes);
+    pCurveIsogeny->Border = (digit_t*)OPENSSL_malloc(obytes);
+    pCurveIsogeny->PA = (digit_t*)OPENSSL_malloc(2*pbytes);
+    pCurveIsogeny->PB = (digit_t*)OPENSSL_malloc(2*pbytes);
+    pCurveIsogeny->BigMont_order = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->Montgomery_R2 = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->Montgomery_pp = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->Montgomery_one = (digit_t*)OPENSSL_malloc(pbytes);
+
+    if (is_CurveIsogenyStruct_null(pCurveIsogeny)) {
+        return NULL;
+    }
+    return pCurveIsogeny;
+}
+
+
+void SIDH_curve_free(PCurveIsogenyStruct pCurveIsogeny)
+{ // Free memory for curve isogeny structure
+
+    if (pCurveIsogeny != NULL)
+    {
+        if (pCurveIsogeny->prime != NULL) 
+	  OPENSSL_free(pCurveIsogeny->prime);
+        if (pCurveIsogeny->A != NULL) 
+	  OPENSSL_free(pCurveIsogeny->A);
+        if (pCurveIsogeny->C != NULL) 
+	  OPENSSL_free(pCurveIsogeny->C);
+        if (pCurveIsogeny->Aorder != NULL) 
+	  OPENSSL_free(pCurveIsogeny->Aorder);
+        if (pCurveIsogeny->Border != NULL) 
+	  OPENSSL_free(pCurveIsogeny->Border);
+        if (pCurveIsogeny->PA != NULL) 
+	  OPENSSL_free(pCurveIsogeny->PA);
+        if (pCurveIsogeny->PB != NULL) 
+	  OPENSSL_free(pCurveIsogeny->PB);
+        if (pCurveIsogeny->BigMont_order != NULL) 
+	  OPENSSL_free(pCurveIsogeny->BigMont_order);
+        if (pCurveIsogeny->Montgomery_R2 != NULL) 
+	  OPENSSL_free(pCurveIsogeny->Montgomery_R2);
+        if (pCurveIsogeny->Montgomery_pp != NULL) 
+	  OPENSSL_free(pCurveIsogeny->Montgomery_pp);
+        if (pCurveIsogeny->Montgomery_one != NULL) 
+	  OPENSSL_free(pCurveIsogeny->Montgomery_one);
+
+        OPENSSL_free(pCurveIsogeny);
+    }
+}
+
+
+bool is_CurveIsogenyStruct_null(PCurveIsogenyStruct pCurveIsogeny)
+{ // Check if curve isogeny structure is NULL
+
+    if (pCurveIsogeny == NULL || pCurveIsogeny->prime == NULL || pCurveIsogeny->A == NULL || pCurveIsogeny->C == NULL || pCurveIsogeny->Aorder == NULL || pCurveIsogeny->Border == NULL || 
+        pCurveIsogeny->PA == NULL || pCurveIsogeny->PB == NULL || pCurveIsogeny->BigMont_order == NULL || pCurveIsogeny->Montgomery_R2 == NULL || pCurveIsogeny->Montgomery_pp == NULL || 
+        pCurveIsogeny->Montgomery_one == NULL)
+    {
+        return true;
+    }
+    return false;
+}
+
+
+const char* SIDH_get_error_message(CRYPTO_STATUS Status)
+{ // Output error/success message for a given CRYPTO_STATUS
+    struct error_mapping {
+        unsigned int index;
+        char*        string;
+    } mapping[CRYPTO_STATUS_TYPE_SIZE] = {
+        {CRYPTO_SUCCESS, CRYPTO_MSG_SUCCESS},
+        {CRYPTO_ERROR, CRYPTO_MSG_ERROR},
+        {CRYPTO_ERROR_DURING_TEST, CRYPTO_MSG_ERROR_DURING_TEST},
+        {CRYPTO_ERROR_UNKNOWN, CRYPTO_MSG_ERROR_UNKNOWN},
+        {CRYPTO_ERROR_NOT_IMPLEMENTED, CRYPTO_MSG_ERROR_NOT_IMPLEMENTED},
+        {CRYPTO_ERROR_NO_MEMORY, CRYPTO_MSG_ERROR_NO_MEMORY},
+        {CRYPTO_ERROR_INVALID_PARAMETER, CRYPTO_MSG_ERROR_INVALID_PARAMETER},
+        {CRYPTO_ERROR_SHARED_KEY, CRYPTO_MSG_ERROR_SHARED_KEY},
+        {CRYPTO_ERROR_PUBLIC_KEY_VALIDATION, CRYPTO_MSG_ERROR_PUBLIC_KEY_VALIDATION},
+        {CRYPTO_ERROR_TOO_MANY_ITERATIONS, CRYPTO_MSG_ERROR_TOO_MANY_ITERATIONS}
+    };
+
+    if (Status >= CRYPTO_STATUS_TYPE_SIZE || mapping[Status].string == NULL) {
+        return "Unrecognized CRYPTO_STATUS";
+    } else {
+        return mapping[Status].string;
+    }
+};
+
+
+const uint64_t Border_div3[NWORDS_ORDER] = { 0xEDCD718A828384F9, 0x733B35BFD4427A14, 0xF88229CF94D7CF38, 0x63C56C990C7C2AD6, 0xB858A87E8F4222C7, 0x254C9C6B525EAF5 }; 
+
+
+CRYPTO_STATUS random_mod_order(digit_t* random_digits, unsigned int AliceOrBob, PCurveIsogenyStruct pCurveIsogeny)
+{ // Output random values in the range [1, order-1] in little endian format that can be used as private keys.
+  // It makes requests of random values with length "oAbits" (when AliceOrBob = 0) or "oBbits" (when AliceOrBob = 1). 
+  // The process repeats until random value is in [0, Aorder-2]  ([0, Border-2], resp.). 
+  // If successful, the output is given in "random_digits" in the range [1, Aorder-1] ([1, Border-1], resp.).
+    unsigned int ntry = 0, nbytes, nwords;    
+    digit_t t1[MAXWORDS_ORDER] = {0}, order2[MAXWORDS_ORDER] = {0};
+    unsigned char mask;
+    CRYPTO_STATUS Status = CRYPTO_SUCCESS;
+
+    if (random_digits == NULL || is_CurveIsogenyStruct_null(pCurveIsogeny) || AliceOrBob > 1) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+
+    clear_words((void*)random_digits, MAXWORDS_ORDER);     
+    t1[0] = 2;
+    if (AliceOrBob == ALICE) {
+        nbytes = (pCurveIsogeny->oAbits+7)/8;                  // Number of random bytes to be requested 
+        nwords = NBITS_TO_NWORDS(pCurveIsogeny->oAbits);
+        mask = 0x07;                                           // Value for masking last random byte
+        copy_words(pCurveIsogeny->Aorder, order2, nwords);
+        mp_shiftr1(order2, nwords);                            // order/2
+        mp_sub(order2, t1, order2, nwords);                    // order2 = order/2-2
+    } else {
+        nbytes = (pCurveIsogeny->oBbits+7)/8;                    
+        nwords = NBITS_TO_NWORDS(pCurveIsogeny->oBbits);
+        mask = 0x03;                                           // Value for masking last random byte
+        mp_sub((digit_t*)Border_div3, t1, order2, nwords);     // order2 = order/3-2
+    }
+
+    do {
+        ntry++;
+        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, order-2] 
+            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;
+        }
+	if (!RAND_bytes((unsigned char*)random_digits, nbytes)) {
+            return CRYPTO_ERROR;
+        }
+        ((unsigned char*)random_digits)[nbytes-1] &= mask;     // Masking last byte 
+    } while (mp_sub(order2, random_digits, t1, nwords) == 1);
+    
+    clear_words((void*)t1, MAXWORDS_ORDER);  
+    t1[0] = 1;
+    mp_add(random_digits, t1, random_digits, nwords);          
+    copy_words(random_digits, t1, nwords);
+    mp_shiftl1(random_digits, nwords);                         // Alice's output in the range [2, order-2]
+    if (AliceOrBob == BOB) {
+        mp_add(random_digits, t1, random_digits, nwords);      // Bob's output in the range [3, order-3]
+    }
+
+    return Status;
+}
+
+
+CRYPTO_STATUS random_BigMont_mod_order(digit_t* random_digits, PCurveIsogenyStruct pCurveIsogeny)
+{ // Output random values in the range [1, BigMont_order-1] in little endian format that can be used as private keys to compute scalar multiplications 
+  // using the elliptic curve BigMont.
+  // It makes requests of random values with length "BIGMONT_NBITS_ORDER". 
+  // The process repeats until random value is in [0, BigMont_order-2] 
+  // If successful, the output is given in "random_digits" in the range [1, BigMont_order-1].
+    unsigned int ntry = 0, nbytes = (BIGMONT_NBITS_ORDER+7)/8, nwords = NBITS_TO_NWORDS(BIGMONT_NBITS_ORDER);    
+    digit_t t1[BIGMONT_MAXWORDS_ORDER] = {0}, order2[BIGMONT_MAXWORDS_ORDER] = {0};
+    unsigned char mask;
+    CRYPTO_STATUS Status = CRYPTO_SUCCESS;
+
+    if (random_digits == NULL || is_CurveIsogenyStruct_null(pCurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+
+    clear_words((void*)random_digits, BIGMONT_MAXWORDS_ORDER);     
+    t1[0] = 2;
+    mask = (unsigned char)(8*nbytes - BIGMONT_NBITS_ORDER);
+    mp_sub(pCurveIsogeny->BigMont_order, t1, order2, nwords);  // order2 = order-2
+    mask = ((unsigned char)-1 >> mask);                        // Value for masking last random byte
+
+    do {
+        ntry++;
+        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, order-2] 
+            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;
+        }
+	if (!RAND_bytes((unsigned char*)random_digits, nbytes)) {
+            return CRYPTO_ERROR;
+        }
+        ((unsigned char*)random_digits)[nbytes-1] &= mask;     // Masking last byte 
+    } while (mp_sub(order2, random_digits, t1, nwords) == 1);
+    
+    clear_words((void*)t1, BIGMONT_MAXWORDS_ORDER);  
+    t1[0] = 1;
+    mp_add(random_digits, t1, random_digits, nwords);          // Output in the range [1, order-1]
+
+    return Status;
+}
+
+
+void clear_words(void* mem, digit_t nwords)
+{ // Clear digits from memory. "nwords" indicates the number of digits to be zeroed.
+  // This function uses the volatile type qualifier to inform the compiler not to optimize out the memory clearing.
+    unsigned int i;
+    volatile digit_t *v = mem; 
+
+    for (i = 0; i < nwords; i++) {
+        v[i] = 0;
+    }
+}
+
+
+
+
+
+
diff --git a/crypto/sidh/sidhlib/ec_isogeny.c b/crypto/sidh/sidhlib/ec_isogeny.c
new file mode 100644
index 0000000..bf57a01
--- /dev/null
+++ b/crypto/sidh/sidhlib/ec_isogeny.c
@@ -0,0 +1,586 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: elliptic curve and isogeny functions
+*
+*********************************************************************************************/ 
+
+#include "SIDH_internal.h"
+
+
+void j_inv(f2elm_t A, f2elm_t C, f2elm_t jinv)
+{ // Computes the j-invariant of a Montgomery curve with projective constant.
+  // Input: A,C in GF(p^2).
+  // Output: j=256*(A^2-3*C^2)^3/(C^4*(A^2-4*C^2)), which is j-invariant of Montgomery curve B*y^2=x^3+(A/C)*x^2+x or (equivalently) j-invariant of B'*y^2=C*x^3+A*x^2+C*x.
+    f2elm_t t0, t1;
+    
+    fp2sqr751_mont(A, jinv);                           // jinv = A^2        
+    fp2sqr751_mont(C, t1);                             // t1 = C^2
+    fp2add751(t1, t1, t0);                             // t0 = t1+t1
+    fp2sub751(jinv, t0, t0);                           // t0 = jinv-t0
+    fp2sub751(t0, t1, t0);                             // t0 = t0-t1
+    fp2sub751(t0, t1, jinv);                           // jinv = t0-t1
+    fp2sqr751_mont(t1, t1);                            // t1 = t1^2
+    fp2mul751_mont(jinv, t1, jinv);                    // jinv = jinv*t1
+    fp2add751(t0, t0, t0);                             // t0 = t0+t0
+    fp2add751(t0, t0, t0);                             // t0 = t0+t0
+    fp2sqr751_mont(t0, t1);                            // t1 = t0^2
+    fp2mul751_mont(t0, t1, t0);                        // t0 = t0*t1
+    fp2add751(t0, t0, t0);                             // t0 = t0+t0
+    fp2add751(t0, t0, t0);                             // t0 = t0+t0
+    fp2inv751_mont(jinv);                              // jinv = 1/jinv 
+    fp2mul751_mont(jinv, t0, jinv);                    // jinv = t0*jinv
+}
+
+
+void xDBLADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ, f2elm_t A24)
+{ // Simultaneous doubling and differential addition.
+  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, affine difference xPQ=x(P-Q) and Montgomery curve constant A24=(A+2)/4.
+  // Output: projective Montgomery points P <- 2*P = (X2P:Z2P) such that x(2P)=X2P/Z2P, and Q <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. 
+    f2elm_t t0, t1, t2;
+
+    fp2add751(P->X, P->Z, t0);                         // t0 = XP+ZP
+    fp2sub751(P->X, P->Z, t1);                         // t1 = XP-ZP
+    fp2sqr751_mont(t0, P->X);                          // XP = (XP+ZP)^2
+    fp2sub751(Q->X, Q->Z, t2);                         // t2 = XQ-ZQ
+    fp2add751(Q->X, Q->Z, Q->X);                       // XQ = XQ+ZQ
+    fp2mul751_mont(t0, t2, t0);                        // t0 = (XP+ZP)*(XQ-ZQ)
+    fp2sqr751_mont(t1, P->Z);                          // ZP = (XP-ZP)^2
+    fp2mul751_mont(t1, Q->X, t1);                      // t1 = (XP-ZP)*(XQ+ZQ)
+    fp2sub751(P->X, P->Z, t2);                         // t2 = (XP+ZP)^2-(XP-ZP)^2
+    fp2mul751_mont(P->X, P->Z, P->X);                  // XP = (XP+ZP)^2*(XP-ZP)^2
+    fp2mul751_mont(t2, A24, Q->X);                     // XQ = A24*[(XP+ZP)^2-(XP-ZP)^2]
+    fp2sub751(t0, t1, Q->Z);                           // ZQ = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)
+    fp2add751(Q->X, P->Z, P->Z);                       // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+(XP-ZP)^2
+    fp2add751(t0, t1, Q->X);                           // XQ = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)
+    fp2mul751_mont(P->Z, t2, P->Z);                    // ZP = [A24*[(XP+ZP)^2-(XP-ZP)^2]+(XP-ZP)^2]*[(XP+ZP)^2-(XP-ZP)^2]
+    fp2sqr751_mont(Q->Z, Q->Z);                        // ZQ = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+    fp2sqr751_mont(Q->X, Q->X);                        // XQ = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2
+    fp2mul751_mont(Q->Z, xPQ, Q->Z);                   // ZQ = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+}
+
+
+void xDBL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24)
+{ // Doubling of a Montgomery point in projective coordinates (X:Z).
+  // Input: projective Montgomery x-coordinates P = (X1:Z1), where x1=X1/Z1 and Montgomery curve constant A24/C24=(A/C+2)/4.
+  // Output: projective Montgomery x-coordinates Q = 2*P = (X2:Z2).
+    f2elm_t t0, t1;
+    
+    fp2sub751(P->X, P->Z, t0);                         // t0 = X1-Z1
+    fp2add751(P->X, P->Z, t1);                         // t1 = X1+Z1
+    fp2sqr751_mont(t0, t0);                            // t0 = (X1-Z1)^2 
+    fp2sqr751_mont(t1, t1);                            // t1 = (X1+Z1)^2 
+    fp2mul751_mont(C24, t0, Q->Z);                     // Z2 = C24*(X1-Z1)^2   
+    fp2mul751_mont(t1, Q->Z, Q->X);                    // X2 = C24*(X1-Z1)^2*(X1+Z1)^2
+    fp2sub751(t1, t0, t1);                             // t1 = (X1+Z1)^2-(X1-Z1)^2 
+    fp2mul751_mont(A24, t1, t0);                       // t0 = A24*[(X1+Z1)^2-(X1-Z1)^2]
+    fp2add751(Q->Z, t0, Q->Z);                         // Z2 = A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2
+    fp2mul751_mont(Q->Z, t1, Q->Z);                    // Z2 = [A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2]*[(X1+Z1)^2-(X1-Z1)^2]
+}
+
+
+void xDBLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e)
+{ // Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings.
+  // Input: projective Montgomery x-coordinates P = (XP:ZP), such that xP=XP/ZP and Montgomery curve constant A/C.
+  // Output: projective Montgomery x-coordinates P <- (2^e)*P.
+    f2elm_t A24num, A24den;
+    int i;
+    
+    fp2add751(C, C, A24num);                           
+    fp2add751(A24num, A24num, A24den);                    
+    fp2add751(A24num, A, A24num); 
+    copy_words((digit_t*)P, (digit_t*)Q, 2*2*NWORDS_FIELD);
+
+    for (i = 0; i < e; i++) {
+        xDBL(Q, Q, A24num, A24den);
+    }
+}
+
+
+void xADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ)
+{ // Differential addition.
+  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, and affine difference xPQ=x(P-Q).
+  // Output: projective Montgomery point P <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. 
+    f2elm_t t0, t1;
+    
+    fp2add751(P->X, P->Z, t0);                         // t0 = XP+ZP
+    fp2sub751(P->X, P->Z, t1);                         // t1 = XP-ZP
+    fp2sub751(Q->X, Q->Z, P->X);                       // XP = XQ-ZQ
+    fp2add751(Q->X, Q->Z, P->Z);                       // ZP = XQ+ZQ
+    fp2mul751_mont(t0, P->X, t0);                      // t0 = (XP+ZP)*(XQ-ZQ)                           
+    fp2mul751_mont(t1, P->Z, t1);                      // t1 = (XP-ZP)*(XQ+ZQ)
+    fp2sub751(t0, t1, P->Z);                           // ZP = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)
+    fp2add751(t0, t1, P->X);                           // XP = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)
+    fp2sqr751_mont(P->Z, P->Z);                        // ZP = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+    fp2sqr751_mont(P->X, P->X);                        // XP = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2
+    fp2mul751_mont(P->Z, xPQ, P->Z);                   // ZP = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+}
+
+
+void xDBL_basefield(point_basefield_proj_t P, point_basefield_proj_t Q)
+{ // Doubling of a Montgomery point in projective coordinates (X:Z) over the base field.
+  // Input: projective Montgomery x-coordinates P = (X1:Z1), where x1=X1/Z1 and Montgomery curve constant A24/C24=(A/C+2)/4.
+  // Output: projective Montgomery x-coordinates Q = 2*P = (X2:Z2).
+    felm_t t0, t1;
+
+    // NOTE: this function is fixed for A24=1, C24=2
+    
+    fpsub751(P->X, P->Z, t0);                          // t0 = X1-Z1
+    fpadd751(P->X, P->Z, t1);                          // t1 = X1+Z1
+    fpsqr751_mont(t0, t0);                             // t0 = (X1-Z1)^2 
+    fpsqr751_mont(t1, t1);                             // t1 = (X1+Z1)^2   
+    fpadd751(t0, t0, Q->Z);                            // Z2 = C24*(X1-Z1)^2 
+    fpmul751_mont(t1, Q->Z, Q->X);                     // X2 = C24*(X1-Z1)^2*(X1+Z1)^2
+    fpsub751(t1, t0, t1);                              // t1 = (X1+Z1)^2-(X1-Z1)^2 
+    fpadd751(Q->Z, t1, Q->Z);                          // Z2 = A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2
+    fpmul751_mont(Q->Z, t1, Q->Z);                     // Z2 = [A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2]*[(X1+Z1)^2-(X1-Z1)^2]
+}
+
+
+void xDBLADD_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, felm_t xPQ, felm_t A24)
+{ // Simultaneous doubling and differential addition over the base field.
+  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, affine difference xPQ=x(P-Q) and Montgomery curve constant A24=(A+2)/4.
+  // Output: projective Montgomery points P <- 2*P = (X2P:Z2P) such that x(2P)=X2P/Z2P, and Q <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. 
+    felm_t t0, t1, t2;
+
+    // NOTE: this function is fixed for C24=2
+
+    fpadd751(P->X, P->Z, t0);                          // t0 = XP+ZP
+    fpsub751(P->X, P->Z, t1);                          // t1 = XP-ZP
+    fpsqr751_mont(t0, P->X);                           // XP = (XP+ZP)^2
+    fpsub751(Q->X, Q->Z, t2);                          // t2 = XQ-ZQ
+    fpadd751(Q->X, Q->Z, Q->X);                        // XQ = XQ+ZQ
+    fpmul751_mont(t0, t2, t0);                         // t0 = (XP+ZP)*(XQ-ZQ)
+    fpsqr751_mont(t1, P->Z);                           // ZP = (XP-ZP)^2
+    fpmul751_mont(t1, Q->X, t1);                       // t1 = (XP-ZP)*(XQ+ZQ)
+    fpsub751(P->X, P->Z, t2);                          // t2 = (XP+ZP)^2-(XP-ZP)^2
+
+    if (A24[0] == 1) {
+        fpadd751(P->Z, P->Z, P->Z);                    // ZP = C24*(XP-ZP)^2
+        fpmul751_mont(P->X, P->Z, P->X);               // XP = C24*(XP+ZP)^2*(XP-ZP)^2
+        fpadd751(t2, P->Z, P->Z);                      // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2
+    } else {
+        fpmul751_mont(P->X, P->Z, P->X);               // XP = (XP+ZP)^2*(XP-ZP)^2
+        fpmul751_mont(A24, t2, Q->X);                  // XQ = A24*[(XP+ZP)^2-(XP-ZP)^2]
+        fpadd751(P->Z, Q->X, P->Z);                    // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2
+    }
+    
+    fpsub751(t0, t1, Q->Z);                            // ZQ = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)
+    fpadd751(t0, t1, Q->X);                            // XQ = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)
+    fpmul751_mont(P->Z, t2, P->Z);                     // ZP = [A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2]*[(XP+ZP)^2-(XP-ZP)^2]
+    fpsqr751_mont(Q->Z, Q->Z);                         // ZQ = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+    fpsqr751_mont(Q->X, Q->X);                         // XQ = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2
+    fpmul751_mont(Q->Z, xPQ, Q->Z);                    // ZQ = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+}
+
+
+void ladder(felm_t x, digit_t* m, point_basefield_proj_t P, point_basefield_proj_t Q, felm_t A24, unsigned int order_bits, unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny)
+{ // The Montgomery ladder
+  // Inputs: the affine x-coordinate of a point P on E: B*y^2=x^3+A*x^2+x, 
+  //         scalar m
+  //         curve constant A24 = (A+2)/4
+  //         order_bits = subgroup order bitlength
+  //         order_fullbits = smallest multiple of 32 larger than the order bitlength
+  // Output: Q = m*(x:1)
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int bit = 0, owords = NBITS_TO_NWORDS(order_fullbits);
+    digit_t mask;
+    int i;
+
+    // Initializing with the points (1:0) and (x:1)
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)P->X);
+    fpzero751(P->Z);
+    fpcopy751(x, Q->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)Q->Z);
+
+    for (i = order_fullbits-order_bits; i > 0; i--) {
+        mp_shiftl1(m, owords);
+    }
+    
+    for (i = order_bits; i > 0; i--) {
+        bit = (unsigned int)(m[owords-1] >> (RADIX-1));
+        mp_shiftl1(m, owords);
+        mask = 0-(digit_t)bit;
+
+        swap_points_basefield(P, Q, mask);
+        xDBLADD_basefield(P, Q, x, A24);           // If bit=0 then P <- 2*P and Q <- P+Q, 
+        swap_points_basefield(P, Q, mask);         // else if bit=1 then Q <- 2*Q and P <- P+Q
+    }
+}
+
+
+CRYPTO_STATUS BigMont_ladder(unsigned char* x, digit_t* m, unsigned char* xout, PCurveIsogenyStruct CurveIsogeny)
+{ // BigMont's scalar multiplication using the Montgomery ladder
+  // Inputs: x, the affine x-coordinate of a point P on BigMont: y^2=x^3+A*x^2+x, 
+  //         scalar m.
+  // Output: xout, the affine x-coordinate of m*(x:1)
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    point_basefield_proj_t P1, P2;
+    digit_t scalar[BIGMONT_NWORDS_ORDER];
+    felm_t X, A24 = {0};
+
+    A24[0] = (digit_t)CurveIsogeny->BigMont_A24; 
+    to_mont(A24, A24);                               // Conversion to Montgomery representation
+    to_mont((digit_t*)x, X);
+    
+    copy_words(m, scalar, BIGMONT_NWORDS_ORDER);
+    ladder(X, scalar, P1, P2, A24, BIGMONT_NBITS_ORDER, BIGMONT_MAXBITS_ORDER, CurveIsogeny);
+
+    fpinv751_mont(P1->Z);
+    fpmul751_mont(P1->X, P1->Z, (digit_t*)xout);
+    from_mont((digit_t*)xout, (digit_t*)xout);       // Conversion to standard representation
+
+    return CRYPTO_SUCCESS;
+}
+
+
+CRYPTO_STATUS secret_pt(point_basefield_t P, digit_t* m, unsigned int AliceOrBob, point_proj_t R, PCurveIsogenyStruct CurveIsogeny)
+{ // Computes key generation entirely in the base field by exploiting a 1-dimensional Montgomery ladder in the trace zero subgroup and 
+  // recovering the y-coordinate for the addition. All operations in the base field GF(p).
+  // Input:  The scalar m, point P = (x,y) on E in the base field subgroup and Q = (x1,y1*i) on E in the trace-zero subgroup. 
+  //         x,y,x1,y1 are all in the base field.          
+  // Output: R = (RX0+RX1*i)/RZ0 (the x-coordinate of P+[m]Q).
+    unsigned int nbits;
+    point_basefield_t Q;
+    point_basefield_proj_t S, T;
+    digit_t *X0 = (digit_t*)S->X, *Z0 = (digit_t*)S->Z, *X1 = (digit_t*)T->X, *Z1 = (digit_t*)T->Z;
+    digit_t *x  = (digit_t*)P->x, *y  = (digit_t*)P->y, *x1 = (digit_t*)Q->x, *y1 = (digit_t*)Q->y;
+    digit_t scalar[NWORDS_ORDER];
+    felm_t t0, t1, t2, A24 = {0};
+    digit_t *RX0 = (digit_t*)R->X[0], *RX1 = (digit_t*)R->X[1], *RZ0 = (digit_t*)R->Z[0], *RZ1 = (digit_t*)R->Z[1];
+
+    fpcopy751(P->x, Q->x);                         // Q = (-XP,YP)
+    fpcopy751(P->y, Q->y);
+    fpneg751(Q->x);
+
+    if (AliceOrBob == ALICE) {
+        nbits = CurveIsogeny->oAbits;
+    } else if (AliceOrBob == BOB) {
+        nbits = CurveIsogeny->oBbits;
+    } else {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+        
+    // Setting curve constant to one (in standard representation), used in xDBLADD_basefield() in the ladder computation
+    A24[0] = 1;
+    copy_words(m, scalar, NWORDS_ORDER);
+    ladder(Q->x, scalar, S, T, A24, nbits, CurveIsogeny->owordbits, CurveIsogeny);
+    
+    //RX0 := (2*y*y1*Z0^2*Z1 + Z1*(X0*x1+Z0)*(X0+x1*Z0) - X1*(X0-x1*Z0)^2)*(2*y*y1*Z0^2*Z1 - Z1*(X0*x1+Z0)*(X0+x1*Z0) + X1*(X0-x1*Z0)^2) - 4*y1^2*Z0*Z1^2*(X0+x*Z0)*(X0-x*Z0)^2;
+    //RX1 := 4*y*y1*Z0^2*Z1*(Z1*(X0*x1+Z0)*(X0+x1*Z0) - X1*(X0-x1*Z0)^2);
+    //RZ0 := 4*y1^2*Z0^2*Z1^2*(X0-x*Z0)^2;
+
+    fpmul751_mont(x1, Z0, RX1);
+    fpmul751_mont(X0, x1, RX0);
+    fpsub751(X0, RX1, t0);
+    fpadd751(X0, RX1, RX1);
+    fpsqr751_mont(t0, t0);
+    fpadd751(RX0, Z0, RX0);
+    fpmul751_mont(t0, X1, t0);
+    fpmul751_mont(RX0, RX1, RX0);
+    fpmul751_mont(y1, Z1, t2);
+    fpmul751_mont(y, Z0, t1);
+    fpadd751(t2, t2, t2);
+    fpmul751_mont(t2, Z0, RX1);
+    fpmul751_mont(RX0, Z1, RX0);
+    fpsub751(RX0, t0, RX0);
+    fpmul751_mont(t1, RX1, t1);
+    fpsqr751_mont(RX1, t0);
+    fpmul751_mont(t2, RX1, t2);
+    fpmul751_mont(t1, RX0, RX1);
+    fpadd751(t1, RX0, RZ0);
+    fpadd751(RX1, RX1, RX1);
+    fpsub751(t1, RX0, t1);
+    fpmul751_mont(x, Z0, RX0);
+    fpmul751_mont(t1, RZ0, t1);
+    fpsub751(X0, RX0, RZ0);
+    fpadd751(X0, RX0, RX0);
+    fpsqr751_mont(RZ0, RZ0);
+    fpmul751_mont(t2, RX0, t2);
+    fpmul751_mont(t2, RZ0, t2);
+    fpmul751_mont(RZ0, t0, RZ0);
+    fpsub751(t1, t2, RX0);
+    fpzero751(RZ1);
+
+    return CRYPTO_SUCCESS;
+}
+
+
+CRYPTO_STATUS ladder_3_pt(f2elm_t xP, f2elm_t xQ, f2elm_t xPQ, digit_t* m, unsigned int AliceOrBob, point_proj_t W, f2elm_t A, PCurveIsogenyStruct CurveIsogeny)
+{ // Computes P+[m]Q via x-only arithmetic. Algorithm by De Feo, Jao and Plut.
+  // Input:  three affine points xP,xQ,xPQ and Montgomery constant A.
+  // Output: projective Montgomery x-coordinates of x(P+[m]Q)=WX/WZ
+    point_proj_t U = {0}, V = {0};
+    f2elm_t A24, A24num, constant1 = {0}, constant2;
+    felm_t temp_scalar;
+    unsigned int bit = 0, nbits, fullbits = CurveIsogeny->owordbits;
+    digit_t mask;
+    int i;
+
+    if (AliceOrBob == ALICE) {
+        nbits = CurveIsogeny->oAbits;
+    } else if (AliceOrBob == BOB) {
+        nbits = CurveIsogeny->oBbits;
+    } else {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+   
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, constant1[0]);
+    fp2add751(constant1, constant1, constant1);                  // constant = 2
+    fp2add751(A, constant1, A24num);
+    fp2div2_751(A24num, A24);  
+    fp2div2_751(A24, A24);
+    
+    // Initializing with the points (1:0), (xQ:1) and (xP:1)
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)U->X);
+    fp2copy751(xQ, V->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)V->Z);
+    fp2copy751(xP, W->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)W->Z);
+    fpzero751(W->Z[1]);
+    fpcopy751(m, temp_scalar);
+    
+    for (i = fullbits-nbits; i > 0; i--) {
+        mp_shiftl1(temp_scalar, NWORDS_ORDER);
+    }
+    
+    for (i = nbits; i > 0; i--) {
+        bit = (unsigned int)(temp_scalar[NWORDS_ORDER-1] >> (RADIX-1));
+        mp_shiftl1(temp_scalar, NWORDS_ORDER);
+        mask = 0 - (digit_t)bit;
+
+        swap_points(W, U, mask);
+        swap_points(U, V, mask);
+        select_f2elm(xP, xQ, constant1, mask);
+        select_f2elm(xQ, xPQ, constant2, mask);
+        xADD(W, U, constant1);                     // If bit=0 then W <- W+U, U <- 2*U and V <- U+V, 
+        xDBLADD(U, V, constant2, A24);             // else if bit=1 then U <- U+V, V <- 2*V and W <- V+W
+        swap_points(U, V, mask);
+        swap_points(W, U, mask);
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+
+void get_4_isog(point_proj_t P, f2elm_t A, f2elm_t C, f2elm_t* coeff)
+{ // Computes the corresponding 4-isogeny of a projective Montgomery point (X4:Z4) of order 4.
+  // Input:  projective point of order four P = (X4:Z4).
+  // Output: the 4-isogenous Montgomery curve with projective coefficient A/C and the 5 coefficients 
+  //         that are used to evaluate the isogeny at a point in eval_4_isog().
+    
+    fp2add751(P->X, P->Z, coeff[0]);                   // coeff[0] = X4+Z4
+    fp2sqr751_mont(P->X, coeff[3]);                    // coeff[3] = X4^2
+    fp2sqr751_mont(P->Z, coeff[4]);                    // coeff[4] = Z4^2
+    fp2sqr751_mont(coeff[0], coeff[0]);                // coeff[0] = (X4+Z4)^2
+    fp2add751(coeff[3], coeff[4], coeff[1]);           // coeff[1] = X4^2+Z4^2
+    fp2sub751(coeff[3], coeff[4], coeff[2]);           // coeff[2] = X4^2-Z4^2
+    fp2sqr751_mont(coeff[3], coeff[3]);                // coeff[3] = X4^4
+    fp2sqr751_mont(coeff[4], coeff[4]);                // coeff[4] = Z4^4
+    fp2add751(coeff[3], coeff[3], A);                  // A = 2*X4^4
+    fp2sub751(coeff[0], coeff[1], coeff[0]);           // coeff[0] = 2*X4*Z4 = (X4+Z4)^2 - (X4^2+Z4^2)
+    fp2sub751(A, coeff[4], A);                         // A = 2*X4^4-Z4^4
+    fp2copy751(coeff[4], C);                           // C = Z4^4
+    fp2add751(A, A, A);                                // A = 2(2*X4^4-Z4^4)
+}
+
+
+void eval_4_isog(point_proj_t P, f2elm_t* coeff)
+{ // Evaluates the isogeny at the point (X:Z) in the domain of the isogeny, given a 4-isogeny phi defined 
+  // by the 5 coefficients in coeff (computed in the function four_isogeny_from_projective_kernel()).
+  // Inputs: the coefficients defining the isogeny, and the projective point P = (X:Z).
+  // Output: the projective point P = phi(P) = (X:Z) in the codomain. 
+    f2elm_t t0, t1;
+
+    fp2mul751_mont(P->X, coeff[0], P->X);              // X = coeff[0]*X
+    fp2mul751_mont(P->Z, coeff[1], t0);                // t0 = coeff[1]*Z
+    fp2sub751(P->X, t0, P->X);                         // X = X-t0
+    fp2mul751_mont(P->Z, coeff[2], P->Z);              // Z = coeff[2]*Z
+    fp2sub751(P->X, P->Z, t0);                         // t0 = X-Z
+    fp2mul751_mont(P->Z, P->X, P->Z);                  // Z = X*Z
+    fp2sqr751_mont(t0, t0);                            // t0 = t0^2
+    fp2add751(P->Z, P->Z, P->Z);                       // Z = Z+Z
+    fp2add751(P->Z, P->Z, P->Z);                       // Z = Z+Z
+    fp2add751(P->Z, t0, P->X);                         // X = t0+Z
+    fp2mul751_mont(P->Z, t0, P->Z);                    // Z = t0*Z
+    fp2mul751_mont(P->Z, coeff[4], P->Z);              // Z = coeff[4]*Z
+    fp2mul751_mont(t0, coeff[4], t0);                  // t0 = t0*coeff[4]
+    fp2mul751_mont(P->X, coeff[3], t1);                // t1 = X*coeff[3]
+    fp2sub751(t0, t1, t0);                             // t0 = t0-t1
+    fp2mul751_mont(P->X, t0, P->X);                    // X = X*t0
+}
+
+
+void first_4_isog(point_proj_t P, f2elm_t A, f2elm_t Aout, f2elm_t Cout, PCurveIsogenyStruct CurveIsogeny)
+{ // Computes first 4-isogeny computed by Alice.
+  // Inputs: projective point P = (X4:Z4) and curve constant A.
+  // Output: the projective point P = (X4:Z4) in the codomain and isogenous curve constant Aout/Cout.  
+    f2elm_t t0 = {0}, t1, t2;
+    
+    fpcopy751(CurveIsogeny->Montgomery_one, t0[0]); 
+    fpadd751(t0[0], t0[0], t0[0]);                     // t0 = 2 (in Montgomery domain)
+    fp2sub751(A, t0, Cout);                            // Cout = A-2
+    fpadd751(t0[0], t0[0], t1[0]);                     
+    fpadd751(t0[0], t1[0], t0[0]);                     // t0 = 6 (in Montgomery domain)
+    fp2add751(P->X, P->Z, t1);                         // t1 = X+Z
+    fp2sub751(P->X, P->Z, t2);                         // t2 = X-Z
+    fp2sqr751_mont(t1, t1);                            // t1 = (X+Z)^2
+    fp2add751(A, t0, Aout);                            // A = A+6
+    fp2mul751_mont(P->X, P->Z, P->Z);                  // Z = X*Z
+    fp2neg751(P->Z);                                   // Z = -X*Z
+    fp2sqr751_mont(t2, t2);                            // t2 = (X-Z)^2
+    fp2mul751_mont(P->Z, Cout, P->Z);                  // Z = -C*X*Z
+    fp2add751(Aout, Aout, Aout);                       // Aout = 2*A+12
+    fp2sub751(t1, P->Z, P->X);                         // X = (X+Z)^2+C*X*Z
+    fp2mul751_mont(P->Z, t2, P->Z);                    // Z = -C*X*Z*(X-Z)^2
+    fp2mul751_mont(P->X, t1, P->X);                    // X = (X+Z)^2*[(X+Z)^2+C*X*Z]
+}
+
+
+void xTPL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24)
+{ // Tripling of a Montgomery point in projective coordinates (X:Z).
+  // Input: projective Montgomery x-coordinates P = (X:Z), where x=X/Z and Montgomery curve constant A/C.
+  // Output: projective Montgomery x-coordinates Q = 3*P = (X3:Z3).
+    f2elm_t t0, t1, t2, t3, t4, t5;
+
+    fp2sub751(P->X, P->Z, t2);                         // t2 = X-Z           
+    fp2add751(P->X, P->Z, t3);                         // t3 = X+Z 
+    fp2sqr751_mont(t2, t0);                            // t0 = t2^2 
+    fp2sqr751_mont(t3, t1);                            // t1 = t3^2 
+    fp2mul751_mont(t0, C24, t4);                       // t4 = C24*t0 
+    fp2mul751_mont(t1, t4, t5);                        // t5 = t4*t1
+    fp2sub751(t1, t0, t1);                             // t1 = t1-t0 
+    fp2mul751_mont(A24, t1, t0);                       // t0 = A24*t1
+    fp2add751(t4, t0, t4);                             // t4 = t4+t0
+    fp2mul751_mont(t1, t4, t4);                        // t4 = t4*t1
+    fp2add751(t5, t4, t0);                             // t0 = t5+t4
+    fp2sub751(t5, t4, t1);                             // t1 = t5-t4
+    fp2mul751_mont(t0, t2, t0);                        // t0 = t2*t0
+    fp2mul751_mont(t1, t3, t1);                        // t1 = t3*t1
+    fp2sub751(t0, t1, t4);                             // t4 = t0-t1
+    fp2add751(t0, t1, t5);                             // t5 = t0+t1
+    fp2sqr751_mont(t4, t4);                            // t4 = t4^2
+    fp2sqr751_mont(t5, t5);                            // t5 = t5^2
+    fp2mul751_mont(P->X, t4, t4);                      // t4 = X*t4
+    fp2mul751_mont(P->Z, t5, Q->X);                    // X3 = Z*t5
+    fp2copy751(t4, Q->Z);                              // Z3 = t4
+}
+
+
+void xTPLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e)
+{ // Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings.
+  // Input: projective Montgomery x-coordinates P = (XP:ZP), such that xP=XP/ZP and Montgomery curve constant A/C.
+  // Output: projective Montgomery x-coordinates P <- (3^e)*P.
+    f2elm_t A24, C24;
+    int i;
+    
+    fp2add751(C, C, A24);                           
+    fp2add751(A24, A24, C24);                    
+    fp2add751(A24, A, A24);       
+    copy_words((digit_t*)P, (digit_t*)Q, 2*2*NWORDS_FIELD);
+
+    for (i = 0; i < e; i++) {
+        xTPL(Q, Q, A24, C24);
+    }
+}
+
+
+void get_3_isog(point_proj_t P, f2elm_t A, f2elm_t C)
+{ // Computes the corresponding 3-isogeny of a projective Montgomery point (X3:Z3) of order 3.
+  // Input:  projective point of order three P = (X3:Z3).
+  // Output: the 3-isogenous Montgomery curve with projective coefficient A/C. 
+    f2elm_t t0, t1;
+
+    fp2sqr751_mont(P->X, t0);                          // t0 = X^2
+    fp2add751(t0, t0, t1);                             // t1 = 2*t0
+    fp2add751(t0, t1, t0);                             // t0 = t0+t1
+    fp2sqr751_mont(P->Z, t1);                          // t1 = Z^2
+    fp2sqr751_mont(t1, A);                             // A = t1^2
+    fp2add751(t1, t1, t1);                             // t1 = 2*t1
+    fp2add751(t1, t1, C);                              // C = 2*t1
+    fp2sub751(t0, t1, t1);                             // t1 = t0-t1
+    fp2mul751_mont(t0, t1, t1);                        // t1 = t0*t1
+    fp2sub751(A, t1, A);                               // A = A-t1 
+    fp2sub751(A, t1, A);                               // A = A-t1 
+    fp2sub751(A, t1, A);                               // A = A-t1     
+    fp2mul751_mont(P->X, P->Z, t1);                    // t1 = X*Z    // ms trade-off possible (1 mul for 1sqr + 1add + 2sub)
+    fp2mul751_mont(C, t1, C);                          // C = C*t1
+}
+
+
+void eval_3_isog(point_proj_t P, point_proj_t Q)
+{ // Computes the 3-isogeny R=phi(X:Z), given projective point (X3:Z3) of order 3 on a Montgomery curve and a point P = (X:Z).
+  // Inputs: projective points P = (X3:Z3) and Q = (X:Z).
+  // Output: the projective point R = phi(Q) = (XX:ZZ). 
+    f2elm_t t0, t1, t2;
+
+    fp2mul751_mont(P->X, Q->X, t0);                  // t0 = X3*X
+    fp2mul751_mont(P->Z, Q->X, t1);                  // t1 = Z3*X
+    fp2mul751_mont(P->Z, Q->Z, t2);                  // t2 = Z3*Z
+    fp2sub751(t0, t2, t0);                           // t0 = X3*X-Z3*Z          
+    fp2mul751_mont(P->X, Q->Z, t2);                  // t2 = X3*Z
+    fp2sub751(t1, t2, t1);                           // t1 = Z3*X-X3*Z
+    fp2sqr751_mont(t0, t0);                          // t0 = (X3*X-Z3*Z)^2
+    fp2sqr751_mont(t1, t1);                          // t1 = (Z3*X-X3*Z)^2
+    fp2mul751_mont(Q->X, t0, Q->X);                  // X = X*(X3*X-Z3*Z)^2        
+    fp2mul751_mont(Q->Z, t1, Q->Z);                  // Z = Z*(Z3*X-X3*Z)^2
+}
+
+
+void inv_3_way(f2elm_t z1, f2elm_t z2, f2elm_t z3)
+{ // 3-way simultaneous inversion
+  // Input:  z1,z2,z3
+  // Output: 1/z1,1/z2,1/z3 (override inputs).
+    f2elm_t t0, t1, t2, t3;
+
+    fp2mul751_mont(z1, z2, t0);                      // t0 = z1*z2
+    fp2mul751_mont(z3, t0, t1);                      // t1 = z1*z2*z3
+    fp2inv751_mont(t1);                              // t1 = 1/(z1*z2*z3)
+    fp2mul751_mont(z3, t1, t2);                      // t2 = 1/(z1*z2) 
+    fp2mul751_mont(t2, z2, t3);                      // t3 = 1/z1
+    fp2mul751_mont(t2, z1, z2);                      // z2 = 1/z2
+    fp2mul751_mont(t0, t1, z3);                      // z3 = 1/z3
+    fp2copy751(t3, z1);                              // z1 = 1/z1
+}
+
+
+void distort_and_diff(felm_t xP, point_proj_t D, PCurveIsogenyStruct CurveIsogeny)
+{ // Computing the point (x(Q-P),z(Q-P))
+  // Input:  coordinate xP of point P=(xP,yP)
+  // Output: the point D = (x(Q-P),z(Q-P)), where Q=tau(P).
+    felm_t one;
+
+    fpcopy751(CurveIsogeny->Montgomery_one, one);
+    fpsqr751_mont(xP, D->X[0]);	                     // XD = xP^2
+    fpadd751(D->X[0], one, D->X[0]);                 // XD = XD+1
+    fpcopy751(D->X[0], D->X[1]);                     // XD = XD*i
+    fpzero751(D->X[0]);          
+    fpadd751(xP, xP, D->Z[0]);                       // ZD = xP+xP
+}
+
+
+void get_A(f2elm_t xP, f2elm_t xQ, f2elm_t xR, f2elm_t A, PCurveIsogenyStruct CurveIsogeny)
+{ // Given the x-coordinates of P, Q, and R, returns the value A corresponding to the Montgomery curve E_A: y^2=x^3+A*x^2+x such that R=Q-P on E_A.
+  // Input:  the x-coordinates xP, xQ, and xR of the points P, Q and R.
+  // Output: the coefficient A corresponding to the curve E_A: y^2=x^3+A*x^2+x.
+    f2elm_t t0, t1, one = {0};
+    
+    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);
+    fp2add751(xP, xQ, t1);                           // t1 = xP+xQ
+    fp2mul751_mont(xP, xQ, t0);                      // t0 = xP*xQ
+    fp2mul751_mont(xR, t1, A);                       // A = xR*t1
+    fp2add751(t0, A, A);                             // A = A+t0
+    fp2mul751_mont(t0, xR, t0);                      // t0 = t0*xR
+    fp2sub751(A, one, A);                            // A = A-1
+    fp2add751(t0, t0, t0);                           // t0 = t0+t0
+    fp2add751(t1, xR, t1);                           // t1 = t1+xR
+    fp2add751(t0, t0, t0);                           // t0 = t0+t0
+    fp2sqr751_mont(A, A);                            // A = A^2
+    fp2inv751_mont(t0);                              // t0 = 1/t0
+    fp2mul751_mont(A, t0, A);                        // A = A*t0
+    fp2sub751(A, t1, A);                             // Afinal = A-t1
+}
\ No newline at end of file
diff --git a/crypto/sidh/sidhlib/fpx.c b/crypto/sidh/sidhlib/fpx.c
new file mode 100644
index 0000000..501e048
--- /dev/null
+++ b/crypto/sidh/sidhlib/fpx.c
@@ -0,0 +1,485 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: core functions over GF(p751^2) and field operations over the prime p751
+*
+*********************************************************************************************/ 
+
+#include "SIDH_internal.h"
+    
+
+// Global constants          
+const uint64_t p751[NWORDS_FIELD]          = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xEEAFFFFFFFFFFFFF,
+                                               0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x00006FE5D541F71C };
+const uint64_t p751p1[NWORDS_FIELD]        = { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0xEEB0000000000000,
+                                               0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x00006FE5D541F71C };
+const uint64_t p751x2[NWORDS_FIELD]        = { 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xDD5FFFFFFFFFFFFF, 
+                                               0xC7D92D0A93F0F151, 0xB52B363427EF98ED, 0x109D30CFADD7D0ED, 0x0AC56A08B964AE90, 0x1C25213F2F75B8CD, 0x0000DFCBAA83EE38 };
+const uint64_t Montgomery_R2[NWORDS_FIELD] = { 0x233046449DAD4058, 0xDB010161A696452A, 0x5E36941472E3FD8E, 0xF40BFE2082A2E706, 0x4932CCA8904F8751 ,0x1F735F1F1EE7FC81, 
+                                               0xA24F4D80C1048E18, 0xB56C383CCDB607C5, 0x441DD47B735F9C90, 0x5673ED2C6A6AC82A, 0x06C905261132294B, 0x000041AD830F1F35 }; 
+
+
+/*******************************************************/
+/************* Field arithmetic functions **************/
+
+__inline void fpcopy751(felm_t a, felm_t c)
+{ // Copy of a field element, c = a
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++)
+        c[i] = a[i];
+}
+
+
+__inline void fpzero751(felm_t a)
+{ // Zeroing a field element, a = 0
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++)
+        a[i] = 0;
+}
+
+
+void to_mont(felm_t a, felm_t mc)
+{ // Conversion to Montgomery representation
+  // mc = a*R^2*R^-1 mod p751 = a*R mod p751, where a in [0, p751-1]
+  // The Montgomery constant R^2 mod p751 is the global value "Montgomery_R2". 
+
+    fpmul751_mont(a, (digit_t*)&Montgomery_R2, mc);
+}
+
+
+void from_mont(felm_t ma, felm_t c)
+{ // Conversion from Montgomery representation to standard representation
+  // c = ma*R^-1 mod p751 = a mod p751, where ma in [0, p751-1].
+    digit_t one[NWORDS_FIELD] = {0};
+    
+    one[0] = 1;
+    fpmul751_mont(ma, one, c);
+    fpcorrection751(c);
+}
+
+
+static __inline unsigned int is_felm_zero(felm_t x)
+{ // Is x = 0? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise
+  // NOTE: this function does not run in constant-time so it can only be used in functions
+  //       incorporating countermeasures such as projective randomization.
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        if (x[i] != 0) return false;
+    }
+    return true;
+}
+
+
+static __inline unsigned int is_felm_even(felm_t x)
+{ // Is x even? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise
+    return (unsigned int)((x[0] & 1) ^ 1);
+}
+
+
+static __inline unsigned int is_felm_lt(felm_t x, felm_t y)
+{ // Is x < y? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise
+  // NOTE: this function does not run in constant-time so it can only be used in functions
+  //       incorporating countermeasures such as projective randomization.
+    int i;
+
+    for (i = NWORDS_FIELD-1; i >= 0; i--) {
+        if (x[i] < y[i]) { 
+            return true;
+        } else if (x[i] > y[i]) {
+            return false;
+        }
+    }
+    return false;
+}
+
+
+void copy_words(digit_t* a, digit_t* c, unsigned int nwords)
+{ // Copy wordsize digits, c = a, where lng(a) = nwords
+    unsigned int i;
+        
+    for (i = 0; i < nwords; i++) {                      
+        c[i] = a[i];
+    }
+}
+
+
+__inline unsigned int mp_sub(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)
+{ // Multiprecision subtraction, c = a-b, where lng(a) = lng(b) = nwords. Returns the borrow bit 
+    unsigned int i, borrow = 0;
+
+    for (i = 0; i < nwords; i++) {
+        SUBC(borrow, a[i], b[i], borrow, c[i]);
+    }
+
+    return borrow;
+}
+
+
+__inline unsigned int mp_add(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)
+{ // Multiprecision addition, c = a+b, where lng(a) = lng(b) = nwords. Returns the carry bit 
+    unsigned int i, carry = 0;
+        
+    for (i = 0; i < nwords; i++) {                      
+        ADDC(carry, a[i], b[i], carry, c[i]);
+    }
+
+    return carry;
+}
+
+
+void mp_shiftr1(digit_t* x, unsigned int nwords)
+{ // Multiprecision right shift by one
+    unsigned int i;
+
+    for (i = 0; i < nwords-1; i++) {
+        SHIFTR(x[i+1], x[i], 1, x[i], RADIX);
+    }
+    x[nwords-1] >>= 1;
+}
+
+
+void mp_shiftl1(digit_t* x, unsigned int nwords)
+{ // Multiprecision left right shift by one
+    int i;
+
+    for (i = nwords-1; i > 0; i--) {
+        SHIFTL(x[i], x[i-1], 1, x[i], RADIX);
+    }
+    x[0] <<= 1;
+}
+
+
+void fpmul751_mont(felm_t ma, felm_t mb, felm_t mc)
+{ // 751-bit Comba multi-precision multiplication, c = a*b mod p751
+    dfelm_t temp = {0};
+
+    mp_mul(ma, mb, temp, NWORDS_FIELD);
+    rdc_mont(temp, mc);
+}
+
+
+void fpsqr751_mont(felm_t ma, felm_t mc)
+{ // 751-bit Comba multi-precision squaring, c = a^2 mod p751
+    dfelm_t temp = {0};
+
+    mp_mul(ma, ma, temp, NWORDS_FIELD);
+    rdc_mont(temp, mc);
+}
+
+
+void fpinv751_mont(felm_t a)
+{ // Field inversion using Montgomery arithmetic, a = a^-1*R mod p751
+    felm_t t[27], tt;
+    unsigned int i, j;
+    
+    // Precomputed table
+    fpsqr751_mont(a, tt);
+    fpmul751_mont(a, tt, t[0]);
+    fpmul751_mont(t[0], tt, t[1]);
+    fpmul751_mont(t[1], tt, t[2]);
+    fpmul751_mont(t[2], tt, t[3]); 
+    fpmul751_mont(t[3], tt, t[3]);
+    for (i = 3; i <= 8; i++) fpmul751_mont(t[i], tt, t[i+1]);
+    fpmul751_mont(t[9], tt, t[9]);
+    for (i = 9; i <= 20; i++) fpmul751_mont(t[i], tt, t[i+1]);
+    fpmul751_mont(t[21], tt, t[21]); 
+    for (i = 21; i <= 24; i++) fpmul751_mont(t[i], tt, t[i+1]); 
+    fpmul751_mont(t[25], tt, t[25]);
+    fpmul751_mont(t[25], tt, t[26]);
+
+    fpcopy751(a, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[20], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[24], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[11], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[8], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[2], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[23], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[2], tt, tt);
+    for (i = 0; i < 9; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[2], tt, tt);
+    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[15], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[13], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[26], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[20], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[11], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[10], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[14], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[4], tt, tt);
+    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[18], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[1], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[22], tt, tt);
+    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[6], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[24], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[9], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[18], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[17], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(a, tt, tt);
+    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[16], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[7], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[0], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[12], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[19], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[22], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[25], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[2], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[10], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[22], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[18], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[4], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[14], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[13], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[5], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[23], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[21], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[2], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[23], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[12], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[9], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[3], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[13], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[17], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[26], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[5], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[8], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[11], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[22], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    for (j = 0; j < 61; j++) {
+        fpmul751_mont(t[26], tt, tt);
+        for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    }
+    fpmul751_mont(t[25], tt, a);  
+}
+
+
+/***********************************************/
+/************* GF(p^2) FUNCTIONS ***************/
+
+void fp2copy751(f2elm_t a, f2elm_t c)
+{ // Copy of a GF(p751^2) element, c = a
+    fpcopy751(a[0], c[0]);
+    fpcopy751(a[1], c[1]);
+}
+
+
+void fp2zero751(f2elm_t a)
+{ // Zeroing a GF(p751^2) element, a = 0
+    fpzero751(a[0]);
+    fpzero751(a[1]);
+}
+
+
+void fp2neg751(f2elm_t a)
+{ // GF(p751^2) negation, a = -a in GF(p751^2)
+    fpneg751(a[0]);
+    fpneg751(a[1]);
+}
+
+
+__inline void fp2add751(f2elm_t a, f2elm_t b, f2elm_t c)           
+{ // GF(p751^2) addition, c = a+b in GF(p751^2)
+    fpadd751(a[0], b[0], c[0]);
+    fpadd751(a[1], b[1], c[1]);
+}
+
+
+__inline void fp2sub751(f2elm_t a, f2elm_t b, f2elm_t c)          
+{ // GF(p751^2) subtraction, c = a-b in GF(p751^2) 
+    fpsub751(a[0], b[0], c[0]);
+    fpsub751(a[1], b[1], c[1]);
+}
+
+
+void fp2div2_751(f2elm_t a, f2elm_t c)          
+{ // GF(p751^2) division by two, c = a/2  in GF(p751^2) 
+    fpdiv2_751(a[0], c[0]);
+    fpdiv2_751(a[1], c[1]);
+}
+
+
+void fp2correction751(f2elm_t a)
+{ // Modular correction, a = a in GF(p751^2)
+    fpcorrection751(a[0]);
+    fpcorrection751(a[1]);
+}
+
+
+void fp2sqr751_mont(f2elm_t a, f2elm_t c)
+{ // GF(p751^2) squaring using Montgomery arithmetic, c = a^2 in GF(p751^2)
+    felm_t t1, t2, t3;
+    
+    mp_add(a[0], a[1], t1, NWORDS_FIELD);    // t1 = a0+a1 
+    fpsub751(a[0], a[1], t2);                // t2 = a0-a1
+    mp_add(a[0], a[0], t3, NWORDS_FIELD);    // t3 = 2a0
+    fpmul751_mont(t1, t2, c[0]);             // c0 = (a0+a1)(a0-a1)
+    fpmul751_mont(t3, a[1], c[1]);           // c1 = 2a0*a1
+}
+
+
+void fp2mul751_mont(f2elm_t a, f2elm_t b, f2elm_t c)
+{ // GF(p751^2) multiplication using Montgomery arithmetic, c = a*b in GF(p751^2)
+    felm_t t1, t2;
+    dfelm_t tt1, tt2, tt3; 
+    digit_t mask;
+    unsigned int i, borrow;
+    
+    mp_mul(a[0], b[0], tt1, NWORDS_FIELD);           // tt1 = a0*b0
+    mp_mul(a[1], b[1], tt2, NWORDS_FIELD);           // tt2 = a1*b1
+    mp_add(a[0], a[1], t1, NWORDS_FIELD);            // t1 = a0+a1
+    mp_add(b[0], b[1], t2, NWORDS_FIELD);            // t2 = b0+b1
+    borrow = mp_sub(tt1, tt2, tt3, 2*NWORDS_FIELD);  // tt3 = a0*b0 - a1*b1
+    mask = 0 - (digit_t)borrow;                      // if tt3 < 0 then mask = 0xFF..F, else if tt3 >= 0 then mask = 0x00..0
+    borrow = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(borrow, tt3[NWORDS_FIELD+i],  ((digit_t*)p751)[i]  & mask, borrow, tt3[NWORDS_FIELD+i]);
+    }
+    rdc_mont(tt3, c[0]);                             // c[0] = a0*b0 - a1*b1
+    mp_add(tt1, tt2, tt1, 2*NWORDS_FIELD);           // tt1 = a0*b0 + a1*b1
+    mp_mul(t1, t2, tt2, NWORDS_FIELD);               // tt2 = (a0+a1)*(b0+b1)
+    mp_sub(tt2, tt1, tt2, 2*NWORDS_FIELD);           // tt2 = (a0+a1)*(b0+b1) - a0*b0 - a1*b1 
+    rdc_mont(tt2, c[1]);                             // c[1] = (a0+a1)*(b0+b1) - a0*b0 - a1*b1 
+}
+
+
+void to_fp2mont(f2elm_t a, f2elm_t mc)
+{ // Conversion of a GF(p751^2) element to Montgomery representation
+  // mc_i = a_i*R^2*R^-1 = a_i*R in GF(p751^2). 
+
+    to_mont(a[0], mc[0]);
+    to_mont(a[1], mc[1]);
+}
+
+
+void from_fp2mont(f2elm_t ma, f2elm_t c)
+{ // Conversion of a GF(p751^2) element from Montgomery representation to standard representation
+  // c_i = ma_i*R^-1 = a_i in GF(p751^2).
+
+    from_mont(ma[0], c[0]);
+    from_mont(ma[1], c[1]);
+}
+
+
+void fp2inv751_mont(f2elm_t a)
+{// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2)
+    f2elm_t t1;
+
+    fpsqr751_mont(a[0], t1[0]);             // t10 = a0^2
+    fpsqr751_mont(a[1], t1[1]);             // t11 = a1^2
+    fpadd751(t1[0], t1[1], t1[0]);          // t10 = a0^2+a1^2
+    fpinv751_mont(t1[0]);                   // t10 = (a0^2+a1^2)^-1
+    fpneg751(a[1]);                         // a = a0-i*a1
+    fpmul751_mont(a[0], t1[0], a[0]);
+    fpmul751_mont(a[1], t1[0], a[1]);       // a = (a0-i*a1)*(a0^2+a1^2)^-1
+}
+
+
+void swap_points_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, digit_t option)
+{ // Swap points over the base field 
+  // If option = 0 then P <- P and Q <- Q, else if option = 0xFF...FF then P <- Q and Q <- P
+    digit_t temp;
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        temp = option & (P->X[i] ^ Q->X[i]);
+        P->X[i] = temp ^ P->X[i]; 
+        Q->X[i] = temp ^ Q->X[i]; 
+        temp = option & (P->Z[i] ^ Q->Z[i]);
+        P->Z[i] = temp ^ P->Z[i]; 
+        Q->Z[i] = temp ^ Q->Z[i]; 
+    }
+}
+
+
+void swap_points(point_proj_t P, point_proj_t Q, digit_t option)
+{ // Swap points
+  // If option = 0 then P <- P and Q <- Q, else if option = 0xFF...FF then P <- Q and Q <- P
+    digit_t temp;
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        temp = option & (P->X[0][i] ^ Q->X[0][i]);
+        P->X[0][i] = temp ^ P->X[0][i]; 
+        Q->X[0][i] = temp ^ Q->X[0][i]; 
+        temp = option & (P->Z[0][i] ^ Q->Z[0][i]);
+        P->Z[0][i] = temp ^ P->Z[0][i]; 
+        Q->Z[0][i] = temp ^ Q->Z[0][i]; 
+        temp = option & (P->X[1][i] ^ Q->X[1][i]);
+        P->X[1][i] = temp ^ P->X[1][i]; 
+        Q->X[1][i] = temp ^ Q->X[1][i]; 
+        temp = option & (P->Z[1][i] ^ Q->Z[1][i]);
+        P->Z[1][i] = temp ^ P->Z[1][i]; 
+        Q->Z[1][i] = temp ^ Q->Z[1][i]; 
+    }
+}
+
+
+void select_f2elm(f2elm_t x, f2elm_t y, f2elm_t z, digit_t option)
+{ // Select either x or y depending on value of option 
+  // If option = 0 then z <- x, else if option = 0xFF...FF then z <- y
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        z[0][i] = (option & (x[0][i] ^ y[0][i])) ^ x[0][i]; 
+        z[1][i] = (option & (x[1][i] ^ y[1][i])) ^ x[1][i]; 
+    }
+}
diff --git a/crypto/sidh/sidhlib/generic/fp_generic.c b/crypto/sidh/sidhlib/generic/fp_generic.c
new file mode 100644
index 0000000..8efec3d
--- /dev/null
+++ b/crypto/sidh/sidhlib/generic/fp_generic.c
@@ -0,0 +1,251 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: portable modular arithmetic
+*
+*********************************************************************************************/
+
+#include "../SIDH_internal.h"
+
+
+// Global constants
+extern const uint64_t p751[NWORDS_FIELD];
+extern const uint64_t p751p1[NWORDS_FIELD]; 
+extern const uint64_t p751x2[NWORDS_FIELD]; 
+
+
+__inline void fpadd751(digit_t* a, digit_t* b, digit_t* c)
+{ // Modular addition, c = a+b mod p751.
+  // Inputs: a, b in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    unsigned int i, carry = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, a[i], b[i], carry, c[i]); 
+    }
+
+    carry = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(carry, c[i], ((digit_t*)p751x2)[i], carry, c[i]); 
+    }
+    mask = 0 - (digit_t)carry;
+
+    carry = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, c[i], ((digit_t*)p751x2)[i] & mask, carry, c[i]); 
+    }
+} 
+
+
+__inline void fpsub751(digit_t* a, digit_t* b, digit_t* c)
+{ // Modular subtraction, c = a-b mod p751.
+  // Inputs: a, b in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    unsigned int i, borrow = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, a[i], b[i], borrow, c[i]); 
+    }
+    mask = 0 - (digit_t)borrow;
+
+    borrow = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(borrow, c[i], ((digit_t*)p751x2)[i] & mask, borrow, c[i]); 
+    }
+}
+
+
+__inline void fpneg751(digit_t* a)
+{ // Modular negation, a = -a mod p751.
+  // Input/output: a in [0, 2*p751-1] 
+    unsigned int i, borrow = 0;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, ((digit_t*)p751x2)[i], a[i], borrow, a[i]); 
+    }
+}
+
+
+void fpdiv2_751(digit_t* a, digit_t* c)
+{ // Modular division by two, c = a/2 mod p751.
+  // Input : a in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    unsigned int i, carry = 0;
+    digit_t mask;
+        
+    mask = 0 - (digit_t)(a[0] & 1);    // If a is odd compute a+p521
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, a[i], ((digit_t*)p751)[i] & mask, carry, c[i]); 
+    }
+
+    mp_shiftr1(c, NWORDS_FIELD);
+} 
+
+
+void fpcorrection751(digit_t* a)
+{ // Modular correction to reduce field element a in [0, 2*p751-1] to [0, p751-1].
+    unsigned int i, borrow = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, a[i], ((digit_t*)p751)[i], borrow, a[i]); 
+    }
+    mask = 0 - (digit_t)borrow;
+
+    borrow = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(borrow, a[i], ((digit_t*)p751)[i] & mask, borrow, a[i]); 
+    }
+}
+
+
+void digit_x_digit(digit_t a, digit_t b, digit_t* c)
+{ // Digit multiplication, digit * digit -> 2-digit result    
+    register digit_t al, ah, bl, bh, temp;
+    digit_t albl, albh, ahbl, ahbh, res1, res2, res3, carry;
+    digit_t mask_low = (digit_t)(-1) >> (sizeof(digit_t)*4), mask_high = (digit_t)(-1) << (sizeof(digit_t)*4);
+
+    al = a & mask_low;                        // Low part
+    ah = a >> (sizeof(digit_t) * 4);          // High part
+    bl = b & mask_low;
+    bh = b >> (sizeof(digit_t) * 4);
+
+    albl = al*bl;
+    albh = al*bh;
+    ahbl = ah*bl;
+    ahbh = ah*bh;
+    c[0] = albl & mask_low;                   // C00
+
+    res1 = albl >> (sizeof(digit_t) * 4);
+    res2 = ahbl & mask_low;
+    res3 = albh & mask_low;  
+    temp = res1 + res2 + res3;
+    carry = temp >> (sizeof(digit_t) * 4);
+    c[0] ^= temp << (sizeof(digit_t) * 4);    // C01   
+
+    res1 = ahbl >> (sizeof(digit_t) * 4);
+    res2 = albh >> (sizeof(digit_t) * 4);
+    res3 = ahbh & mask_low;
+    temp = res1 + res2 + res3 + carry;
+    c[1] = temp & mask_low;                   // C10 
+    carry = temp & mask_high; 
+    c[1] ^= (ahbh & mask_high) + carry;       // C11
+}
+
+ 
+void mp_mul_schoolbook(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)
+{ // Multiprecision schoolbook multiply, c = a*b, where lng(a) = lng(b) = nwords.   
+    unsigned int i, j;
+    digit_t u, v, UV[2];
+    unsigned int carry = 0;
+
+     for (i = 0; i < (2*nwords); i++) c[i] = 0;
+
+     for (i = 0; i < nwords; i++) {
+          u = 0;
+          for (j = 0; j < nwords; j++) {
+               MUL(a[i], b[j], UV+1, UV[0]); 
+               ADDC(0, UV[0], u, carry, v); 
+               u = UV[1] + carry;
+               ADDC(0, c[i+j], v, carry, v); 
+               u = u + carry;
+               c[i+j] = v;
+          }
+          c[nwords+i] = u;
+     }
+}
+
+
+void mp_mul_comba(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)
+{ // Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.   
+    unsigned int i, j;
+    digit_t t = 0, u = 0, v = 0, UV[2];
+    unsigned int carry = 0;
+    
+    for (i = 0; i < nwords; i++) {
+        for (j = 0; j <= i; j++) {
+            MUL(a[j], b[i-j], UV+1, UV[0]); 
+            ADDC(0, UV[0], v, carry, v); 
+            ADDC(carry, UV[1], u, carry, u); 
+            t += carry;
+        }
+        c[i] = v;
+        v = u; 
+        u = t;
+        t = 0;
+    }
+
+    for (i = nwords; i < 2*nwords-1; i++) {
+        for (j = i-nwords+1; j < nwords; j++) {
+            MUL(a[j], b[i-j], UV+1, UV[0]); 
+            ADDC(0, UV[0], v, carry, v); 
+            ADDC(carry, UV[1], u, carry, u); 
+            t += carry;
+        }
+        c[i] = v;
+        v = u; 
+        u = t;
+        t = 0;
+    }
+    c[2*nwords-1] = v; 
+}
+
+
+void rdc_mont(dfelm_t ma, felm_t mc)
+{ // Optimized Montgomery reduction using comba and exploiting the special form of the prime p751.
+  // mc = ma*mb*R^-1 mod p751, where ma,mb,mc in [0, p751-1] and R = 2^768.
+  // ma and mb are assumed to be in Montgomery representation.
+    unsigned int i, j, carry, count = p751_ZERO_WORDS;
+    digit_t UV[2], t = 0, u = 0, v = 0;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        mc[i] = 0;
+    }
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        for (j = 0; j < i; j++) {
+            if (j < (i-p751_ZERO_WORDS+1)) { 
+                MUL(mc[j], ((digit_t*)p751p1)[i-j], UV+1, UV[0]);
+                ADDC(0, UV[0], v, carry, v); 
+                ADDC(carry, UV[1], u, carry, u); 
+                t += carry; 
+            }
+        }
+        ADDC(0, v, ma[i], carry, v); 
+        ADDC(carry, u, 0, carry, u); 
+        t += carry; 
+        mc[i] = v;
+        v = u;
+        u = t;
+        t = 0;
+    }    
+
+    for (i = NWORDS_FIELD; i < 2*NWORDS_FIELD-1; i++) {
+        if (count > 0) {
+            count -= 1;
+        }
+        for (j = i-NWORDS_FIELD+1; j < NWORDS_FIELD; j++) {
+            if (j < (NWORDS_FIELD-count)) { 
+                MUL(mc[j], ((digit_t*)p751p1)[i-j], UV+1, UV[0]);
+                ADDC(0, UV[0], v, carry, v); 
+                ADDC(carry, UV[1], u, carry, u); 
+                t += carry;
+            }
+        }
+        ADDC(0, v, ma[i], carry, v); 
+        ADDC(carry, u, 0, carry, u); 
+        t += carry; 
+        mc[i-NWORDS_FIELD] = v;
+        v = u;
+        u = t;
+        t = 0;
+    }
+    ADDC(0, v, ma[2*NWORDS_FIELD-1], carry, v); 
+    mc[NWORDS_FIELD-1] = v;
+}
\ No newline at end of file
diff --git a/crypto/sidh/sidhlib/kex.c b/crypto/sidh/sidhlib/kex.c
new file mode 100644
index 0000000..6188c66
--- /dev/null
+++ b/crypto/sidh/sidhlib/kex.c
@@ -0,0 +1,387 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: isogeny-based key exchange
+*
+*********************************************************************************************/ 
+
+#include "SIDH_internal.h"
+
+extern const unsigned int splits_Alice[MAX_Alice];
+extern const unsigned int splits_Bob[MAX_Bob];
+
+
+CRYPTO_STATUS KeyGeneration_A(unsigned char* pPrivateKeyA, unsigned char* pPublicKeyA, PCurveIsogenyStruct CurveIsogeny)
+{ // Alice's key-pair generation
+  // It produces a private key pPrivateKeyA and computes the public key pPublicKeyA.
+  // The private key is an even integer in the range [2, oA-2], where oA = 2^372 (i.e., 372 bits in total). 
+  // The public key consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int owords = NBITS_TO_NWORDS(CurveIsogeny->owordbits), pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);
+    point_basefield_t P;
+    point_proj_t R, phiP = {0}, phiQ = {0}, phiD = {0}, pts[MAX_INT_POINTS_ALICE];
+    publickey_t* PublicKeyA = (publickey_t*)pPublicKeyA;
+    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_ALICE], npts = 0; 
+    f2elm_t coeff[5], A = {0}, C = {0}, Aout, Cout;
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN; 
+
+    if (pPrivateKeyA == NULL || pPublicKeyA == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }  
+
+    // Choose a random even number in the range [2, oA-2] as secret key for Alice
+    Status = random_mod_order((digit_t*)pPrivateKeyA, ALICE, CurveIsogeny);    
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)pPrivateKeyA, owords);
+        return Status;
+    }
+
+    to_mont((digit_t*)CurveIsogeny->PA, (digit_t*)P);                               // Conversion of Alice's generators to Montgomery representation
+    to_mont(((digit_t*)CurveIsogeny->PA)+NWORDS_FIELD, ((digit_t*)P)+NWORDS_FIELD); 
+
+    Status = secret_pt(P, (digit_t*)pPrivateKeyA, ALICE, R, CurveIsogeny);
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)pPrivateKeyA, owords);
+        return Status;
+    }
+
+    copy_words((digit_t*)CurveIsogeny->PB, (digit_t*)phiP, pwords);                 // Copy X-coordinates from Bob's public parameters, set Z <- 1
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiP->Z);  
+    to_mont((digit_t*)phiP, (digit_t*)phiP);                                        
+    copy_words((digit_t*)phiP, (digit_t*)phiQ, pwords);                             // QB = (-XPB:1)
+    fpneg751(phiQ->X[0]);   
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiQ->Z); 
+    distort_and_diff(phiP->X[0], phiD, CurveIsogeny);                               // DB = (x(QB-PB),z(QB-PB))
+
+    fpcopy751(CurveIsogeny->A, A[0]);                                               // Extracting curve parameters A and C
+    fpcopy751(CurveIsogeny->C, C[0]);
+    to_mont(A[0], A[0]);
+    to_mont(C[0], C[0]);
+
+    first_4_isog(phiP, A, Aout, Cout, CurveIsogeny);     
+    first_4_isog(phiQ, A, Aout, Cout, CurveIsogeny);
+    first_4_isog(phiD, A, Aout, Cout, CurveIsogeny);
+    first_4_isog(R, A, A, C, CurveIsogeny);
+    
+    index = 0;        
+    for (row = 1; row < MAX_Alice; row++) {
+        while (index < MAX_Alice-row) {
+            fp2copy751(R->X, pts[npts]->X);
+            fp2copy751(R->Z, pts[npts]->Z);
+            pts_index[npts] = index;
+            npts += 1;
+            m = splits_Alice[MAX_Alice-index-row];
+            xDBLe(R, R, A, C, (int)(2*m));
+            index += m;
+        }
+        get_4_isog(R, A, C, coeff);        
+
+        for (i = 0; i < npts; i++) {
+            eval_4_isog(pts[i], coeff);
+        }
+        eval_4_isog(phiP, coeff);
+        eval_4_isog(phiQ, coeff);
+        eval_4_isog(phiD, coeff);
+
+        fp2copy751(pts[npts-1]->X, R->X); 
+        fp2copy751(pts[npts-1]->Z, R->Z);
+        index = pts_index[npts-1];
+        npts -= 1;
+    }
+
+    get_4_isog(R, A, C, coeff); 
+    eval_4_isog(phiP, coeff);
+    eval_4_isog(phiQ, coeff);
+    eval_4_isog(phiD, coeff);
+
+    inv_3_way(phiP->Z, phiQ->Z, phiD->Z);
+    fp2mul751_mont(phiP->X, phiP->Z, phiP->X);
+    fp2mul751_mont(phiQ->X, phiQ->Z, phiQ->X);
+    fp2mul751_mont(phiD->X, phiD->Z, phiD->X);
+                                   
+    from_fp2mont(phiP->X, ((f2elm_t*)PublicKeyA)[0]);                               // Converting back to standard representation
+    from_fp2mont(phiQ->X, ((f2elm_t*)PublicKeyA)[1]);
+    from_fp2mont(phiD->X, ((f2elm_t*)PublicKeyA)[2]);
+
+// Cleanup:
+    clear_words((void*)R, 2*2*pwords);
+    clear_words((void*)phiP, 2*2*pwords);
+    clear_words((void*)phiQ, 2*2*pwords);
+    clear_words((void*)phiD, 2*2*pwords);
+    clear_words((void*)pts, MAX_INT_POINTS_ALICE*2*2*pwords);
+    clear_words((void*)A, 2*pwords);
+    clear_words((void*)C, 2*pwords);
+    clear_words((void*)coeff, 5*2*pwords);
+      
+    return Status;
+}
+
+
+CRYPTO_STATUS KeyGeneration_B(unsigned char* pPrivateKeyB, unsigned char* pPublicKeyB, PCurveIsogenyStruct CurveIsogeny)
+{ // Bob's key-pair generation
+  // It produces a private key pPrivateKeyB and computes the public key pPublicKeyB.
+  // The private key is an integer in the range [1, oB-1], where oA = 3^239 (i.e., 379 bits in total). 
+  // The public key consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int owords = NBITS_TO_NWORDS(CurveIsogeny->owordbits), pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);
+    point_basefield_t P;
+    point_proj_t R, phiP = {0}, phiQ = {0}, phiD = {0}, pts[MAX_INT_POINTS_BOB];
+    publickey_t* PublicKeyB = (publickey_t*)pPublicKeyB;
+    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_BOB], npts = 0; 
+    f2elm_t A = {0}, C = {0};
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;  
+
+    if (pPrivateKeyB == NULL || pPublicKeyB == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }  
+
+    // Choose a random number equivalent to 0 (mod 3) in the range [3, oB-3] as secret key for Bob
+    Status = random_mod_order((digit_t*)pPrivateKeyB, BOB, CurveIsogeny);
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)pPrivateKeyB, owords);
+        return Status;
+    }
+
+    to_mont((digit_t*)CurveIsogeny->PB, (digit_t*)P);                               // Conversion of Bob's generators to Montgomery representation
+    to_mont(((digit_t*)CurveIsogeny->PB)+NWORDS_FIELD, ((digit_t*)P)+NWORDS_FIELD); 
+
+    Status = secret_pt(P, (digit_t*)pPrivateKeyB, BOB, R, CurveIsogeny);
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)pPrivateKeyB, owords);
+        return Status;
+    }
+
+    copy_words((digit_t*)CurveIsogeny->PA, (digit_t*)phiP, pwords);                 // Copy X-coordinates from Alice's public parameters, set Z <- 1
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiP->Z);   
+    to_mont((digit_t*)phiP, (digit_t*)phiP);                                        // Conversion to Montgomery representation
+    copy_words((digit_t*)phiP, (digit_t*)phiQ, pwords);                             // QA = (-XPA:1)
+    fpneg751(phiQ->X[0]); 
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiQ->Z);  
+    distort_and_diff(phiP->X[0], phiD, CurveIsogeny);                               // DA = (x(QA-PA),z(QA-PA))
+
+    fpcopy751(CurveIsogeny->A, A[0]);                                               // Extracting curve parameters A and C
+    fpcopy751(CurveIsogeny->C, C[0]);
+    to_mont(A[0], A[0]);
+    to_mont(C[0], C[0]);
+    
+    index = 0;  
+    for (row = 1; row < MAX_Bob; row++) {
+        while (index < MAX_Bob-row) {
+            fp2copy751(R->X, pts[npts]->X);
+            fp2copy751(R->Z, pts[npts]->Z);
+            pts_index[npts] = index;
+            npts += 1;
+            m = splits_Bob[MAX_Bob-index-row];
+            xTPLe(R, R, A, C, (int)m);
+            index += m;
+        }
+        get_3_isog(R, A, C);        
+
+        for (i = 0; i < npts; i++) {
+            eval_3_isog(R, pts[i]);
+        }     
+        eval_3_isog(R, phiP);
+        eval_3_isog(R, phiQ);
+        eval_3_isog(R, phiD);
+
+        fp2copy751(pts[npts-1]->X, R->X); 
+        fp2copy751(pts[npts-1]->Z, R->Z);
+        index = pts_index[npts-1];
+        npts -= 1;
+    }
+    
+    get_3_isog(R, A, C);    
+    eval_3_isog(R, phiP);
+    eval_3_isog(R, phiQ);
+    eval_3_isog(R, phiD);
+
+    inv_3_way(phiP->Z, phiQ->Z, phiD->Z);
+    fp2mul751_mont(phiP->X, phiP->Z, phiP->X);
+    fp2mul751_mont(phiQ->X, phiQ->Z, phiQ->X);
+    fp2mul751_mont(phiD->X, phiD->Z, phiD->X);
+                                   
+    from_fp2mont(phiP->X, ((f2elm_t*)PublicKeyB)[0]);                               // Converting back to standard representation
+    from_fp2mont(phiQ->X, ((f2elm_t*)PublicKeyB)[1]);
+    from_fp2mont(phiD->X, ((f2elm_t*)PublicKeyB)[2]);
+
+// Cleanup:
+    clear_words((void*)R, 2*2*pwords);
+    clear_words((void*)phiP, 2*2*pwords);
+    clear_words((void*)phiQ, 2*2*pwords);
+    clear_words((void*)phiD, 2*2*pwords);
+    clear_words((void*)pts, MAX_INT_POINTS_BOB*2*2*pwords);
+    clear_words((void*)A, 2*pwords);
+    clear_words((void*)C, 2*pwords);
+      
+    return Status;
+}
+
+
+CRYPTO_STATUS SecretAgreement_A(unsigned char* pPrivateKeyA, unsigned char* pPublicKeyB, unsigned char* pSharedSecretA, bool validate, PCurveIsogenyStruct CurveIsogeny)
+{ // Alice's shared secret generation
+  // It produces a shared secret key pSharedSecretA using her secret key pPrivateKeyA and Bob's public key pPublicKeyB
+  // Inputs: Alice's pPrivateKeyA is an even integer in the range [2, oA-2], where oA = 2^372 (i.e., 372 bits in total). 
+  //         Bob's pPublicKeyB consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+  //         "validate" flag that indicates if Alice must validate Bob's public key. 
+  // Output: a shared secret pSharedSecretA that consists of one element in GF(p751^2), i.e., 1502 bits in total. 
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);
+    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_ALICE], npts = 0; 
+    point_proj_t R, pts[MAX_INT_POINTS_ALICE];
+    publickey_t* PublicKeyB = (publickey_t*)pPublicKeyB;
+    f2elm_t jinv, coeff[5], PKB[3], A, C = {0};
+    bool valid_PublicKey = false; 
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN; 
+
+    if (pPrivateKeyA == NULL || pPublicKeyB == NULL || pSharedSecretA == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+      
+    to_fp2mont(((f2elm_t*)PublicKeyB)[0], PKB[0]);    // Extracting and converting Bob's public curve parameters to Montgomery representation
+    to_fp2mont(((f2elm_t*)PublicKeyB)[1], PKB[1]);        
+    to_fp2mont(((f2elm_t*)PublicKeyB)[2], PKB[2]);
+
+    get_A(PKB[0], PKB[1], PKB[2], A, CurveIsogeny);
+    fpcopy751(CurveIsogeny->C, C[0]);
+    to_mont(C[0], C[0]);
+
+    if (validate == true) {                           // Alice validating Bob's public key
+        Status = Validate_PKB(A, &PKB[0], &valid_PublicKey, CurveIsogeny);                   
+        if (Status != CRYPTO_SUCCESS) {  
+            return Status;
+        }  
+        if (valid_PublicKey != true) {
+            Status = CRYPTO_ERROR_PUBLIC_KEY_VALIDATION; 
+            return Status;
+        }
+    }
+
+    Status = ladder_3_pt(PKB[0], PKB[1], PKB[2], (digit_t*)pPrivateKeyA, ALICE, R, A, CurveIsogeny);
+    if (Status != CRYPTO_SUCCESS) {
+        return Status;
+    }
+    first_4_isog(R, A, A, C, CurveIsogeny); 
+        
+    index = 0;  
+    for (row = 1; row < MAX_Alice; row++) {
+        while (index < MAX_Alice-row) {
+            fp2copy751(R->X, pts[npts]->X);
+            fp2copy751(R->Z, pts[npts]->Z);
+            pts_index[npts] = index;
+            npts += 1;
+            m = splits_Alice[MAX_Alice-index-row];
+            xDBLe(R, R, A, C, (int)(2*m));
+            index += m;
+        }
+        get_4_isog(R, A, C, coeff);        
+
+        for (i = 0; i < npts; i++) {
+            eval_4_isog(pts[i], coeff);
+        }
+
+        fp2copy751(pts[npts-1]->X, R->X); 
+        fp2copy751(pts[npts-1]->Z, R->Z);
+        index = pts_index[npts-1];
+        npts -= 1;
+    }
+    
+    get_4_isog(R, A, C, coeff); 
+    j_inv(A, C, jinv);
+    from_fp2mont(jinv, (felm_t*)pSharedSecretA);      // Converting back to standard representation
+
+// Cleanup:
+    clear_words((void*)R, 2*2*pwords);
+    clear_words((void*)pts, MAX_INT_POINTS_ALICE*2*2*pwords);
+    clear_words((void*)A, 2*pwords);
+    clear_words((void*)C, 2*pwords);
+    clear_words((void*)jinv, 2*pwords);
+    clear_words((void*)coeff, 5*2*pwords);
+      
+    return Status;
+}
+
+
+CRYPTO_STATUS SecretAgreement_B(unsigned char* pPrivateKeyB, unsigned char* pPublicKeyA, unsigned char* pSharedSecretB, bool validate, PCurveIsogenyStruct CurveIsogeny)
+{ // Bob's shared secret generation
+  // It produces a shared secret key pSharedSecretB using his secret key pPrivateKeyB and Alice's public key pPublicKeyA
+  // Inputs: Bob's pPrivateKeyB is an integer in the range [1, oB-1], where oA = 3^239 (i.e., 379 bits in total). 
+  //         Alice's pPublicKeyA consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+  //         "validate" flag that indicates if Bob must validate Alice's public key. 
+  // Output: a shared secret pSharedSecretB that consists of one element in GF(p751^2), i.e., 1502 bits in total. 
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);
+    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_BOB], npts = 0; 
+    point_proj_t R, pts[MAX_INT_POINTS_BOB];
+    publickey_t* PublicKeyA = (publickey_t*)pPublicKeyA;
+    f2elm_t jinv, A, PKA[3], C = {0};
+    bool valid_PublicKey = false; 
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;  
+
+    if (pPrivateKeyB == NULL || pPublicKeyA == NULL || pSharedSecretB == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+       
+    to_fp2mont(((f2elm_t*)PublicKeyA)[0], PKA[0]);    // Extracting and converting Alice's public curve parameters to Montgomery representation
+    to_fp2mont(((f2elm_t*)PublicKeyA)[1], PKA[1]);       
+    to_fp2mont(((f2elm_t*)PublicKeyA)[2], PKA[2]);
+    
+    get_A(PKA[0], PKA[1], PKA[2], A, CurveIsogeny);
+    fpcopy751(CurveIsogeny->C, C[0]);
+    to_mont(C[0], C[0]);
+
+    if (validate == true) {                           // Bob validating Alice's public key
+        Status = Validate_PKA(A, &PKA[0], &valid_PublicKey, CurveIsogeny);                   
+        if (Status != CRYPTO_SUCCESS) {  
+            return Status;
+        }  
+        if (valid_PublicKey != true) {
+            Status = CRYPTO_ERROR_PUBLIC_KEY_VALIDATION; 
+            return Status;
+        }
+    }
+
+    Status = ladder_3_pt(PKA[0], PKA[1], PKA[2], (digit_t*)pPrivateKeyB, BOB, R, A, CurveIsogeny);
+    if (Status != CRYPTO_SUCCESS) {
+        return Status;
+    }
+    
+    index = 0;  
+    for (row = 1; row < MAX_Bob; row++) {
+        while (index < MAX_Bob-row) {
+            fp2copy751(R->X, pts[npts]->X);
+            fp2copy751(R->Z, pts[npts]->Z);
+            pts_index[npts] = index;
+            npts += 1;
+            m = splits_Bob[MAX_Bob-index-row];
+            xTPLe(R, R, A, C, (int)m);
+            index += m;
+        }
+        get_3_isog(R, A, C);        
+
+        for (i = 0; i < npts; i++) {
+            eval_3_isog(R, pts[i]);
+        } 
+
+        fp2copy751(pts[npts-1]->X, R->X); 
+        fp2copy751(pts[npts-1]->Z, R->Z);
+        index = pts_index[npts-1];
+        npts -= 1;
+    }
+    
+    get_3_isog(R, A, C);    
+    j_inv(A, C, jinv);
+    from_fp2mont(jinv, (felm_t*)pSharedSecretB);      // Converting back to standard representation
+
+// Cleanup:
+    clear_words((void*)R, 2*2*pwords);
+    clear_words((void*)pts, MAX_INT_POINTS_BOB*2*2*pwords);
+    clear_words((void*)A, 2*pwords);
+    clear_words((void*)C, 2*pwords);
+    clear_words((void*)jinv, 2*pwords);
+      
+    return Status;
+}
diff --git a/crypto/sidh/sidhlib/makefile_kat_tests b/crypto/sidh/sidhlib/makefile_kat_tests
new file mode 100644
index 0000000..7491e06
--- /dev/null
+++ b/crypto/sidh/sidhlib/makefile_kat_tests
@@ -0,0 +1,109 @@
+####  Makefile for compilation on Linux  ####
+
+OPT=-O3     # Optimization option by default
+
+ifeq "$(CC)" "gcc"
+    COMPILER=gcc
+else ifeq "$(CC)" "clang"
+    COMPILER=clang
+endif
+
+ifeq "$(ARCH)" "x64"
+    ARCHITECTURE=_AMD64_
+else ifeq "$(ARCH)" "x86"
+    ARCHITECTURE=_X86_
+else ifeq "$(ARCH)" "ARM"
+    ARCHITECTURE=_ARM_
+endif
+
+ADDITIONAL_SETTINGS=
+ifeq "$(SET)" "EXTENDED"
+    ADDITIONAL_SETTINGS=-fwrapv -fomit-frame-pointer -march=native
+endif
+
+ifeq "$(ASM)" "TRUE"
+    USE_ASM=-D _ASM_
+endif
+
+ifeq "$(GENERIC)" "TRUE"
+    USE_GENERIC=-D _GENERIC_
+endif
+
+ifeq "$(ARCH)" "ARM"
+    ARM_SETTING=-lrt
+endif
+
+cc=$(COMPILER)
+CFLAGS=-c $(OPT) $(ADDITIONAL_SETTINGS) -D $(ARCHITECTURE) -D __LINUX__ $(USE_ASM) $(USE_GENERIC)
+LDFLAGS=
+ifeq "$(GENERIC)" "TRUE"
+    EXTRA_OBJECTS=fp_generic.o
+else
+ifeq "$(ARCH)" "x64"
+    EXTRA_OBJECTS=fp_x64.o fp_x64_asm.o
+endif
+endif
+OBJECTS=kex.o ec_isogeny.o validate.o SIDH.o SIDH_setup.o fpx.o $(EXTRA_OBJECTS)
+OBJECTS_TEST=test_extras.o
+OBJECTS_ARITH_TEST=arith_tests.o $(OBJECTS_TEST) $(OBJECTS)
+OBJECTS_KEX_TEST=kex_tests.o $(OBJECTS_TEST) $(OBJECTS)
+OBJECTS_KAT_TEST=kat_tests.o $(OBJECTS_TEST) $(OBJECTS)
+OBJECTS_ALL=$(OBJECTS) $(OBJECTS_ARITH_TEST) $(OBJECTS_KEX_TEST)
+
+kat_test: $(OBJECTS_KAT_TEST)
+	$(CC) -o kat_test $(OBJECTS_KAT_TEST) $(ARM_SETTING)
+
+arith_test: $(OBJECTS_ARITH_TEST)
+	$(CC) -o arith_test $(OBJECTS_ARITH_TEST) $(ARM_SETTING)
+
+kex_test: $(OBJECTS_KEX_TEST)
+	$(CC) -o kex_test $(OBJECTS_KEX_TEST) $(ARM_SETTING)
+
+kex.o: kex.c SIDH_internal.h
+	$(CC) $(CFLAGS) kex.c
+
+ec_isogeny.o: ec_isogeny.c SIDH_internal.h
+	$(CC) $(CFLAGS) ec_isogeny.c
+
+validate.o: validate.c SIDH_internal.h
+	$(CC) $(CFLAGS) validate.c
+
+SIDH.o: SIDH.c SIDH_internal.h
+	$(CC) $(CFLAGS) SIDH.c
+
+SIDH_setup.o: SIDH_setup.c SIDH_internal.h
+	$(CC) $(CFLAGS) SIDH_setup.c
+
+fpx.o: fpx.c SIDH_internal.h
+	$(CC) $(CFLAGS) fpx.c
+
+ifeq "$(GENERIC)" "TRUE"
+    fp_generic.o: generic/fp_generic.c
+	    $(CC) $(CFLAGS) generic/fp_generic.c
+else
+ifeq "$(ARCH)" "x64"
+    fp_x64.o: AMD64/fp_x64.c
+	    $(CC) $(CFLAGS) AMD64/fp_x64.c
+
+    fp_x64_asm.o: AMD64/fp_x64_asm.S
+	    $(CC) $(CFLAGS) AMD64/fp_x64_asm.S
+endif
+endif
+
+test_extras.o: tests/test_extras.c tests/test_extras.h
+	$(CC) $(CFLAGS) tests/test_extras.c
+
+arith_tests.o: tests/arith_tests.c SIDH_internal.h
+	$(CC) $(CFLAGS) tests/arith_tests.c
+
+kex_tests.o: tests/kex_tests.c SIDH.h
+	$(CC) $(CFLAGS) tests/kex_tests.c
+
+kat_tests.o: tests/kat_tests.c SIDH_internal.h
+	$(CC) $(CFLAGS) tests/kat_tests.c
+
+.PHONY: clean
+
+clean:
+	rm arith_test kex_test kat_test fp_generic.o fp_x64.o fp_x64_asm.o $(OBJECTS_ALL)
+
diff --git a/crypto/sidh/sidhlib/validate.c b/crypto/sidh/sidhlib/validate.c
new file mode 100644
index 0000000..cd3259e
--- /dev/null
+++ b/crypto/sidh/sidhlib/validate.c
@@ -0,0 +1,223 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: functions for validation of public keys
+*           
+* SECURITY NOTE: these functions run in variable time because it is assumed that they are
+*                used over public data.
+*
+*********************************************************************************************/ 
+
+#include <openssl/rand.h>
+#include "SIDH_internal.h"
+
+
+static bool is_equal_fp(felm_t a, felm_t b)
+{ // Return true if a = b in GF(p751). Otherwise, return false
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        if (a[i] != b[i]) {
+            return false; 
+        }
+    }
+
+    return true;
+}
+
+
+static bool is_equal_fp2(f2elm_t a, f2elm_t b)
+{ // Return true if a = b in GF(p751^2). Otherwise, return false
+
+    return (is_equal_fp(a[0], b[0]) && is_equal_fp(a[1], b[1]));
+}
+
+
+CRYPTO_STATUS random_fp2(f2elm_t f2value, PCurveIsogenyStruct pCurveIsogeny)
+{ // Output random value in GF(p751). It makes requests of random values to the "random_bytes" function. 
+  // If successful, the output is given in "f2value".
+    unsigned int ntry = 0, nbytes;    
+    felm_t t1, p751;
+    unsigned char mask;
+    clear_words((void*)f2value, 2*NWORDS_FIELD);    
+    fpcopy751(pCurveIsogeny->prime, p751);
+    nbytes = (pCurveIsogeny->pbits+7)/8;                       // Number of random bytes to be requested 
+    mask = (unsigned char)(8*nbytes - pCurveIsogeny->pbits);
+    mask = ((unsigned char)-1 >> mask);                        // Value for masking last random byte
+
+    do {
+        ntry++;
+        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, p751-1] 
+            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;
+        }
+	if (!RAND_bytes((unsigned char*)&f2value[0], nbytes)) {
+            return CRYPTO_ERROR;
+        }
+        ((unsigned char*)&f2value[0])[nbytes-1] &= mask;       // Masking last byte 
+    } while (mp_sub(p751, f2value[0], t1, NWORDS_FIELD) == 1);
+
+    ntry = 0;
+    do {
+        ntry++;
+        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, p751-1] 
+            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;
+        }
+	if (!RAND_bytes((unsigned char*)&f2value[1], nbytes)) {
+            return CRYPTO_ERROR;
+        }
+        ((unsigned char*)&f2value[1])[nbytes-1] &= mask;       // Masking last byte 
+    } while (mp_sub(p751, f2value[1], t1, NWORDS_FIELD) == 1);
+
+// Cleanup
+    clear_words((void*)t1, NWORDS_FIELD);
+
+    return CRYPTO_SUCCESS;
+}
+
+
+static bool test_curve(f2elm_t A, f2elm_t rvalue, PCurveIsogenyStruct CurveIsogeny) 
+{ // This function checks that the curve is in the correct supersingular isogeny class via Sutherland's Monte Carlo algorithm. 
+  // It also checks that the curve is not a subfield curve. Both Alice and Bob call this same function in their respective validation procedures below. 
+  // Inputs: the curve constant A, corresponding to E_A: y^2=x^3+A*x^2+x,
+  //         a random value "rvalue" in Fp2.
+  // Output: returns "true" if curve is valid, "false" otherwise.
+    f2elm_t t0, t1, one = {0}, zero = {0};
+    point_proj_t rP, P1;
+    bool valid_curve;
+    
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, one[0]);
+
+    // Test j invariant in Fp2\Fp
+    fp2sqr751_mont(A, t0);                             // t0 = a^2
+    fp2sub751(t0, one, t0);             
+    fp2sub751(t0, one, t0);             
+    fp2sub751(t0, one, t0);                            // t0 = t0-3
+    fp2sqr751_mont(t0, t1);                            // t1 = t0^2
+    fp2mul751_mont(t0, t1, t1);                        // t1 = t1*t0
+    fp2sub751(t0, one, t0);                            // t0 = t0-1
+    fpmul751_mont(t1[0], t0[1], t1[0]);
+    fpmul751_mont(t1[1], t0[0], t1[1]);  
+    fp2correction751(t1);  
+
+    valid_curve = !is_equal_fp(t1[0], t1[1]);
+        
+    // Test supersingular
+    fp2copy751(rvalue, rP->X);
+    fp2copy751(one, rP->Z);
+
+    xDBLe(rP, rP, A, one, 1);
+    xDBLe(rP, P1, A, one, 371);    
+    xTPLe(P1, P1, A, one, 239);    
+    fp2mul751_mont(rP->X, P1->Z, rP->X);               // X = X*Z1
+    fp2mul751_mont(rP->Z, P1->X, rP->Z);               // Z = Z*X1
+    fp2sub751(rP->X, rP->Z, rP->X);                    // X = X-Z
+    fp2mul751_mont(rP->X, P1->Z, rP->X);               // X = X*Z1 
+    fp2correction751(rP->X);  
+
+    return (valid_curve && is_equal_fp2(rP->X, zero));
+}
+
+
+CRYPTO_STATUS Validate_PKA(f2elm_t A, publickey_t PKA, bool* valid, PCurveIsogenyStruct CurveIsogeny)
+{ // Bob validating Alice's public key
+  // Inputs: Alice's public key [A,xP,xQ,xQP], where xP,xQ and xQP are contained in PKA,
+  //         the exponent eB (=239 for our curve) for Miller's algorithm.
+  // Output: valid = "true" if key is valid, "false" otherwise.
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int eB1 = CurveIsogeny->eB - 1;    // eB1 = eB-1
+    f2elm_t t0, t1, rvalue, one = {0}, zero = {0};
+    point_proj_t P = {0}, Q = {0}; 
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;
+    
+    // Choose a random element in GF(p751^2) for Sutherland's algorithm. Assume that it is in Montgomery representation 
+    Status = random_fp2(rvalue, CurveIsogeny);    
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)rvalue, 2*NWORDS_FIELD);
+        return Status;
+    }
+    
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, one[0]);
+    fp2copy751(PKA[0], P->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, P->Z[0]);
+    fp2copy751(PKA[1], Q->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, Q->Z[0]); 
+    
+    xTPLe(P, P, A, one, eB1);                      
+    xTPLe(Q, Q, A, one, eB1);    
+    fp2mul751_mont(P->X, Q->Z, t0);                         // t0 = XP*ZQ  
+    fp2mul751_mont(Q->X, P->Z, t1);                         // t1 = XQ*ZP   
+    fp2sub751(t0, t1, t0);                                  // t0 = t0-t1  
+    fp2mul751_mont(P->Z, t0, t0);                           // t0 = ZP*t0   
+    fp2mul751_mont(Q->Z, t0, t0);                           // t0 = ZQ*t0   
+    fp2correction751(t0);    
+    *valid = !is_equal_fp2(t0, zero);                       // Checks that ZP*ZQ*(XQ*ZP-XP*ZQ) != 0, i.e., that 3^(e-1)*P != 3^(e-1)*Q and neither P nor Q has order 3^(e-1)
+            
+    xTPLe(P, P, A, one, 1);                      
+    xTPLe(Q, Q, A, one, 1);   
+    fp2correction751(P->Z);   
+    fp2correction751(Q->Z);          
+    *valid = *valid & is_equal_fp2(P->Z, zero);             // Checks that 3^e*P = 0
+    *valid = *valid & is_equal_fp2(Q->Z, zero);             // Checks that 3^e*Q = 0
+    *valid = *valid & test_curve(A, rvalue, CurveIsogeny);  // Tests curve via Sutherland's algorithm
+
+    return CRYPTO_SUCCESS;
+}
+
+
+CRYPTO_STATUS Validate_PKB(f2elm_t A, publickey_t PKB, bool* valid, PCurveIsogenyStruct CurveIsogeny)
+{ // Alice validating Bob's public key
+  // Inputs: Bob's public key [A,xP,xQ,xQP], where xP,xQ and xQP are contained in PKB,
+  //         the exponent eA (=372 for our curve) for Miller's algorithm.
+  // Output: valid = "true" if key is valid, "false" otherwise.
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int oAbits2 = CurveIsogeny->oAbits - 2;    // oAbits2 = oAbits-2   
+    f2elm_t t0, t1, two, four, rvalue, one = {0}, zero = {0};
+    point_proj_t P = {0}, Q = {0}; 
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN; 
+
+    // Choose a random element in GF(p751^2) for Sutherland's algorithm. Assume that it is in Montgomery representation 
+    Status = random_fp2(rvalue, CurveIsogeny);    
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)rvalue, 2*NWORDS_FIELD);
+        return Status;
+    }
+    
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, one[0]);
+    fp2copy751(PKB[0], P->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, P->Z[0]);
+    fp2copy751(PKB[1], Q->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, Q->Z[0]);    
+
+    fp2add751(one, one, two); 
+    fp2add751(two, two, four);                              // four = 4    
+    xDBLe(P, P, A, one, oAbits2);                      
+    xDBLe(Q, Q, A, one, oAbits2);    
+    fp2mul751_mont(P->X, Q->Z, t0);                         // t0 = XP*ZQ  
+    fp2mul751_mont(Q->X, P->Z, t1);                         // t1 = XQ*ZP   
+    fp2sub751(t0, t1, t0);                                  // t0 = t0-t1  
+    fp2mul751_mont(P->Z, t0, t0);                           // t0 = ZP*t0   
+    fp2mul751_mont(Q->Z, t0, t0);                           // t0 = ZQ*t0  
+    fp2correction751(t0);  
+    *valid = !is_equal_fp2(t0, zero);                       // Checks that ZP*ZQ*(XQ*ZP-XP*ZQ) != 0, i.e., that 2^(e-2)*P != 2^(e-2)*Q and neither P nor Q has order 2^(e-2)
+    
+    fp2add751(A, two, t0);                                  // t0 = A+2
+    xDBL(P, P, t0, four);                      
+    xDBL(Q, Q, t0, four);   
+    fp2mul751_mont(P->Z, Q->Z, t0);                         // t0 = ZP*ZQ    
+    fp2correction751(t0);  
+    *valid = *valid & !is_equal_fp2(t0, zero);              // Checks that 2^(e-1)*P != 0 and 2^(e-1)*Q != 0
+        
+    xDBL(P, P, t0, four);                      
+    xDBL(Q, Q, t0, four);   
+    fp2correction751(P->Z);   
+    fp2correction751(Q->Z);      
+    *valid = *valid & is_equal_fp2(P->Z, zero);             // Checks that 2^e*P = 0
+    *valid = *valid & is_equal_fp2(Q->Z, zero);             // Checks that 2^e*Q = 0
+    *valid = *valid & test_curve(A, rvalue, CurveIsogeny);  // Tests curve via Sutherland's algorithm
+
+    return CRYPTO_SUCCESS;
+}
diff --git a/ssl/Makefile b/ssl/Makefile
index dd12962..213df70 100644
--- a/ssl/Makefile
+++ b/ssl/Makefile
@@ -107,38 +107,40 @@ clean:
 # DO NOT DELETE THIS LINE -- make depend depends on it.
 
 bio_ssl.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-bio_ssl.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-bio_ssl.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-bio_ssl.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-bio_ssl.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-bio_ssl.o: ../include/openssl/err.h ../include/openssl/evp.h
-bio_ssl.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-bio_ssl.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-bio_ssl.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-bio_ssl.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-bio_ssl.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-bio_ssl.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-bio_ssl.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+bio_ssl.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+bio_ssl.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+bio_ssl.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+bio_ssl.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+bio_ssl.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+bio_ssl.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+bio_ssl.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+bio_ssl.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+bio_ssl.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+bio_ssl.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+bio_ssl.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+bio_ssl.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
+bio_ssl.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 bio_ssl.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 bio_ssl.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 bio_ssl.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
 bio_ssl.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 bio_ssl.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h bio_ssl.c
 d1_both.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-d1_both.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-d1_both.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-d1_both.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-d1_both.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-d1_both.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-d1_both.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-d1_both.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-d1_both.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-d1_both.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-d1_both.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-d1_both.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-d1_both.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-d1_both.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-d1_both.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+d1_both.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+d1_both.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+d1_both.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+d1_both.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+d1_both.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+d1_both.o: ../include/openssl/err.h ../include/openssl/evp.h
+d1_both.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+d1_both.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+d1_both.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+d1_both.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+d1_both.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+d1_both.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+d1_both.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+d1_both.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+d1_both.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 d1_both.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 d1_both.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 d1_both.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -160,26 +162,27 @@ d1_clnt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 d1_clnt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 d1_clnt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
 d1_clnt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-d1_clnt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-d1_clnt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-d1_clnt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-d1_clnt.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-d1_clnt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h d1_clnt.c
-d1_clnt.o: kssl_lcl.h ssl_locl.h
+d1_clnt.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+d1_clnt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+d1_clnt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+d1_clnt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+d1_clnt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+d1_clnt.o: ../include/openssl/x509_vfy.h d1_clnt.c kssl_lcl.h ssl_locl.h
 d1_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-d1_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-d1_lib.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-d1_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-d1_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-d1_lib.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-d1_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-d1_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-d1_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-d1_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-d1_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-d1_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-d1_lib.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-d1_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+d1_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+d1_lib.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+d1_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+d1_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+d1_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+d1_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
+d1_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+d1_lib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+d1_lib.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+d1_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+d1_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+d1_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+d1_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+d1_lib.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 d1_lib.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 d1_lib.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 d1_lib.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -187,19 +190,20 @@ d1_lib.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 d1_lib.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h d1_lib.c
 d1_lib.o: ssl_locl.h
 d1_meth.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-d1_meth.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-d1_meth.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-d1_meth.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-d1_meth.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-d1_meth.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-d1_meth.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-d1_meth.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-d1_meth.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-d1_meth.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-d1_meth.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-d1_meth.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-d1_meth.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-d1_meth.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+d1_meth.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+d1_meth.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+d1_meth.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+d1_meth.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+d1_meth.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+d1_meth.o: ../include/openssl/err.h ../include/openssl/evp.h
+d1_meth.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+d1_meth.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+d1_meth.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+d1_meth.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+d1_meth.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+d1_meth.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+d1_meth.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+d1_meth.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 d1_meth.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 d1_meth.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 d1_meth.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -207,39 +211,41 @@ d1_meth.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 d1_meth.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h d1_meth.c
 d1_meth.o: ssl_locl.h
 d1_pkt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-d1_pkt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-d1_pkt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-d1_pkt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-d1_pkt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-d1_pkt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-d1_pkt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-d1_pkt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-d1_pkt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-d1_pkt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-d1_pkt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-d1_pkt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-d1_pkt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-d1_pkt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-d1_pkt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+d1_pkt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+d1_pkt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+d1_pkt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+d1_pkt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+d1_pkt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+d1_pkt.o: ../include/openssl/err.h ../include/openssl/evp.h
+d1_pkt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+d1_pkt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+d1_pkt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+d1_pkt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+d1_pkt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+d1_pkt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+d1_pkt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+d1_pkt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+d1_pkt.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 d1_pkt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 d1_pkt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 d1_pkt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 d1_pkt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 d1_pkt.o: ../include/openssl/x509_vfy.h d1_pkt.c ssl_locl.h
 d1_srtp.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-d1_srtp.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-d1_srtp.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-d1_srtp.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-d1_srtp.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-d1_srtp.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-d1_srtp.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-d1_srtp.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-d1_srtp.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-d1_srtp.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-d1_srtp.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-d1_srtp.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-d1_srtp.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-d1_srtp.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+d1_srtp.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+d1_srtp.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+d1_srtp.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+d1_srtp.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+d1_srtp.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+d1_srtp.o: ../include/openssl/err.h ../include/openssl/evp.h
+d1_srtp.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+d1_srtp.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+d1_srtp.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+d1_srtp.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+d1_srtp.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+d1_srtp.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+d1_srtp.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+d1_srtp.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 d1_srtp.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 d1_srtp.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 d1_srtp.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -262,17 +268,18 @@ d1_srvr.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 d1_srvr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 d1_srvr.o: ../include/openssl/rand.h ../include/openssl/rsa.h
 d1_srvr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-d1_srvr.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-d1_srvr.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-d1_srvr.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-d1_srvr.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-d1_srvr.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h d1_srvr.c
-d1_srvr.o: ssl_locl.h
+d1_srvr.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+d1_srvr.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+d1_srvr.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+d1_srvr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+d1_srvr.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+d1_srvr.o: ../include/openssl/x509_vfy.h d1_srvr.c ssl_locl.h
 kssl.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-kssl.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-kssl.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-kssl.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-kssl.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+kssl.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+kssl.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+kssl.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+kssl.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+kssl.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
 kssl.o: ../include/openssl/evp.h ../include/openssl/hmac.h
 kssl.o: ../include/openssl/krb5_asn.h ../include/openssl/kssl.h
 kssl.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
@@ -281,46 +288,48 @@ kssl.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 kssl.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 kssl.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 kssl.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-kssl.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-kssl.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-kssl.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-kssl.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-kssl.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h kssl.c
-kssl.o: kssl_lcl.h
+kssl.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+kssl.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+kssl.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+kssl.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+kssl.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+kssl.o: ../include/openssl/x509_vfy.h kssl.c kssl_lcl.h
 s23_clnt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s23_clnt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s23_clnt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s23_clnt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s23_clnt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s23_clnt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s23_clnt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s23_clnt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s23_clnt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s23_clnt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s23_clnt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s23_clnt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s23_clnt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-s23_clnt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s23_clnt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s23_clnt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s23_clnt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s23_clnt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s23_clnt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s23_clnt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s23_clnt.o: ../include/openssl/err.h ../include/openssl/evp.h
+s23_clnt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s23_clnt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s23_clnt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s23_clnt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s23_clnt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s23_clnt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s23_clnt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+s23_clnt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s23_clnt.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s23_clnt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s23_clnt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s23_clnt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 s23_clnt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 s23_clnt.o: ../include/openssl/x509_vfy.h s23_clnt.c ssl_locl.h
 s23_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s23_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s23_lib.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s23_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s23_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s23_lib.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s23_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s23_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s23_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s23_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s23_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s23_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s23_lib.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s23_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s23_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s23_lib.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s23_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s23_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s23_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s23_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
+s23_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s23_lib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s23_lib.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s23_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s23_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s23_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s23_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s23_lib.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s23_lib.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s23_lib.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s23_lib.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -328,19 +337,20 @@ s23_lib.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s23_lib.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s23_lib.c
 s23_lib.o: ssl_locl.h
 s23_meth.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s23_meth.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s23_meth.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s23_meth.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s23_meth.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s23_meth.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s23_meth.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s23_meth.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s23_meth.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s23_meth.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s23_meth.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s23_meth.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s23_meth.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s23_meth.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s23_meth.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s23_meth.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s23_meth.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s23_meth.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s23_meth.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s23_meth.o: ../include/openssl/err.h ../include/openssl/evp.h
+s23_meth.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s23_meth.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s23_meth.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s23_meth.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s23_meth.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s23_meth.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s23_meth.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s23_meth.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s23_meth.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s23_meth.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s23_meth.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -348,19 +358,20 @@ s23_meth.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s23_meth.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s23_meth.c
 s23_meth.o: ssl_locl.h
 s23_pkt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s23_pkt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s23_pkt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s23_pkt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s23_pkt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s23_pkt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s23_pkt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s23_pkt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s23_pkt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s23_pkt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s23_pkt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s23_pkt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s23_pkt.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s23_pkt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s23_pkt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s23_pkt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s23_pkt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s23_pkt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s23_pkt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s23_pkt.o: ../include/openssl/err.h ../include/openssl/evp.h
+s23_pkt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s23_pkt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s23_pkt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s23_pkt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s23_pkt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s23_pkt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s23_pkt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s23_pkt.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s23_pkt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s23_pkt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s23_pkt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -368,39 +379,41 @@ s23_pkt.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s23_pkt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s23_pkt.c
 s23_pkt.o: ssl_locl.h
 s23_srvr.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s23_srvr.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s23_srvr.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s23_srvr.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s23_srvr.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s23_srvr.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s23_srvr.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s23_srvr.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s23_srvr.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s23_srvr.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s23_srvr.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s23_srvr.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s23_srvr.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-s23_srvr.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s23_srvr.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s23_srvr.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s23_srvr.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s23_srvr.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s23_srvr.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s23_srvr.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s23_srvr.o: ../include/openssl/err.h ../include/openssl/evp.h
+s23_srvr.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s23_srvr.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s23_srvr.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s23_srvr.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s23_srvr.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s23_srvr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s23_srvr.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+s23_srvr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s23_srvr.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s23_srvr.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s23_srvr.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s23_srvr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 s23_srvr.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 s23_srvr.o: ../include/openssl/x509_vfy.h s23_srvr.c ssl_locl.h
 s2_clnt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_clnt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_clnt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_clnt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_clnt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_clnt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_clnt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_clnt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_clnt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_clnt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_clnt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_clnt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_clnt.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_clnt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_clnt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_clnt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_clnt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_clnt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_clnt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_clnt.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_clnt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_clnt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_clnt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_clnt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_clnt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_clnt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_clnt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_clnt.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_clnt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_clnt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_clnt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -408,19 +421,20 @@ s2_clnt.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s2_clnt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_clnt.c
 s2_clnt.o: ssl_locl.h
 s2_enc.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_enc.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_enc.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_enc.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_enc.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_enc.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_enc.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_enc.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_enc.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_enc.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_enc.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_enc.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_enc.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_enc.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_enc.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_enc.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_enc.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_enc.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_enc.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_enc.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_enc.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_enc.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_enc.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_enc.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_enc.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_enc.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_enc.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_enc.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_enc.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_enc.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_enc.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -428,19 +442,20 @@ s2_enc.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s2_enc.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_enc.c
 s2_enc.o: ssl_locl.h
 s2_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_lib.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_lib.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_lib.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_lib.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_lib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_lib.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_lib.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_lib.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_lib.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_lib.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -448,19 +463,20 @@ s2_lib.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s2_lib.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_lib.c
 s2_lib.o: ssl_locl.h
 s2_meth.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_meth.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_meth.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_meth.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_meth.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_meth.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_meth.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_meth.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_meth.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_meth.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_meth.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_meth.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_meth.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_meth.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_meth.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_meth.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_meth.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_meth.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_meth.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_meth.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_meth.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_meth.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_meth.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_meth.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_meth.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_meth.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_meth.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_meth.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_meth.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_meth.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_meth.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -468,19 +484,20 @@ s2_meth.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s2_meth.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_meth.c
 s2_meth.o: ssl_locl.h
 s2_pkt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_pkt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_pkt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_pkt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_pkt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_pkt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_pkt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_pkt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_pkt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_pkt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_pkt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_pkt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_pkt.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_pkt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_pkt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_pkt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_pkt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_pkt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_pkt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_pkt.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_pkt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_pkt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_pkt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_pkt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_pkt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_pkt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_pkt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_pkt.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_pkt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_pkt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_pkt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -488,19 +505,20 @@ s2_pkt.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s2_pkt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_pkt.c
 s2_pkt.o: ssl_locl.h
 s2_srvr.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_srvr.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_srvr.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_srvr.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_srvr.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_srvr.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_srvr.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_srvr.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_srvr.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_srvr.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_srvr.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_srvr.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_srvr.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_srvr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_srvr.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_srvr.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_srvr.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_srvr.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_srvr.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_srvr.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_srvr.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_srvr.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_srvr.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_srvr.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_srvr.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_srvr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_srvr.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_srvr.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_srvr.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_srvr.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_srvr.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -508,40 +526,42 @@ s2_srvr.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s2_srvr.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_srvr.c
 s2_srvr.o: ssl_locl.h
 s3_both.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s3_both.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s3_both.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s3_both.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s3_both.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s3_both.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s3_both.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s3_both.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s3_both.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s3_both.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s3_both.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s3_both.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s3_both.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-s3_both.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s3_both.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s3_both.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s3_both.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s3_both.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s3_both.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s3_both.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s3_both.o: ../include/openssl/err.h ../include/openssl/evp.h
+s3_both.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s3_both.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s3_both.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s3_both.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s3_both.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s3_both.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s3_both.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+s3_both.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_both.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s3_both.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s3_both.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s3_both.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 s3_both.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 s3_both.o: ../include/openssl/x509_vfy.h s3_both.c ssl_locl.h
 s3_cbc.o: ../crypto/constant_time_locl.h ../e_os.h ../include/openssl/asn1.h
-s3_cbc.o: ../include/openssl/bio.h ../include/openssl/buffer.h
-s3_cbc.o: ../include/openssl/comp.h ../include/openssl/crypto.h
-s3_cbc.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
-s3_cbc.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-s3_cbc.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-s3_cbc.o: ../include/openssl/err.h ../include/openssl/evp.h
-s3_cbc.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-s3_cbc.o: ../include/openssl/lhash.h ../include/openssl/md5.h
-s3_cbc.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s3_cbc.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s3_cbc.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s3_cbc.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s3_cbc.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s3_cbc.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_cbc.o: ../include/openssl/bio.h ../include/openssl/bn.h
+s3_cbc.o: ../include/openssl/buffer.h ../include/openssl/comp.h
+s3_cbc.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
+s3_cbc.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+s3_cbc.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+s3_cbc.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+s3_cbc.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+s3_cbc.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+s3_cbc.o: ../include/openssl/md5.h ../include/openssl/obj_mac.h
+s3_cbc.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s3_cbc.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s3_cbc.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s3_cbc.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s3_cbc.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s3_cbc.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s3_cbc.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s3_cbc.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s3_cbc.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -564,47 +584,50 @@ s3_clnt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
 s3_clnt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
 s3_clnt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
 s3_clnt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s3_clnt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
-s3_clnt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
-s3_clnt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
-s3_clnt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-s3_clnt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
-s3_clnt.o: ../include/openssl/x509_vfy.h kssl_lcl.h s3_clnt.c ssl_locl.h
+s3_clnt.o: ../include/openssl/sha.h ../include/openssl/sidh.h
+s3_clnt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
+s3_clnt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
+s3_clnt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
+s3_clnt.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
+s3_clnt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h kssl_lcl.h
+s3_clnt.o: s3_clnt.c ssl_locl.h
 s3_enc.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s3_enc.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s3_enc.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s3_enc.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s3_enc.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s3_enc.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s3_enc.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s3_enc.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s3_enc.o: ../include/openssl/md5.h ../include/openssl/obj_mac.h
-s3_enc.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-s3_enc.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-s3_enc.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-s3_enc.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-s3_enc.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s3_enc.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s3_enc.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s3_enc.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s3_enc.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s3_enc.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s3_enc.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s3_enc.o: ../include/openssl/err.h ../include/openssl/evp.h
+s3_enc.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s3_enc.o: ../include/openssl/lhash.h ../include/openssl/md5.h
+s3_enc.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+s3_enc.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+s3_enc.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+s3_enc.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+s3_enc.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
+s3_enc.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_enc.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s3_enc.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s3_enc.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s3_enc.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 s3_enc.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 s3_enc.o: ../include/openssl/x509_vfy.h s3_enc.c ssl_locl.h
 s3_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s3_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s3_lib.o: ../include/openssl/crypto.h ../include/openssl/dh.h
-s3_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
-s3_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-s3_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-s3_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
-s3_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-s3_lib.o: ../include/openssl/lhash.h ../include/openssl/md5.h
-s3_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s3_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s3_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s3_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s3_lib.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s3_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s3_lib.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s3_lib.o: ../include/openssl/dh.h ../include/openssl/dsa.h
+s3_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+s3_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+s3_lib.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+s3_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+s3_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+s3_lib.o: ../include/openssl/md5.h ../include/openssl/obj_mac.h
+s3_lib.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s3_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s3_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s3_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s3_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s3_lib.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s3_lib.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s3_lib.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s3_lib.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -612,19 +635,20 @@ s3_lib.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s3_lib.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h kssl_lcl.h
 s3_lib.o: s3_lib.c ssl_locl.h
 s3_meth.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s3_meth.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s3_meth.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s3_meth.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s3_meth.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s3_meth.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s3_meth.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s3_meth.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s3_meth.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s3_meth.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s3_meth.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s3_meth.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s3_meth.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s3_meth.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_meth.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s3_meth.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s3_meth.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s3_meth.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s3_meth.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s3_meth.o: ../include/openssl/err.h ../include/openssl/evp.h
+s3_meth.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s3_meth.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s3_meth.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s3_meth.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s3_meth.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s3_meth.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s3_meth.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s3_meth.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s3_meth.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s3_meth.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s3_meth.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -632,20 +656,21 @@ s3_meth.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 s3_meth.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s3_meth.c
 s3_meth.o: ssl_locl.h
 s3_pkt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s3_pkt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s3_pkt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s3_pkt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s3_pkt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s3_pkt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s3_pkt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s3_pkt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s3_pkt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s3_pkt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s3_pkt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s3_pkt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s3_pkt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-s3_pkt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s3_pkt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s3_pkt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s3_pkt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s3_pkt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s3_pkt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s3_pkt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s3_pkt.o: ../include/openssl/err.h ../include/openssl/evp.h
+s3_pkt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s3_pkt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s3_pkt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s3_pkt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s3_pkt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s3_pkt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s3_pkt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+s3_pkt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_pkt.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s3_pkt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s3_pkt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s3_pkt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -668,26 +693,27 @@ s3_srvr.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 s3_srvr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 s3_srvr.o: ../include/openssl/rand.h ../include/openssl/rsa.h
 s3_srvr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-s3_srvr.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-s3_srvr.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-s3_srvr.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-s3_srvr.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-s3_srvr.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h kssl_lcl.h
-s3_srvr.o: s3_srvr.c ssl_locl.h
+s3_srvr.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+s3_srvr.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+s3_srvr.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+s3_srvr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+s3_srvr.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+s3_srvr.o: ../include/openssl/x509_vfy.h kssl_lcl.h s3_srvr.c ssl_locl.h
 ssl_algs.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_algs.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_algs.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_algs.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_algs.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_algs.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_algs.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_algs.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_algs.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_algs.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_algs.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_algs.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_algs.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_algs.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_algs.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_algs.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_algs.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_algs.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_algs.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_algs.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_algs.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_algs.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_algs.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_algs.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_algs.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_algs.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_algs.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_algs.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_algs.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_algs.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_algs.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -695,20 +721,21 @@ ssl_algs.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_algs.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_algs.c
 ssl_algs.o: ssl_locl.h
 ssl_asn1.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/asn1_mac.h
-ssl_asn1.o: ../include/openssl/bio.h ../include/openssl/buffer.h
-ssl_asn1.o: ../include/openssl/comp.h ../include/openssl/crypto.h
-ssl_asn1.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
-ssl_asn1.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-ssl_asn1.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-ssl_asn1.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_asn1.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_asn1.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_asn1.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ssl_asn1.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ssl_asn1.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-ssl_asn1.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-ssl_asn1.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-ssl_asn1.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+ssl_asn1.o: ../include/openssl/bio.h ../include/openssl/bn.h
+ssl_asn1.o: ../include/openssl/buffer.h ../include/openssl/comp.h
+ssl_asn1.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
+ssl_asn1.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+ssl_asn1.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+ssl_asn1.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+ssl_asn1.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_asn1.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_asn1.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_asn1.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssl_asn1.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssl_asn1.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssl_asn1.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
+ssl_asn1.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_asn1.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 ssl_asn1.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 ssl_asn1.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 ssl_asn1.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -730,47 +757,50 @@ ssl_cert.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
 ssl_cert.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
 ssl_cert.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
 ssl_cert.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-ssl_cert.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-ssl_cert.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-ssl_cert.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-ssl_cert.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-ssl_cert.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
-ssl_cert.o: ../include/openssl/x509v3.h ssl_cert.c ssl_locl.h
+ssl_cert.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+ssl_cert.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+ssl_cert.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+ssl_cert.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+ssl_cert.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+ssl_cert.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h
+ssl_cert.o: ssl_cert.c ssl_locl.h
 ssl_ciph.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_ciph.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_ciph.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_ciph.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_ciph.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_ciph.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-ssl_ciph.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_ciph.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_ciph.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_ciph.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ssl_ciph.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ssl_ciph.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-ssl_ciph.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-ssl_ciph.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-ssl_ciph.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+ssl_ciph.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_ciph.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_ciph.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_ciph.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_ciph.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_ciph.o: ../include/openssl/engine.h ../include/openssl/err.h
+ssl_ciph.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_ciph.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_ciph.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_ciph.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssl_ciph.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssl_ciph.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssl_ciph.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
+ssl_ciph.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_ciph.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 ssl_ciph.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 ssl_ciph.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 ssl_ciph.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 ssl_ciph.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 ssl_ciph.o: ../include/openssl/x509_vfy.h ssl_ciph.c ssl_locl.h
 ssl_conf.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_conf.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_conf.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-ssl_conf.o: ../include/openssl/dh.h ../include/openssl/dsa.h
-ssl_conf.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_conf.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_conf.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_conf.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_conf.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_conf.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_conf.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_conf.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_conf.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_conf.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_conf.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_conf.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_conf.o: ../include/openssl/comp.h ../include/openssl/conf.h
+ssl_conf.o: ../include/openssl/crypto.h ../include/openssl/dh.h
+ssl_conf.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_conf.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_conf.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_conf.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_conf.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_conf.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_conf.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_conf.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_conf.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_conf.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_conf.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_conf.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_conf.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_conf.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_conf.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -778,58 +808,61 @@ ssl_conf.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_conf.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_conf.c
 ssl_conf.o: ssl_locl.h
 ssl_err.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_err.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_err.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-ssl_err.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-ssl_err.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-ssl_err.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_err.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_err.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_err.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ssl_err.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ssl_err.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-ssl_err.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-ssl_err.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_err.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_err.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_err.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+ssl_err.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+ssl_err.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+ssl_err.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_err.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_err.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_err.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssl_err.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssl_err.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssl_err.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
+ssl_err.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_err.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_err.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_err.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
 ssl_err.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_err.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_err.c
 ssl_err2.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_err2.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_err2.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-ssl_err2.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-ssl_err2.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-ssl_err2.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_err2.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_err2.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_err2.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ssl_err2.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ssl_err2.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-ssl_err2.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-ssl_err2.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_err2.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_err2.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_err2.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+ssl_err2.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+ssl_err2.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+ssl_err2.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_err2.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_err2.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_err2.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssl_err2.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssl_err2.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssl_err2.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
+ssl_err2.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_err2.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_err2.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_err2.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
 ssl_err2.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_err2.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_err2.c
 ssl_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_lib.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-ssl_lib.o: ../include/openssl/dh.h ../include/openssl/dsa.h
-ssl_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_lib.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-ssl_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_lib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_lib.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-ssl_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_lib.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-ssl_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-ssl_lib.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+ssl_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_lib.o: ../include/openssl/comp.h ../include/openssl/conf.h
+ssl_lib.o: ../include/openssl/crypto.h ../include/openssl/dh.h
+ssl_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_lib.o: ../include/openssl/engine.h ../include/openssl/err.h
+ssl_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_lib.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+ssl_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_lib.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+ssl_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_lib.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 ssl_lib.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 ssl_lib.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 ssl_lib.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -837,19 +870,20 @@ ssl_lib.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 ssl_lib.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h kssl_lcl.h
 ssl_lib.o: ssl_lib.c ssl_locl.h
 ssl_rsa.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_rsa.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_rsa.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_rsa.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_rsa.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_rsa.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_rsa.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_rsa.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_rsa.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_rsa.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_rsa.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_rsa.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_rsa.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_rsa.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_rsa.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_rsa.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_rsa.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_rsa.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_rsa.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_rsa.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_rsa.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_rsa.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_rsa.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_rsa.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_rsa.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_rsa.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_rsa.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_rsa.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_rsa.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_rsa.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_rsa.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -857,20 +891,21 @@ ssl_rsa.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_rsa.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 ssl_rsa.o: ssl_rsa.c
 ssl_sess.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_sess.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_sess.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_sess.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_sess.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_sess.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-ssl_sess.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_sess.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_sess.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_sess.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ssl_sess.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ssl_sess.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-ssl_sess.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-ssl_sess.o: ../include/openssl/rand.h ../include/openssl/rsa.h
-ssl_sess.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_sess.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_sess.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_sess.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_sess.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_sess.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_sess.o: ../include/openssl/engine.h ../include/openssl/err.h
+ssl_sess.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_sess.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_sess.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_sess.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssl_sess.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssl_sess.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssl_sess.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
+ssl_sess.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_sess.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_sess.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_sess.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_sess.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -878,19 +913,20 @@ ssl_sess.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_sess.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 ssl_sess.o: ssl_sess.c
 ssl_stat.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_stat.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_stat.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_stat.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_stat.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_stat.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_stat.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_stat.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_stat.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_stat.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_stat.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_stat.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_stat.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_stat.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_stat.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_stat.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_stat.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_stat.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_stat.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_stat.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_stat.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_stat.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_stat.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_stat.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_stat.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_stat.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_stat.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_stat.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_stat.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_stat.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_stat.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -898,19 +934,20 @@ ssl_stat.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_stat.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 ssl_stat.o: ssl_stat.c
 ssl_txt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_txt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_txt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_txt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_txt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_txt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_txt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_txt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_txt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_txt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_txt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_txt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_txt.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_txt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_txt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_txt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_txt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_txt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_txt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_txt.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_txt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_txt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_txt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_txt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_txt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_txt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_txt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_txt.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_txt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_txt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_txt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -918,19 +955,20 @@ ssl_txt.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_txt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 ssl_txt.o: ssl_txt.c
 ssl_utst.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_utst.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_utst.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_utst.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_utst.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_utst.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_utst.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_utst.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_utst.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_utst.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_utst.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_utst.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_utst.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_utst.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_utst.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_utst.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_utst.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_utst.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_utst.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_utst.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_utst.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_utst.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_utst.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_utst.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_utst.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_utst.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_utst.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_utst.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_utst.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_utst.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_utst.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -938,40 +976,42 @@ ssl_utst.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_utst.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 ssl_utst.o: ssl_utst.c
 t1_clnt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_clnt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_clnt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_clnt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_clnt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_clnt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_clnt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_clnt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_clnt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_clnt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_clnt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_clnt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_clnt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-t1_clnt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-t1_clnt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+t1_clnt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_clnt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_clnt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_clnt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_clnt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_clnt.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_clnt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_clnt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_clnt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_clnt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_clnt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_clnt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_clnt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+t1_clnt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_clnt.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 t1_clnt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 t1_clnt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 t1_clnt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 t1_clnt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 t1_clnt.o: ../include/openssl/x509_vfy.h ssl_locl.h t1_clnt.c
 t1_enc.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_enc.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_enc.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_enc.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_enc.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_enc.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_enc.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_enc.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_enc.o: ../include/openssl/md5.h ../include/openssl/obj_mac.h
-t1_enc.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-t1_enc.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-t1_enc.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-t1_enc.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-t1_enc.o: ../include/openssl/rand.h ../include/openssl/rsa.h
-t1_enc.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_enc.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_enc.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_enc.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_enc.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_enc.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_enc.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_enc.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_enc.o: ../include/openssl/lhash.h ../include/openssl/md5.h
+t1_enc.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+t1_enc.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+t1_enc.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+t1_enc.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+t1_enc.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
+t1_enc.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+t1_enc.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 t1_enc.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 t1_enc.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 t1_enc.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -979,19 +1019,20 @@ t1_enc.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 t1_enc.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 t1_enc.o: t1_enc.c
 t1_ext.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_ext.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_ext.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_ext.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_ext.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_ext.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_ext.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_ext.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_ext.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_ext.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_ext.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_ext.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_ext.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-t1_ext.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_ext.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_ext.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_ext.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_ext.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_ext.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_ext.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_ext.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_ext.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_ext.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_ext.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_ext.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_ext.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_ext.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+t1_ext.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 t1_ext.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 t1_ext.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 t1_ext.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -999,21 +1040,22 @@ t1_ext.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 t1_ext.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 t1_ext.o: t1_ext.c
 t1_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_lib.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-t1_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
-t1_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-t1_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-t1_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
-t1_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-t1_lib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-t1_lib.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-t1_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_lib.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-t1_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-t1_lib.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+t1_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_lib.o: ../include/openssl/comp.h ../include/openssl/conf.h
+t1_lib.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
+t1_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+t1_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+t1_lib.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+t1_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+t1_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+t1_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+t1_lib.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+t1_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_lib.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+t1_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_lib.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 t1_lib.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 t1_lib.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 t1_lib.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -1021,19 +1063,20 @@ t1_lib.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 t1_lib.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h ssl_locl.h
 t1_lib.o: t1_lib.c
 t1_meth.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_meth.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_meth.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_meth.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_meth.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_meth.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_meth.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_meth.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_meth.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_meth.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_meth.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_meth.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_meth.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-t1_meth.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_meth.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_meth.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_meth.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_meth.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_meth.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_meth.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_meth.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_meth.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_meth.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_meth.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_meth.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_meth.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_meth.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+t1_meth.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 t1_meth.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 t1_meth.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 t1_meth.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -1041,19 +1084,20 @@ t1_meth.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 t1_meth.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 t1_meth.o: t1_meth.c
 t1_reneg.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_reneg.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_reneg.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_reneg.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_reneg.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_reneg.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_reneg.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_reneg.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_reneg.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_reneg.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_reneg.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_reneg.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_reneg.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-t1_reneg.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_reneg.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_reneg.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_reneg.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_reneg.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_reneg.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_reneg.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_reneg.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_reneg.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_reneg.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_reneg.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_reneg.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_reneg.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_reneg.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+t1_reneg.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 t1_reneg.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 t1_reneg.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 t1_reneg.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -1061,39 +1105,41 @@ t1_reneg.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 t1_reneg.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 t1_reneg.o: t1_reneg.c
 t1_srvr.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_srvr.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_srvr.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_srvr.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_srvr.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_srvr.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_srvr.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_srvr.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_srvr.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_srvr.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_srvr.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_srvr.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_srvr.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-t1_srvr.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-t1_srvr.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+t1_srvr.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_srvr.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_srvr.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_srvr.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_srvr.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_srvr.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_srvr.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_srvr.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_srvr.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_srvr.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_srvr.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_srvr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_srvr.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+t1_srvr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_srvr.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 t1_srvr.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 t1_srvr.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 t1_srvr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 t1_srvr.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 t1_srvr.o: ../include/openssl/x509_vfy.h ssl_locl.h t1_srvr.c
 t1_trce.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_trce.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_trce.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_trce.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_trce.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_trce.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_trce.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_trce.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_trce.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_trce.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_trce.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_trce.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_trce.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-t1_trce.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_trce.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_trce.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_trce.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_trce.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_trce.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_trce.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_trce.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_trce.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_trce.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_trce.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_trce.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_trce.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_trce.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+t1_trce.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 t1_trce.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 t1_trce.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 t1_trce.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -1115,9 +1161,10 @@ tls_srp.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 tls_srp.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 tls_srp.o: ../include/openssl/rand.h ../include/openssl/rsa.h
 tls_srp.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-tls_srp.o: ../include/openssl/srp.h ../include/openssl/srtp.h
-tls_srp.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
-tls_srp.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
-tls_srp.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-tls_srp.o: ../include/openssl/tls1.h ../include/openssl/x509.h
-tls_srp.o: ../include/openssl/x509_vfy.h ssl_locl.h tls_srp.c
+tls_srp.o: ../include/openssl/sidh.h ../include/openssl/srp.h
+tls_srp.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
+tls_srp.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
+tls_srp.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
+tls_srp.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
+tls_srp.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
+tls_srp.o: tls_srp.c
diff --git a/ssl/s3_clnt.c b/ssl/s3_clnt.c
index 32f2f1a..cd63937 100644
--- a/ssl/s3_clnt.c
+++ b/ssl/s3_clnt.c
@@ -1391,6 +1391,10 @@ int ssl3_get_key_exchange(SSL *s)
     int curve_nid = 0;
     int encoded_pt_len = 0;
 #endif
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PUB *srvr_sidhpub = NULL;
+    int encoded_sidhpub_len = 0;
+#endif
 
     EVP_MD_CTX_init(&md_ctx);
 
@@ -1454,6 +1458,13 @@ int ssl3_get_key_exchange(SSL *s)
             s->session->sess_cert->peer_ecdh_tmp = NULL;
         }
 #endif
+#ifndef OPENSSL_NO_SIDH
+	if (s->session->sess_cert->peer_sidhpub_tmp)
+	  {
+	    SIDH_PUB_free(s->session->sess_cert->peer_sidhpub_tmp);
+	    s->session->sess_cert->peer_sidhpub_tmp=NULL;
+	  }
+#endif
     } else {
         s->session->sess_cert = ssl_sess_cert_new();
     }
@@ -1816,8 +1827,46 @@ int ssl3_get_key_exchange(SSL *s)
     }
 #endif                          /* !OPENSSL_NO_DH */
 
+#ifndef OPENSSL_NO_SIDH
+    else if ((alg_k & SSL_kSIDH) && !(alg_k & SSL_kEECDH))
+      {
+	/* Get the encoded SIDH public key  */
+	if ((srvr_sidhpub = SIDH_PUB_new()) == NULL)
+	  {
+	    SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+	    goto err;
+	  }
+	
+	encoded_sidhpub_len = (p[0] << 8) | p[1];
+	p += 2;
+	n -= 2;
+	if ((encoded_sidhpub_len >= n) ||
+	    (o2i_SIDH_PUB(&srvr_sidhpub, p, encoded_sidhpub_len) == NULL))
+	  {
+	    al=SSL_AD_DECODE_ERROR;
+	    SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIDH_PUB);
+	    goto f_err;
+	  }
+
+	n-=encoded_sidhpub_len;
+	p+=encoded_sidhpub_len;
+	param_len = 2 + encoded_sidhpub_len;
+
+	if (0) ;
+#ifndef OPENSSL_NO_RSA
+	else if (alg_a & SSL_aRSA)
+	  pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
+#endif
+#ifndef OPENSSL_NO_ECDSA
+	else if (alg_a & SSL_aECDSA)
+	  pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
+#endif
+	s->session->sess_cert->peer_sidhpub_tmp=srvr_sidhpub;
+		}
+#endif /* !OPENSSL_NO_SIDH */
+
 #ifndef OPENSSL_NO_ECDH
-    else if (alg_k & SSL_kEECDH) {
+    else if (alg_k & SSL_kEECDH || alg_k & SSL_kSIDHECDHEHYBRID) {
         EC_GROUP *ngroup;
         const EC_GROUP *group;
 
@@ -1902,6 +1951,31 @@ int ssl3_get_key_exchange(SSL *s)
         n -= param_len;
         p += encoded_pt_len;
 
+	if (alg_k & SSL_kSIDHECDHEHYBRID) {
+	  /* Get the encoded SIDH public */
+	  if ((srvr_sidhpub = SIDH_PUB_new()) == NULL)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+	      goto err;
+	    }
+
+	  encoded_sidhpub_len = (p[0] << 8) | p[1];
+	  p += 2;
+	  n -= 2;
+	  if ((encoded_sidhpub_len >= n) ||
+	      (o2i_SIDH_PUB(&srvr_sidhpub, p, encoded_sidhpub_len) == NULL))
+	    {
+	      al=SSL_AD_DECODE_ERROR;
+	      SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIDH_PUB);
+	      goto f_err;
+	    }
+
+	  n-=encoded_sidhpub_len;
+	  p+=encoded_sidhpub_len;
+	  param_len += 2 + encoded_sidhpub_len;
+	  s->session->sess_cert->peer_sidhpub_tmp=srvr_sidhpub;
+	}
+
         /*
          * The ECC/TLS specification does not mention the use of DSA to sign
          * ECParameters in the server key exchange message. We do support RSA
@@ -2069,6 +2143,9 @@ int ssl3_get_key_exchange(SSL *s)
     if (ecdh != NULL)
         EC_KEY_free(ecdh);
 #endif
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PUB_free(srvr_sidhpub);
+#endif
     EVP_MD_CTX_cleanup(&md_ctx);
     s->state = SSL_ST_ERR;
     return (-1);
@@ -2496,6 +2573,8 @@ int ssl3_send_client_key_exchange(SSL *s)
 {
     unsigned char *p;
     int n;
+    unsigned char *pprime;
+    int nprime;
     unsigned long alg_k;
 #ifndef OPENSSL_NO_RSA
     unsigned char *q;
@@ -2512,7 +2591,13 @@ int ssl3_send_client_key_exchange(SSL *s)
     int encoded_pt_len = 0;
     BN_CTX *bn_ctx = NULL;
 #endif
-
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PAIR *clnt_sidh = NULL;
+    const SIDH_PUB *srvr_sidhpub = NULL;
+    unsigned char *encoded_sidhpub = NULL;
+    int encoded_sidhpub_len = 0;
+#endif
+ 
     if (s->state == SSL3_ST_CW_KEY_EXCH_A) {
         p = ssl_handshake_start(s);
 
@@ -2806,7 +2891,7 @@ int ssl3_send_client_key_exchange(SSL *s)
 #endif
 
 #ifndef OPENSSL_NO_ECDH
-        else if (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe)) {
+		else if (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID)) {
             const EC_GROUP *srvr_group = NULL;
             EC_KEY *tkey;
             int ecdh_clnt_cert = 0;
@@ -2824,7 +2909,7 @@ int ssl3_send_client_key_exchange(SSL *s)
              * computation as part of client certificate? If so, set
              * ecdh_clnt_cert to 1.
              */
-            if ((alg_k & (SSL_kECDHr | SSL_kECDHe)) && (s->cert != NULL)) {
+			if ((alg_k & (SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID)) && (s->cert != NULL)) {
                 /*-
                  * XXX: For now, we do not support client
                  * authentication using ECDH certificates.
@@ -2927,6 +3012,58 @@ int ssl3_send_client_key_exchange(SSL *s)
                 goto err;
             }
 
+	    if (alg_k & SSL_kSIDHECDHEHYBRID) {
+	      srvr_sidhpub = s->session->sess_cert->peer_sidhpub_tmp;
+
+	      if (srvr_sidhpub == NULL)
+		{
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
+			 ERR_R_INTERNAL_ERROR);
+		  goto err;
+		}
+
+	      if ((clnt_sidh=SIDH_PAIR_new()) == NULL) 
+		{
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+		  goto err;
+		}
+	      if (s->s3->tmp.sidh_ctx == NULL) {
+		/* initialize SIDH context */
+		s->s3->tmp.sidh_ctx = SIDH_CTX_new();
+		if (s->s3->tmp.sidh_ctx == NULL) {
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      }
+
+	      /* Generate a new SIDH key pair */
+	      if (!(SIDH_PAIR_generate_key_client(clnt_sidh, s->s3->tmp.sidh_ctx)))
+		{
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+
+	      /* use the 'pprime' buffer for the SIDH shared key, but
+	       * make sure to clear it out afterwards
+	       */
+
+	      if ((pprime = OPENSSL_malloc(SIDH_PUBKEY_LEN)) == NULL) {
+		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+		goto err;					
+	      }
+
+	      nprime = SIDH_compute_key_client(pprime, SIDH_PUBKEY_LEN, srvr_sidhpub, clnt_sidh, NULL, s->s3->tmp.sidh_ctx);
+	      if (nprime <= 0)
+		{
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      // FIXME: double-check if p is big enough
+	      memcpy(p + n, pprime, nprime);
+	      n += nprime;
+	      OPENSSL_free(pprime);
+	    }
+
             /* generate master key from the result */
             s->session->master_key_length =
                 s->method->ssl3_enc->generate_master_secret(s,
@@ -2970,10 +3107,29 @@ int ssl3_send_client_key_exchange(SSL *s)
                 p += 1;
                 /* copy the point */
                 memcpy((unsigned char *)p, encodedPoint, n);
+		p += n;
                 /* increment n to account for length field */
                 n += 1;
             }
 
+	    if (alg_k & SSL_kSIDHECDHEHYBRID) {
+	      /* Encode the public key */
+	      encoded_sidhpub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(clnt_sidh), &encoded_sidhpub);
+	      
+	      p[0] = (encoded_sidhpub_len >> 8) & 0xFF;
+	      p[1] =  encoded_sidhpub_len       & 0xFF;
+	      p += 2;
+	      memcpy((unsigned char *)p, encoded_sidhpub, encoded_sidhpub_len);
+	      p += encoded_sidhpub_len;
+	      
+	      n += 2 + encoded_sidhpub_len;
+	      
+	      /* Free allocated memory */
+	      SIDH_CTX_free(s->s3->tmp.sidh_ctx);
+	      OPENSSL_free(encoded_sidhpub);
+	      SIDH_PAIR_free(clnt_sidh);
+	    }
+
             /* Free allocated memory */
             BN_CTX_free(bn_ctx);
             if (encodedPoint != NULL)
@@ -2983,6 +3139,75 @@ int ssl3_send_client_key_exchange(SSL *s)
             EVP_PKEY_free(srvr_pub_pkey);
         }
 #endif                          /* !OPENSSL_NO_ECDH */
+#ifndef OPENSSL_NO_SIDH
+	else if ((alg_k & SSL_kSIDH) && !(alg_k & SSL_kEECDH))
+	  {
+	    srvr_sidhpub = s->session->sess_cert->peer_sidhpub_tmp;
+	    if (srvr_sidhpub == NULL)
+	      {
+		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
+		       ERR_R_INTERNAL_ERROR);
+		goto err;
+	      }
+
+	    if ((clnt_sidh=SIDH_PAIR_new()) == NULL)
+	      {
+		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+		goto err;
+	      }
+
+	      if (s->s3->tmp.sidh_ctx == NULL) {
+		/* initialize SIDH context */
+		s->s3->tmp.sidh_ctx = SIDH_CTX_new();
+		if (s->s3->tmp.sidh_ctx == NULL) {
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      }
+
+	      /* Generate a new SIDH key pair */
+	      if (!(SIDH_PAIR_generate_key_client(clnt_sidh, s->s3->tmp.sidh_ctx)))
+		{
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+
+	    /* use the 'p' buffer for the SIDH shared key, but
+	     * make sure to clear it out afterwards
+	     */
+
+	    n = SIDH_compute_key_client(p, SIDH_PUBKEY_LEN, srvr_sidhpub, clnt_sidh, NULL, s->s3->tmp.sidh_ctx);
+	    if (n <= 0)
+	      {
+		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		goto err;
+	      }
+
+	    /* generate master key from the result */
+	    s->session->master_key_length = s->method->ssl3_enc \
+	      -> generate_master_secret(s,
+					s->session->master_key,
+					p, n);
+
+	    memset(p, 0, n); /* clean up */
+
+	    /* Encode the public key */
+	    encoded_sidhpub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(clnt_sidh), &encoded_sidhpub);
+
+	    p[0] = (encoded_sidhpub_len >> 8) & 0xFF;
+	    p[1] =  encoded_sidhpub_len       & 0xFF;
+	    p += 2;
+	    memcpy((unsigned char *)p, encoded_sidhpub, encoded_sidhpub_len);
+	    p += encoded_sidhpub_len;
+
+	    n = 2 + encoded_sidhpub_len;
+
+	    /* Free allocated memory */
+	    SIDH_CTX_free(s->s3->tmp.sidh_ctx); 
+	    OPENSSL_free(encoded_sidhpub);
+	    SIDH_PAIR_free(clnt_sidh);
+	  }
+#endif /* !OPENSSL_NO_SIDH */
         else if (alg_k & SSL_kGOST) {
             /* GOST key exchange message creation */
             EVP_PKEY_CTX *pkey_ctx;
@@ -3234,6 +3459,11 @@ int ssl3_send_client_key_exchange(SSL *s)
         EC_KEY_free(clnt_ecdh);
     EVP_PKEY_free(srvr_pub_pkey);
 #endif
+#ifndef OPENSSL_NO_SIDH
+    SIDH_CTX_free(s->s3->tmp.sidh_ctx);
+    OPENSSL_free(encoded_sidhpub);
+    SIDH_PAIR_free(clnt_sidh);
+#endif
     s->state = SSL_ST_ERR;
     return (-1);
 }
diff --git a/ssl/s3_lib.c b/ssl/s3_lib.c
index 0385e03..c8d96c7 100644
--- a/ssl/s3_lib.c
+++ b/ssl/s3_lib.c
@@ -2888,6 +2888,72 @@ OPENSSL_GLOBAL SSL_CIPHER ssl3_ciphers[] = {
 
 #endif                          /* OPENSSL_NO_ECDH */
 
+#ifndef OPENSSL_NO_SIDH
+	/* Cipher E010 */
+	{
+	1,
+	TLS1_TXT_SIDH_RSA_WITH_AES_128_GCM_SHA256,
+	TLS1_CK_SIDH_RSA_WITH_AES_128_GCM_SHA256,
+	SSL_kSIDH,
+	SSL_aRSA,
+	SSL_AES128GCM,
+	SSL_AEAD,
+	SSL_TLSV1_2,
+	SSL_NOT_EXP|SSL_HIGH,
+	SSL_HANDSHAKE_MAC_SHA256|TLS1_PRF_SHA256,
+	128,
+	128,
+	},
+
+	/* Cipher E011 */
+	{
+	1,
+	TLS1_TXT_SIDH_ECDSA_WITH_AES_128_GCM_SHA256,
+	TLS1_CK_SIDH_ECDSA_WITH_AES_128_GCM_SHA256,
+	SSL_kSIDH,
+	SSL_aECDSA,
+	SSL_AES128GCM,
+	SSL_AEAD,
+	SSL_TLSV1_2,
+	SSL_NOT_EXP|SSL_HIGH,
+	SSL_HANDSHAKE_MAC_SHA256|TLS1_PRF_SHA256,
+	128,
+	128,
+	},
+
+	/* Cipher E012 */
+	{
+	1,
+	TLS1_TXT_SIDH_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+	TLS1_CK_SIDH_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+	SSL_kSIDHECDHEHYBRID,
+	SSL_aRSA,
+	SSL_AES128GCM,
+	SSL_AEAD,
+	SSL_TLSV1_2,
+	SSL_NOT_EXP|SSL_HIGH,
+	SSL_HANDSHAKE_MAC_SHA256|TLS1_PRF_SHA256,
+	128,
+	128,
+	},
+
+	/* Cipher E013 */
+	{
+	1,
+	TLS1_TXT_SIDH_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+	TLS1_CK_SIDH_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+	SSL_kSIDHECDHEHYBRID,
+	SSL_aECDSA,
+	SSL_AES128GCM,
+	SSL_AEAD,
+	SSL_TLSV1_2,
+	SSL_NOT_EXP|SSL_HIGH,
+	SSL_HANDSHAKE_MAC_SHA256|TLS1_PRF_SHA256,
+	128,
+	128,
+	},
+#endif
+
 #ifdef TEMP_GOST_TLS
 /* Cipher FF00 */
     {
@@ -4194,7 +4260,7 @@ SSL_CIPHER *ssl3_choose_cipher(SSL *s, STACK_OF(SSL_CIPHER) *clnt,
          * if we are considering an ECC cipher suite that uses an ephemeral
          * EC key check it
          */
-        if (alg_k & SSL_kEECDH)
+		if (alg_k & SSL_kEECDH || alg_k & SSL_kSIDHECDHEHYBRID)
             ok = ok && tls1_check_ec_tmp_key(s, c->id);
 #  endif                        /* OPENSSL_NO_ECDH */
 # endif                         /* OPENSSL_NO_EC */
@@ -4303,7 +4369,7 @@ int ssl3_get_req_cert_type(SSL *s, unsigned char *p)
         p[ret++] = SSL3_CT_DSS_SIGN;
 #endif
 #ifndef OPENSSL_NO_ECDH
-    if ((alg_k & (SSL_kECDHr | SSL_kECDHe)) && (s->version >= TLS1_VERSION)) {
+	if ((alg_k & (SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID)) && (s->version >= TLS1_VERSION)) {
         if (nostrict || have_rsa_sign)
             p[ret++] = TLS_CT_RSA_FIXED_ECDH;
         if (nostrict || have_ecdsa_sign)
diff --git a/ssl/s3_srvr.c b/ssl/s3_srvr.c
index ea56f9c..3b5b697 100644
--- a/ssl/s3_srvr.c
+++ b/ssl/s3_srvr.c
@@ -478,6 +478,8 @@ int ssl3_accept(SSL *s)
 #endif
                 || (alg_k & SSL_kEDH)
                 || (alg_k & SSL_kEECDH)
+                || (alg_k & SSL_kSIDH)
+				|| (alg_k & SSL_kSIDHECDHEHYBRID)
                 || ((alg_k & SSL_kRSA)
                     && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
                         || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
@@ -1613,6 +1615,11 @@ int ssl3_send_server_key_exchange(SSL *s)
     int curve_id = 0;
     BN_CTX *bn_ctx = NULL;
 #endif
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PAIR *sidh=NULL;
+    unsigned char *encoded_sidhpub = NULL;
+    int encoded_sidhpub_len = 0;
+#endif
     EVP_PKEY *pkey;
     const EVP_MD *md = NULL;
     unsigned char *p, *d;
@@ -1701,7 +1708,7 @@ int ssl3_send_server_key_exchange(SSL *s)
         } else
 #endif
 #ifndef OPENSSL_NO_ECDH
-        if (type & SSL_kEECDH) {
+        if (type & SSL_kEECDH || type & SSL_kSIDHECDHEHYBRID) {
             const EC_GROUP *group;
 
             ecdhp = cert->ecdh_tmp;
@@ -1827,8 +1834,92 @@ int ssl3_send_server_key_exchange(SSL *s)
             r[1] = NULL;
             r[2] = NULL;
             r[3] = NULL;
+
+	    if (type & SSL_kSIDHECDHEHYBRID) {
+	      // generate the SIDH keypair
+	      sidh = SIDH_PAIR_new();
+	      if (sidh == NULL)	{
+		al = SSL_AD_HANDSHAKE_FAILURE;
+		SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		goto err;
+	      }
+	      if (s->s3->tmp.sidh_ctx == NULL) {
+		/* initialize SIDH context */
+		s->s3->tmp.sidh_ctx = SIDH_CTX_new();
+		if (s->s3->tmp.sidh_ctx == NULL) {
+		  al = SSL_AD_HANDSHAKE_FAILURE;
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      }
+	      if (!SIDH_PAIR_generate_key_server(sidh, s->s3->tmp.sidh_ctx))
+		{
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      // save the SIDH keypair
+	      s->s3->tmp.sidh = sidh;
+
+	      encoded_sidhpub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(sidh), &encoded_sidhpub);
+
+	      if (encoded_sidhpub_len == 0) 
+		{
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_SIDH_LIB);
+		  goto err;
+		}
+
+	      n += 2 + encoded_sidhpub_len;
+	    }
         } else
 #endif                          /* !OPENSSL_NO_ECDH */
+#ifndef OPENSSL_NO_SIDH
+	    if (type & SSL_kSIDH || type & SSL_kSIDHECDHEHYBRID)
+	    {
+	      // generate the SIDH keypair
+	      sidh = SIDH_PAIR_new();
+	      if (sidh == NULL) 		{
+		al = SSL_AD_HANDSHAKE_FAILURE;
+		SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		goto err;
+	      }
+	      if (s->s3->tmp.sidh_ctx == NULL) {
+		/* initialize SIDH context */
+		s->s3->tmp.sidh_ctx = SIDH_CTX_new();
+		if (s->s3->tmp.sidh_ctx == NULL) {
+		  al = SSL_AD_HANDSHAKE_FAILURE;
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      }
+	      if (!SIDH_PAIR_generate_key_server(sidh, s->s3->tmp.sidh_ctx))
+		{
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+
+	      // save the SIDH keypair
+	      s->s3->tmp.sidh = sidh;
+
+	      encoded_sidhpub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(sidh), &encoded_sidhpub);
+
+	      if (encoded_sidhpub_len == 0) 
+		{
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_SIDH_LIB);
+		  goto err;
+		}
+
+	      n = 2 + encoded_sidhpub_len;
+
+	      /* We'll generate the serverKeyExchange message
+	       * explicitly so we can set these to NULLs
+	       */
+	      r[0]=NULL;
+	      r[1]=NULL;
+	      r[2]=NULL;
+	      r[3]=NULL;
+	    }
+		else
+#endif /* !OPENSSL_NO_SIDH */
 #ifndef OPENSSL_NO_PSK
         if (type & SSL_kPSK) {
             /*
@@ -1929,7 +2020,7 @@ int ssl3_send_server_key_exchange(SSL *s)
         }
 
 #ifndef OPENSSL_NO_ECDH
-        if (type & SSL_kEECDH) {
+		if (type & SSL_kEECDH || type & SSL_kSIDHECDHEHYBRID) {
             /*
              * XXX: For now, we only support named (not generic) curves. In
              * this situation, the serverKeyExchange message has: [1 byte
@@ -1951,7 +2042,19 @@ int ssl3_send_server_key_exchange(SSL *s)
             p += encodedlen;
         }
 #endif
-
+#ifndef OPENSSL_NO_SIDH
+	if (type & SSL_kSIDH || type & SSL_kSIDHECDHEHYBRID) 
+	  {
+	    p[0] = (encoded_sidhpub_len >> 8) & 0xFF;
+	    p[1] =  encoded_sidhpub_len       & 0xFF;
+	    p += 2;
+	    memcpy((unsigned char*)p, (unsigned char *)encoded_sidhpub, encoded_sidhpub_len);
+	    OPENSSL_free(encoded_sidhpub);
+	    encoded_sidhpub = NULL;
+	    p += encoded_sidhpub_len;
+	  }
+#endif
+ 
 #ifndef OPENSSL_NO_PSK
         if (type & SSL_kPSK) {
             /* copy PSK identity hint */
@@ -2057,6 +2160,9 @@ int ssl3_send_server_key_exchange(SSL *s)
         OPENSSL_free(encodedPoint);
     BN_CTX_free(bn_ctx);
 #endif
+#ifndef OPENSSL_NO_SIDH
+    if (encoded_sidhpub != NULL) OPENSSL_free(encoded_sidhpub);
+#endif
     EVP_MD_CTX_cleanup(&md_ctx);
     s->state = SSL_ST_ERR;
     return (-1);
@@ -2162,6 +2268,8 @@ int ssl3_get_client_key_exchange(SSL *s)
     long n;
     unsigned long alg_k;
     unsigned char *p;
+    unsigned char *pprime;
+    long nprime;
 #ifndef OPENSSL_NO_RSA
     RSA *rsa = NULL;
     EVP_PKEY *pkey = NULL;
@@ -2180,11 +2288,18 @@ int ssl3_get_client_key_exchange(SSL *s)
     EC_POINT *clnt_ecpoint = NULL;
     BN_CTX *bn_ctx = NULL;
 #endif
-
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PAIR *srvr_sidh = NULL;
+    SIDH_PUB *clnt_sidh_pub = NULL;
+    unsigned int clnt_sidh_pub_len;
+#endif
+ 
     n = s->method->ssl_get_message(s,
                                    SSL3_ST_SR_KEY_EXCH_A,
                                    SSL3_ST_SR_KEY_EXCH_B,
-                                   SSL3_MT_CLIENT_KEY_EXCHANGE, 2048, &ok);
+                                   SSL3_MT_CLIENT_KEY_EXCHANGE, 
+				   2048, // FIXME: is that too much?
+				   &ok);
 
     if (!ok)
         return ((int)n);
@@ -2621,7 +2736,7 @@ int ssl3_get_client_key_exchange(SSL *s)
 #endif                          /* OPENSSL_NO_KRB5 */
 
 #ifndef OPENSSL_NO_ECDH
-    if (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe)) {
+    if (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID)) {
         int ret = 1;
         int field_size = 0;
         const EC_KEY *tkey;
@@ -2707,7 +2822,7 @@ int ssl3_get_client_key_exchange(SSL *s)
             /* Get encoded point length */
             i = *p;
             p += 1;
-            if (n != 1 + i) {
+            if (n < 1 + i) {
                 SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, SSL_R_LENGTH_MISMATCH);
                 al = SSL_AD_DECODE_ERROR;
                 goto f_err;
@@ -2717,12 +2832,38 @@ int ssl3_get_client_key_exchange(SSL *s)
                 al = SSL_AD_HANDSHAKE_FAILURE;
                 goto f_err;
             }
-            /*
-             * p is pointing to somewhere in the buffer currently, so set it
-             * to the start
-             */
-            p = (unsigned char *)s->init_buf->data;
-        }
+	    p += i;
+	    n -= 1 + i;
+        }
+
+	if (alg_k & SSL_kSIDHECDHEHYBRID) {
+	  srvr_sidh = s->s3->tmp.sidh;
+	  
+	  /* Parse client public key */
+	  if (n < 2)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  clnt_sidh_pub_len = (p[0] << 8) | p[1];
+	  p += 2;
+	  if (n < 2 + clnt_sidh_pub_len)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  if (o2i_SIDH_PUB(&clnt_sidh_pub, p, clnt_sidh_pub_len) == 0)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  p += clnt_sidh_pub_len;
+	}
+
+	/* p is pointing to somewhere in the buffer
+	 * currently, so set it to the start 
+	 */ 
+	p=(unsigned char *)s->init_buf->data;
 
         /* Compute the shared pre-master secret */
         field_size = EC_GROUP_get_degree(group);
@@ -2743,6 +2884,30 @@ int ssl3_get_client_key_exchange(SSL *s)
         BN_CTX_free(bn_ctx);
         EC_KEY_free(s->s3->tmp.ecdh);
         s->s3->tmp.ecdh = NULL;
+ 
+	if (alg_k & SSL_kSIDHECDHEHYBRID) {
+	  /* Compute the shared pre-master secret */
+	  if ((pprime = OPENSSL_malloc(SIDH_PUBKEY_LEN)) == NULL) {
+	    SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
+	    goto err;
+	  }
+	  nprime = SIDH_compute_key_server(pprime, SIDH_PUBKEY_LEN, clnt_sidh_pub, srvr_sidh, NULL, s->s3->tmp.sidh_ctx);
+	  if (nprime <= 0)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  SIDH_PUB_free(clnt_sidh_pub);
+	  SIDH_PAIR_free(s->s3->tmp.sidh);
+	  s->s3->tmp.sidh = NULL; 
+	  SIDH_CTX_free(s->s3->tmp.sidh_ctx);
+	  s->s3->tmp.sidh_ctx = NULL;
+
+	  // FIXME: double-check if p is big enough
+	  memcpy(p + i, pprime, nprime);
+	  i += nprime;
+	  OPENSSL_free(pprime);
+	}
 
         /* Compute the master secret */
         s->session->master_key_length =
@@ -2755,6 +2920,61 @@ int ssl3_get_client_key_exchange(SSL *s)
         return (ret);
     } else
 #endif
+#ifndef OPENSSL_NO_SIDH
+      if ((alg_k & SSL_kSIDH) && !(alg_k & SSL_kEECDH))
+	{
+	  int ret = 1;
+	  srvr_sidh = s->s3->tmp.sidh;
+
+	  /* Parse client public key */
+	  if (n < 2)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  clnt_sidh_pub_len = (p[0] << 8) | p[1];
+	  p += 2;
+	  if (n < 2 + clnt_sidh_pub_len)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  if (o2i_SIDH_PUB(&clnt_sidh_pub, p, clnt_sidh_pub_len) == 0)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  p += clnt_sidh_pub_len;
+
+	  /* p is pointing to somewhere in the buffer
+	   * currently, so set it to the start 
+	   */ 
+	  p = (unsigned char *)s->init_buf->data;
+
+	  /* Compute the shared pre-master secret */
+
+	  n = SIDH_compute_key_server(p, SIDH_PUBKEY_LEN, clnt_sidh_pub, srvr_sidh, NULL, s->s3->tmp.sidh_ctx);
+	  if (n <= 0)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+
+	  SIDH_PUB_free(clnt_sidh_pub);
+	  SIDH_PAIR_free(s->s3->tmp.sidh);
+	  s->s3->tmp.sidh = NULL; 
+	  SIDH_CTX_free(s->s3->tmp.sidh_ctx);
+	  s->s3->tmp.sidh_ctx = NULL;
+
+	  /* Compute the master secret */
+	  s->session->master_key_length = s->method->ssl3_enc-> \
+	    generate_master_secret(s, s->session->master_key, p, n);
+		
+	  OPENSSL_cleanse(p, n);
+	  return (ret);
+	}
+      else
+#endif
 #ifndef OPENSSL_NO_PSK
     if (alg_k & SSL_kPSK) {
         unsigned char *t = NULL;
@@ -2968,7 +3188,7 @@ int ssl3_get_client_key_exchange(SSL *s)
     return (1);
  f_err:
     ssl3_send_alert(s, SSL3_AL_FATAL, al);
-#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH) || defined(OPENSSL_NO_SRP)
+#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH) || defined(OPENSSL_NO_SRP) || !defined(OPENSSL_NO_SIDH)
  err:
 #endif
 #ifndef OPENSSL_NO_ECDH
@@ -2978,6 +3198,9 @@ int ssl3_get_client_key_exchange(SSL *s)
         EC_KEY_free(srvr_ecdh);
     BN_CTX_free(bn_ctx);
 #endif
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PUB_free(clnt_sidh_pub);
+#endif
     s->state = SSL_ST_ERR;
     return (-1);
 }
diff --git a/ssl/ssl.h b/ssl/ssl.h
index 90aeb0c..eddac04 100644
--- a/ssl/ssl.h
+++ b/ssl/ssl.h
@@ -253,6 +253,7 @@ extern "C" {
 # define SSL_TXT_kECDH           "kECDH"
 # define SSL_TXT_kEECDH          "kEECDH"
 # define SSL_TXT_kECDHE          "kECDHE"/* alias for kEECDH */
+# define SSL_TXT_kSIDH		 "kSIDH"
 # define SSL_TXT_kPSK            "kPSK"
 # define SSL_TXT_kGOST           "kGOST"
 # define SSL_TXT_kSRP            "kSRP"
@@ -280,6 +281,7 @@ extern "C" {
 # define SSL_TXT_ECDHE           "ECDHE"/* alias for ECDHE" */
 # define SSL_TXT_AECDH           "AECDH"
 # define SSL_TXT_ECDSA           "ECDSA"
+# define SSL_TXT_SIDH		 "SIDH" /* same as "kSIDH" */
 # define SSL_TXT_KRB5            "KRB5"
 # define SSL_TXT_PSK             "PSK"
 # define SSL_TXT_SRP             "SRP"
@@ -2860,6 +2862,7 @@ void ERR_load_SSL_strings(void);
 # define SSL_R_BAD_PROTOCOL_VERSION_NUMBER                116
 # define SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH               316
 # define SSL_R_BAD_RESPONSE_ARGUMENT                      117
+# define SSL_R_BAD_SIDH_PUB				  373
 # define SSL_R_BAD_RSA_DECRYPT                            118
 # define SSL_R_BAD_RSA_ENCRYPT                            119
 # define SSL_R_BAD_RSA_E_LENGTH                           120
diff --git a/ssl/ssl3.h b/ssl/ssl3.h
index e681d50..d79ec29 100644
--- a/ssl/ssl3.h
+++ b/ssl/ssl3.h
@@ -123,6 +123,9 @@
 # include <openssl/buffer.h>
 # include <openssl/evp.h>
 # include <openssl/ssl.h>
+#ifndef OPENSSL_NO_SIDH
+#include <openssl/sidh.h>
+#endif
 
 #ifdef  __cplusplus
 extern "C" {
@@ -568,6 +571,10 @@ typedef struct ssl3_state_st {
 #  ifndef OPENSSL_NO_ECDH
         EC_KEY *ecdh;           /* holds short lived ECDH key */
 #  endif
+#ifndef OPENSSL_NO_SIDH
+      SIDH_PAIR *sidh; /* holds short lived SIDH key */
+      SIDH_CTX *sidh_ctx; /* holds SIDH context */
+#endif
         /* used when SSL_ST_FLUSH_DATA is entered */
         int next_state;
         int reuse_message;
diff --git a/ssl/ssl_cert.c b/ssl/ssl_cert.c
index 1be6fb0..3a5dff3 100644
--- a/ssl/ssl_cert.c
+++ b/ssl/ssl_cert.c
@@ -695,6 +695,10 @@ void ssl_sess_cert_free(SESS_CERT *sc)
     if (sc->peer_ecdh_tmp != NULL)
         EC_KEY_free(sc->peer_ecdh_tmp);
 #endif
+#ifndef OPENSSL_NO_SIDH
+    if (sc->peer_sidhpub_tmp != NULL)
+      SIDH_PUB_free(sc->peer_sidhpub_tmp);
+#endif
 
     OPENSSL_free(sc);
 }
diff --git a/ssl/ssl_ciph.c b/ssl/ssl_ciph.c
index 2ad8f43..196ab04 100644
--- a/ssl/ssl_ciph.c
+++ b/ssl/ssl_ciph.c
@@ -259,6 +259,7 @@ static const SSL_CIPHER cipher_aliases[] = {
     {0, SSL_TXT_kECDH, 0, SSL_kECDHr | SSL_kECDHe, 0, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_kEECDH, 0, SSL_kEECDH, 0, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_kECDHE, 0, SSL_kEECDH, 0, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_kSIDH, 0, SSL_kSIDH, 0, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_ECDH, 0, SSL_kECDHr | SSL_kECDHe | SSL_kEECDH, 0, 0, 0, 0, 0,
      0, 0, 0},
 
@@ -288,6 +289,7 @@ static const SSL_CIPHER cipher_aliases[] = {
     {0, SSL_TXT_DHE, 0, SSL_kEDH, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_EECDH, 0, SSL_kEECDH, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_ECDHE, 0, SSL_kEECDH, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_SIDH, 0, SSL_kSIDH, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_NULL, 0, 0, 0, SSL_eNULL, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_KRB5, 0, SSL_kKRB5, SSL_aKRB5, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_RSA, 0, SSL_kRSA, SSL_aRSA, 0, 0, 0, 0, 0, 0, 0},
@@ -1728,6 +1730,9 @@ char *SSL_CIPHER_description(const SSL_CIPHER *cipher, char *buf, int len)
     case SSL_kEECDH:
         kx = "ECDH";
         break;
+    case SSL_kSIDH:
+        kx="SIDH";
+	break;
     case SSL_kPSK:
         kx = "PSK";
         break;
diff --git a/ssl/ssl_err.c b/ssl/ssl_err.c
index a4c17a6..a428f26 100644
--- a/ssl/ssl_err.c
+++ b/ssl/ssl_err.c
@@ -412,6 +412,7 @@ static ERR_STRING_DATA SSL_str_reasons[] = {
     {ERR_REASON(SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH),
      "bad psk identity hint length"},
     {ERR_REASON(SSL_R_BAD_RESPONSE_ARGUMENT), "bad response argument"},
+    {ERR_REASON(SSL_R_BAD_SIDH_PUB), "bad sidh pub"},
     {ERR_REASON(SSL_R_BAD_RSA_DECRYPT), "bad rsa decrypt"},
     {ERR_REASON(SSL_R_BAD_RSA_ENCRYPT), "bad rsa encrypt"},
     {ERR_REASON(SSL_R_BAD_RSA_E_LENGTH), "bad rsa e length"},
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index f8054da..6c7452d 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -2431,7 +2431,13 @@ void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)
         emask_k |= SSL_kEECDH;
     }
 #endif
-
+#ifndef OPENSSL_NO_SIDH
+    mask_k|=SSL_kSIDH;
+    emask_k|=SSL_kSIDH;
+	mask_k |= SSL_kSIDHECDHEHYBRID;
+	emask_k |= SSL_kSIDHECDHEHYBRID;
+#endif
+ 
 #ifndef OPENSSL_NO_PSK
     mask_k |= SSL_kPSK;
     mask_a |= SSL_aPSK;
diff --git a/ssl/ssl_locl.h b/ssl/ssl_locl.h
index d50edd1..2812795 100644
--- a/ssl/ssl_locl.h
+++ b/ssl/ssl_locl.h
@@ -161,6 +161,9 @@
 # ifndef OPENSSL_NO_DSA
 #  include <openssl/dsa.h>
 # endif
+#ifndef OPENSSL_NO_SIDH
+#include <openssl/sidh.h>
+#endif
 # include <openssl/err.h>
 # include <openssl/ssl.h>
 # include <openssl/symhacks.h>
@@ -314,6 +317,9 @@
 # define SSL_kGOST       0x00000200L
 /* SRP */
 # define SSL_kSRP        0x00000400L
+/* SIDH */
+# define SSL_kSIDH	0x00001000L
+# define SSL_kSIDHECDHEHYBRID        0x00002000L
 
 /* Bits for algorithm_auth (server authentication) */
 /* RSA auth */
@@ -633,6 +639,7 @@ typedef struct cert_st {
     /* Select ECDH parameters automatically */
     int ecdh_tmp_auto;
 # endif
+
     /* Flags related to certificates */
     unsigned int cert_flags;
     CERT_PKEY pkeys[SSL_PKEY_NUM];
@@ -724,6 +731,10 @@ typedef struct sess_cert_st {
 # ifndef OPENSSL_NO_ECDH
     EC_KEY *peer_ecdh_tmp;
 # endif
+#ifndef OPENSSL_NO_SIDH
+  SIDH_PUB *peer_sidhpub_tmp;
+#endif
+
     int references;             /* actually always 1 at the moment */
 } SESS_CERT;
 /* Structure containing decoded values of signature algorithms extension */
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index e60c88b..0ca0a8b 100644
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -1246,7 +1246,7 @@ unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
 
             alg_k = c->algorithm_mkey;
             alg_a = c->algorithm_auth;
-            if ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe)
+			if ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID)
                  || (alg_a & SSL_aECDSA))) {
                 using_ecc = 1;
                 break;
@@ -1674,7 +1674,7 @@ unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,
 # ifndef OPENSSL_NO_EC
     unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
     unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;
-    int using_ecc = (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe))
+	int using_ecc = (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID))
         || (alg_a & SSL_aECDSA);
     using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);
 # endif
@@ -3232,7 +3232,7 @@ int ssl_check_serverhello_tlsext(SSL *s)
         && (s->tlsext_ecpointformatlist_length > 0)
         && (s->session->tlsext_ecpointformatlist != NULL)
         && (s->session->tlsext_ecpointformatlist_length > 0)
-        && ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe))
+		&& ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID))
             || (alg_a & SSL_aECDSA))) {
         /* we are using an ECC cipher */
         size_t i;
diff --git a/ssl/t1_trce.c b/ssl/t1_trce.c
index c5e21df..a8e2f3f 100644
--- a/ssl/t1_trce.c
+++ b/ssl/t1_trce.c
@@ -813,7 +813,16 @@ static int ssl_get_keyex(const char **pname, SSL *ssl)
         *pname = "GOST";
         return SSL_kGOST;
     }
-    *pname = "UNKNOWN";
+	if (alg_k & SSL_kSIDH) {
+		*pname = "SIDH";
+		return SSL_kSIDH;
+	}
+	if (alg_k & SSL_kSIDHECDHEHYBRID) {
+		*pname = "SIDH ECDH hybrid";
+		return SSL_kSIDHECDHEHYBRID;
+	}
+
+	*pname = "UNKNOWN";
     return 0;
 }
 
diff --git a/ssl/tls1.h b/ssl/tls1.h
index 7e237d0..49a2a16 100644
--- a/ssl/tls1.h
+++ b/ssl/tls1.h
@@ -563,6 +563,14 @@ SSL_CTX_callback_ctrl(ssl,SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB,(void (*)(void))cb)
 # define TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256        0x0300C031
 # define TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384        0x0300C032
 
+/* SIDH based ciphersuites */
+#ifndef OPENSSL_NO_SIDH
+#define TLS1_CK_SIDH_RSA_WITH_AES_128_GCM_SHA256        0x0300E010
+#define TLS1_CK_SIDH_ECDSA_WITH_AES_128_GCM_SHA256      0x0300E011
+#define TLS1_CK_SIDH_ECDHE_RSA_WITH_AES_128_GCM_SHA256        0x0300E012
+#define TLS1_CK_SIDH_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256      0x0300E013
+#endif
+
 /*
  * XXX * Backward compatibility alert: + * Older versions of OpenSSL gave
  * some DHE ciphers names with "EDH" + * instead of "DHE".  Going forward, we
@@ -713,6 +721,13 @@ SSL_CTX_callback_ctrl(ssl,SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB,(void (*)(void))cb)
 # define TLS1_TXT_ECDH_RSA_WITH_AES_128_GCM_SHA256       "ECDH-RSA-AES128-GCM-SHA256"
 # define TLS1_TXT_ECDH_RSA_WITH_AES_256_GCM_SHA384       "ECDH-RSA-AES256-GCM-SHA384"
 
+#ifndef OPENSSL_NO_SIDH
+#define TLS1_TXT_SIDH_RSA_WITH_AES_128_GCM_SHA256        "SIDH-RSA-AES128-GCM-SHA256"
+#define TLS1_TXT_SIDH_ECDSA_WITH_AES_128_GCM_SHA256      "SIDH-ECDSA-AES128-GCM-SHA256"
+#define TLS1_TXT_SIDH_ECDHE_RSA_WITH_AES_128_GCM_SHA256        "SIDH-ECDHE-RSA-AES128-GCM-SHA256"
+#define TLS1_TXT_SIDH_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256      "SIDH-ECDHE-ECDSA-AES128-GCM-SHA256"
+#endif
+
 # define TLS_CT_RSA_SIGN                 1
 # define TLS_CT_DSS_SIGN                 2
 # define TLS_CT_RSA_FIXED_DH             3
diff --git a/test/Makefile b/test/Makefile
index 8f272ef..6d9734c 100644
--- a/test/Makefile
+++ b/test/Makefile
@@ -33,6 +33,7 @@ BNTEST=		bntest
 ECTEST=		ectest
 ECDSATEST=	ecdsatest
 ECDHTEST=	ecdhtest
+SIDHKEXTEST=	sidhkextest
 EXPTEST=	exptest
 IDEATEST=	ideatest
 SHATEST=	shatest
@@ -76,7 +77,7 @@ DTLSTEST =	dtlstest
 
 TESTS=		alltests
 
-EXE=	$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)$(EXE_EXT) $(IDEATEST)$(EXE_EXT) \
+EXE=	$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)$(EXE_EXT) $(SIDHKEXTEST)$(EXE_EXT) $(IDEATEST)$(EXE_EXT) \
 	$(MD2TEST)$(EXE_EXT)  $(MD4TEST)$(EXE_EXT) $(MD5TEST)$(EXE_EXT) $(HMACTEST)$(EXE_EXT) $(WPTEST)$(EXE_EXT) \
 	$(RC2TEST)$(EXE_EXT) $(RC4TEST)$(EXE_EXT) $(RC5TEST)$(EXE_EXT) \
 	$(DESTEST)$(EXE_EXT) $(SHATEST)$(EXE_EXT) $(SHA1TEST)$(EXE_EXT) $(SHA256TEST)$(EXE_EXT) $(SHA512TEST)$(EXE_EXT) \
@@ -91,7 +92,7 @@ EXE=	$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)
 
 # $(METHTEST)$(EXE_EXT)
 
-OBJ=	$(BNTEST).o $(ECTEST).o  $(ECDSATEST).o $(ECDHTEST).o $(IDEATEST).o \
+OBJ=	$(BNTEST).o $(ECTEST).o  $(ECDSATEST).o $(ECDHTEST).o $(SIDHKEXTEST).o $(IDEATEST).o \
 	$(MD2TEST).o $(MD4TEST).o $(MD5TEST).o \
 	$(HMACTEST).o $(WPTEST).o \
 	$(RC2TEST).o $(RC4TEST).o $(RC5TEST).o \
@@ -104,7 +105,7 @@ OBJ=	$(BNTEST).o $(ECTEST).o  $(ECDSATEST).o $(ECDHTEST).o $(IDEATEST).o \
 	$(CLIENTHELLOTEST).o  $(SSLV2CONFTEST).o $(DTLSTEST).o ssltestlib.o \
 	$(BADDTLSTEST).o
 
-SRC=	$(BNTEST).c $(ECTEST).c  $(ECDSATEST).c $(ECDHTEST).c $(IDEATEST).c \
+SRC=	$(BNTEST).c $(ECTEST).c  $(ECDSATEST).c $(ECDHTEST).c $(SIDHKEXTEST).c $(IDEATEST).c \
 	$(MD2TEST).c  $(MD4TEST).c $(MD5TEST).c \
 	$(HMACTEST).c $(WPTEST).c \
 	$(RC2TEST).c $(RC4TEST).c $(RC5TEST).c \
@@ -153,7 +154,7 @@ alltests: \
 	test_des test_idea test_sha test_md4 test_md5 test_hmac \
 	test_md2 test_mdc2 test_wp \
 	test_rmd test_rc2 test_rc4 test_rc5 test_bf test_cast test_aes \
-	test_rand test_bn test_ec test_ecdsa test_ecdh \
+	test_rand test_bn test_ec test_ecdsa test_ecdh test_sidhkex \
 	test_enc test_x509 test_rsa test_crl test_sid \
 	test_gen test_req test_pkcs7 test_verify test_dh test_dsa \
 	test_ss test_ca test_engine test_evp test_evp_extra test_ssl test_tsa test_ige \
@@ -268,6 +269,10 @@ test_ecdh: $(ECDHTEST)$(EXE_EXT)
 	@echo 'test ecdh'
 	../util/shlib_wrap.sh ./$(ECDHTEST)
 
+test_sidhkex: $(SIDHKEXTEST)$(EXE_EXT)
+	@echo 'test sidh'
+	../util/shlib_wrap.sh ./$(SIDHKEXTEST)
+
 test_verify: ../apps/openssl$(EXE_EXT)
 	@echo "The following command should have some OK's and some failures"
 	@echo "There are definitly a few expired certificates"
@@ -530,6 +535,9 @@ $(ECDSATEST)$(EXE_EXT): $(ECDSATEST).o $(DLIBCRYPTO)
 $(ECDHTEST)$(EXE_EXT): $(ECDHTEST).o $(DLIBCRYPTO)
 	@target=$(ECDHTEST); $(BUILD_CMD)
 
+$(SIDHKEXTEST)$(EXE_EXT): $(SIDHKEXTEST).o $(DLIBCRYPTO)
+	@target=$(SIDHKEXTEST); $(BUILD_CMD)
+
 $(IGETEST)$(EXE_EXT): $(IGETEST).o $(DLIBCRYPTO)
 	@target=$(IGETEST); $(BUILD_CMD)
 
@@ -631,25 +639,25 @@ bntest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h bntest.c
 casttest.o: ../e_os.h ../include/openssl/cast.h ../include/openssl/e_os2.h
 casttest.o: ../include/openssl/opensslconf.h casttest.c
 clienthellotest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-clienthellotest.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-clienthellotest.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-clienthellotest.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-clienthellotest.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-clienthellotest.o: ../include/openssl/err.h ../include/openssl/evp.h
-clienthellotest.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-clienthellotest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-clienthellotest.o: ../include/openssl/objects.h
+clienthellotest.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+clienthellotest.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+clienthellotest.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+clienthellotest.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+clienthellotest.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+clienthellotest.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+clienthellotest.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+clienthellotest.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
 clienthellotest.o: ../include/openssl/opensslconf.h
 clienthellotest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 clienthellotest.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 clienthellotest.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 clienthellotest.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-clienthellotest.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-clienthellotest.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-clienthellotest.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-clienthellotest.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-clienthellotest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
-clienthellotest.o: clienthellotest.c
+clienthellotest.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+clienthellotest.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+clienthellotest.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+clienthellotest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+clienthellotest.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+clienthellotest.o: ../include/openssl/x509_vfy.h clienthellotest.c
 constant_time_test.o: ../crypto/constant_time_locl.h ../e_os.h
 constant_time_test.o: ../include/openssl/e_os2.h
 constant_time_test.o: ../include/openssl/opensslconf.h constant_time_test.c
@@ -776,26 +784,26 @@ exptest.o: ../include/openssl/ossl_typ.h ../include/openssl/rand.h
 exptest.o: ../include/openssl/safestack.h ../include/openssl/stack.h
 exptest.o: ../include/openssl/symhacks.h exptest.c
 heartbeat_test.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-heartbeat_test.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-heartbeat_test.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-heartbeat_test.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-heartbeat_test.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-heartbeat_test.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-heartbeat_test.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-heartbeat_test.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-heartbeat_test.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-heartbeat_test.o: ../include/openssl/opensslconf.h
+heartbeat_test.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+heartbeat_test.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+heartbeat_test.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+heartbeat_test.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+heartbeat_test.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+heartbeat_test.o: ../include/openssl/err.h ../include/openssl/evp.h
+heartbeat_test.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+heartbeat_test.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+heartbeat_test.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
 heartbeat_test.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 heartbeat_test.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 heartbeat_test.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 heartbeat_test.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-heartbeat_test.o: ../include/openssl/sha.h ../include/openssl/srtp.h
-heartbeat_test.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
-heartbeat_test.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
-heartbeat_test.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-heartbeat_test.o: ../include/openssl/tls1.h ../include/openssl/x509.h
-heartbeat_test.o: ../include/openssl/x509_vfy.h ../ssl/ssl_locl.h
-heartbeat_test.o: ../test/testutil.h heartbeat_test.c
+heartbeat_test.o: ../include/openssl/sha.h ../include/openssl/sidh.h
+heartbeat_test.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
+heartbeat_test.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
+heartbeat_test.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
+heartbeat_test.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
+heartbeat_test.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+heartbeat_test.o: ../ssl/ssl_locl.h ../test/testutil.h heartbeat_test.c
 hmactest.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 hmactest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
 hmactest.o: ../include/openssl/evp.h ../include/openssl/hmac.h
@@ -884,6 +892,16 @@ shatest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
 shatest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 shatest.o: ../include/openssl/safestack.h ../include/openssl/sha.h
 shatest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h shatest.c
+sidhkextest.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
+sidhkextest.o: ../include/openssl/bn.h ../include/openssl/crypto.h
+sidhkextest.o: ../include/openssl/e_os2.h ../include/openssl/err.h
+sidhkextest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+sidhkextest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+sidhkextest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+sidhkextest.o: ../include/openssl/rand.h ../include/openssl/safestack.h
+sidhkextest.o: ../include/openssl/sha.h ../include/openssl/sidh.h
+sidhkextest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+sidhkextest.o: sidhkextest.c
 srptest.o: ../include/openssl/bio.h ../include/openssl/bn.h
 srptest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
 srptest.o: ../include/openssl/err.h ../include/openssl/lhash.h
@@ -907,26 +925,28 @@ ssltest.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
 ssltest.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
 ssltest.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
 ssltest.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-ssltest.o: ../include/openssl/sha.h ../include/openssl/srp.h
-ssltest.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-ssltest.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-ssltest.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-ssltest.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-ssltest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
-ssltest.o: ../include/openssl/x509v3.h ssltest.c
+ssltest.o: ../include/openssl/sha.h ../include/openssl/sidh.h
+ssltest.o: ../include/openssl/srp.h ../include/openssl/srtp.h
+ssltest.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+ssltest.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+ssltest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+ssltest.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+ssltest.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h
+ssltest.o: ssltest.c
 ssltestlib.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-ssltestlib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssltestlib.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-ssltestlib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-ssltestlib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-ssltestlib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssltestlib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssltestlib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssltestlib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssltestlib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssltestlib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssltestlib.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
-ssltestlib.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+ssltestlib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssltestlib.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssltestlib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+ssltestlib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+ssltestlib.o: ../include/openssl/ecdsa.h ../include/openssl/evp.h
+ssltestlib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssltestlib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssltestlib.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssltestlib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssltestlib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssltestlib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssltestlib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssltestlib.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 ssltestlib.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 ssltestlib.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 ssltestlib.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
diff --git a/util/libeay.num b/util/libeay.num
index 2094ab3..8d59c62 100755
--- a/util/libeay.num
+++ b/util/libeay.num
@@ -4416,3 +4416,21 @@ X509_VERIFY_PARAM_add1_host             4771	EXIST::FUNCTION:
 EC_GROUP_get_mont_data                  4772	EXIST::FUNCTION:EC
 i2d_re_X509_tbs                         4773	EXIST::FUNCTION:
 EVP_PKEY_asn1_set_item                  4774	EXIST::FUNCTION:
+SIDH_CTX_new				4775	EXIST::FUNCTION:SIDH
+SIDH_CTX_free				4776	EXIST::FUNCTION:SIDH
+SIDH_PUB_new				4777	EXIST::FUNCTION:SIDH
+SIDH_PUB_copy				4778	EXIST::FUNCTION:SIDH
+SIDH_PUB_free				4779	EXIST::FUNCTION:SIDH
+SIDH_PAIR_new				4780	EXIST::FUNCTION:SIDH
+SIDH_PAIR_copy				4781	EXIST::FUNCTION:SIDH
+SIDH_PAIR_dup				4782	EXIST::FUNCTION:SIDH
+SIDH_PAIR_free				4783	EXIST::FUNCTION:SIDH
+SIDH_PAIR_generate_key_server		4784	EXIST::FUNCTION:SIDH
+SIDH_PAIR_generate_key_client		4785	EXIST::FUNCTION:SIDH
+o2i_SIDH_PUB				4786	EXIST::FUNCTION:SIDH
+i2o_SIDH_PUB				4787	EXIST::FUNCTION:SIDH
+SIDH_PAIR_get_publickey			4788	EXIST::FUNCTION:SIDH
+SIDH_PAIR_has_privatekey		4789	EXIST::FUNCTION:SIDH
+SIDH_compute_key_server			4790	EXIST::FUNCTION:SIDH
+SIDH_compute_key_client			4791	EXIST::FUNCTION:SIDH
+ERR_load_SIDH_strings			4792	EXIST::FUNCTION:SIDH
diff --git a/util/mk1mf.pl b/util/mk1mf.pl
index 7a3ae11..6ddb2e7 100755
--- a/util/mk1mf.pl
+++ b/util/mk1mf.pl
@@ -120,6 +120,7 @@ and [options] can be one of
 	no-ec					- No EC
 	no-ecdsa				- No ECDSA
 	no-ecdh					- No ECDH
+	no-sidh				        - No SIDH
 	no-engine				- No engine
 	no-hw					- No hw
 	nasm 					- Use NASM for x86 asm
@@ -285,6 +286,7 @@ $cflags.=" -DOPENSSL_NO_KRB5" if $no_krb5;
 $cflags.=" -DOPENSSL_NO_EC"   if $no_ec;
 $cflags.=" -DOPENSSL_NO_ECDSA" if $no_ecdsa;
 $cflags.=" -DOPENSSL_NO_ECDH" if $no_ecdh;
+$cflags.=" -DOPENSSL_NO_SIDH" if $no_sidh;
 $cflags.=" -DOPENSSL_NO_GOST" if $no_gost;
 $cflags.=" -DOPENSSL_NO_ENGINE"   if $no_engine;
 $cflags.=" -DOPENSSL_NO_HW"   if $no_hw;
@@ -1219,6 +1221,7 @@ sub read_options
 		"no-ec" => \$no_ec,
 		"no-ecdsa" => \$no_ecdsa,
 		"no-ecdh" => \$no_ecdh,
+		"no-sidh" => \$no_sidh,
 		"no-gost" => \$no_gost,
 		"no-engine" => \$no_engine,
 		"no-hw" => \$no_hw,
diff --git a/util/mkdef.pl b/util/mkdef.pl
index b9b159a..845942e 100755
--- a/util/mkdef.pl
+++ b/util/mkdef.pl
@@ -84,7 +84,7 @@ my @known_ossl_platforms = ( "VMS", "WIN16", "WIN32", "WINNT", "OS2" );
 my @known_algorithms = ( "RC2", "RC4", "RC5", "IDEA", "DES", "BF",
 			 "CAST", "MD2", "MD4", "MD5", "SHA", "SHA0", "SHA1",
 			 "SHA256", "SHA512", "RIPEMD",
-			 "MDC2", "WHIRLPOOL", "RSA", "DSA", "DH", "EC", "ECDH", "ECDSA", "EC2M",
+			 "MDC2", "WHIRLPOOL", "RSA", "DSA", "DH", "EC", "ECDH", "SIDH", "ECDSA", "EC2M",
 			 "HMAC", "AES", "CAMELLIA", "SEED", "GOST",
 			 # EC_NISTP_64_GCC_128
 			 "EC_NISTP_64_GCC_128",
@@ -142,7 +142,7 @@ my $no_rc2; my $no_rc4; my $no_rc5; my $no_idea; my $no_des; my $no_bf;
 my $no_cast; my $no_whirlpool; my $no_camellia; my $no_seed;
 my $no_md2; my $no_md4; my $no_md5; my $no_sha; my $no_ripemd; my $no_mdc2;
 my $no_rsa; my $no_dsa; my $no_dh; my $no_hmac=0; my $no_aes; my $no_krb5;
-my $no_ec; my $no_ecdsa; my $no_ecdh; my $no_engine; my $no_hw;
+my $no_ec; my $no_ecdsa; my $no_ecdh; my $no_sidh; my $no_engine; my $no_hw;
 my $no_fp_api; my $no_static_engine=1; my $no_gmp; my $no_deprecated;
 my $no_rfc3779; my $no_psk; my $no_tlsext; my $no_cms; my $no_capieng;
 my $no_jpake; my $no_srp; my $no_ssl2; my $no_ec2m; my $no_nistp_gcc; 
@@ -218,6 +218,7 @@ foreach (@ARGV, split(/ /, $options))
 	elsif (/^no-ec$/)       { $no_ec=1; }
 	elsif (/^no-ecdsa$/)	{ $no_ecdsa=1; }
 	elsif (/^no-ecdh$/) 	{ $no_ecdh=1; }
+	elsif (/^no-sidh$/) 	{ $no_sidh=1; }
 	elsif (/^no-hmac$/)	{ $no_hmac=1; }
 	elsif (/^no-aes$/)	{ $no_aes=1; }
 	elsif (/^no-camellia$/)	{ $no_camellia=1; }
@@ -279,6 +280,7 @@ if (!$do_ssl && !$do_crypto)
 	exit(1);
 	}
 
+
 %ssl_list=&load_numbers($ssl_num);
 $max_ssl = $max_num;
 %crypto_list=&load_numbers($crypto_num);
@@ -319,6 +321,7 @@ $crypto.=" crypto/dh/dh.h" ; # unless $no_dh;
 $crypto.=" crypto/ec/ec.h" ; # unless $no_ec;
 $crypto.=" crypto/ecdsa/ecdsa.h" ; # unless $no_ecdsa;
 $crypto.=" crypto/ecdh/ecdh.h" ; # unless $no_ecdh;
+$crypto.=" crypto/sidh/sidh.h" ; # unless $no_sidh;
 $crypto.=" crypto/hmac/hmac.h" ; # unless $no_hmac;
 $crypto.=" crypto/cmac/cmac.h" ; # unless $no_hmac;
 
@@ -361,7 +364,6 @@ my $symhacks="crypto/symhacks.h";
 
 my @ssl_symbols = &do_defs("SSLEAY", $ssl, $symhacks);
 my @crypto_symbols = &do_defs("LIBEAY", $crypto, $symhacks);
-
 if ($do_update) {
 
 if ($do_ssl == 1) {
@@ -469,6 +471,7 @@ sub do_defs
 			my ($a1, $a2);
 
 			print STDERR "DEBUG: make_variant: Entered with ",$s,", ",$a,", ",(defined($p)?$p:""),", ",(defined($k)?$k:""),"\n" if $debug;
+
 			if (defined($p))
 			{
 				$a1 = join(",",$p,
@@ -1191,6 +1194,7 @@ sub is_valid
 			if ($keyword eq "EC" && $no_ec) { return 0; }
 			if ($keyword eq "ECDSA" && $no_ecdsa) { return 0; }
 			if ($keyword eq "ECDH" && $no_ecdh) { return 0; }
+			if ($keyword eq "SIDH" && $no_sidh) { return 0; }
 			if ($keyword eq "HMAC" && $no_hmac) { return 0; }
 			if ($keyword eq "AES" && $no_aes) { return 0; }
 			if ($keyword eq "CAMELLIA" && $no_camellia) { return 0; }
diff --git a/util/mkfiles.pl b/util/mkfiles.pl
index 7d9a9d5..ee87b73 100755
--- a/util/mkfiles.pl
+++ b/util/mkfiles.pl
@@ -35,6 +35,7 @@ my @dirs = (
 "crypto/dh",
 "crypto/ec",
 "crypto/ecdh",
+"crypto/sidh",
 "crypto/ecdsa",
 "crypto/buffer",
 "crypto/bio",
-- 
2.1.4

